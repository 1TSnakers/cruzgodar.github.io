<!DOCTYPE html><html lang="en"><head><title>Cruz Godar</title><meta property="og:title" content="Cruz Godar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://cruzgodar.com/papers/bijectivizing-the-pt-dt-correspondence/"/><meta property="og:image" content="https://cruzgodar.com/papers/bijectivizing-the-pt-dt-correspondence/cover.jpg"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Cruz Godar"/><style>body {opacity: 0;}</style></head><body><noscript><p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p></noscript><p class="body-text">header Bijectivizing the PT-DT Correspondence</p><div id="slide-container"><div id="help" class="slide"><p class="body-text">text h Lapsa Basics</p><p class="body-text">text b j To move forward through Lapsa slides, use the arrow keys on a keyboard or tap with two fingers on a touchscreen. Try it now!</p><div class="build build-0"><p class="body-text">text b j Move the mouse cursor to the middle of the left edge of the window, or tap with three fingers, to open the shelf. Use the single-arrow buttons to step forward and back, and the fast-forward and rewind buttons to jump a whole slide at a time.</p></div><div class="build build-1"><p class="body-text">text b j The menu in the bottom-left contains visual settings, with options for dark themes, higher contrast, and reducing the amount of animation.</p></div><div class="build build-2"><p class="body-text">text b j Lapsa tries to display identically on screens of all sizes, but it works best with aspect ratios that aren&#x2019;t extremely narrow. If you&#x2019;re using a phone, try rotating it to landscape!</p></div></div><div id="title" class="slide medium-canvas"><p class="body-text">text h Bijectivizing the PT-DT Correspondence</p><p class="body-text">text s Cruz Godar, University of Oregon</p><div class="footer-text"><p class="body-text"><a id="help-link" onclick="Page.Presentation.jump_to_slide(0)">How do I control this presentation?</a></p></div><div id="canvas-bundle"><div data-aos="fade-up"><div style="position: absolute; width: 100%"><canvas id="output-canvas"></canvas></div><div id="numbers-canvas-container" style="width: 100%; opacity: 0"><canvas id="numbers-canvas"></canvas></div></div></div></div><div class="slide"><p class="body-text">text h Integer Partitions and Young Diagrams</p><div class="build build-0"><p class="body-text">text b j A <dfn>partition</dfn> of an integer $ n $ is a sequence $ (a_1, a_2, ... ) $ with $ a_i \in \mathbb{N}_{\geq 0} $ and $ a_i \geq a_{i + 1} $ for all $ i $, such that $ \sum_i a_i = n $.</p></div><div class="build build-1"><p class="body-text">text b j Ex: $ (5, 3, 2, 2, 1, 0, 0, ...) $ is a partition of $ 13 $.</p></div><div class="build build-2"><p class="body-text">text b j The <dfn>Young diagram</dfn> corresponding to a partition $ (a_i) $ is the set $ \{(i, j) \in \mathbb{N}^2 \mid 1 \leq j \leq a_i\} $.</p></div><div class="build build-3"><p class="body-text">text b j We usually treat these as top-left-justified sets of squares in a grid, so that $ a_i $ is the length of row $ i $.</p></div></div><div id="young-diagram-example" class="slide large-canvas"><p class="body-text">text b j Ex: the Young diagram of $ (5, 3, 2, 2, 1, 0, 0, ...) $.</p></div><div class="slide"><p class="body-text">text h Plane Partitions</p><div class="build build-0"><p class="body-text">text b j A <dfn>plane partition</dfn> is a placement of nonnegative integers into a Young diagram, such that the rows and columns weakly decrease. We can also think of them as a stacks of boxes, with each number indicating how many boxes are stacked on that square.</p></div><div class="build build-1"><p class="body-text">text b j The weight of a plane partition $ \pi $, written $ |\pi| $, is just the sum of its entries, or equivalently the total number of boxes stacked.</p></div></div><div id="plane-partition-example" class="slide large-canvas"><p class="body-text">text b j Ex: a plane partition of weight $ 33 $.</p></div><div class="slide"><p class="body-text">text h RPPs and APPs</p><div class="build build-0"><p class="body-text">text b j If we require the rows and columns of a plane partition to weakly <em>increase</em> rather than decrease, the resulting object is called a <dfn>reverse plane partition</dfn>, or RPP.</p></div><div class="build build-1"><p class="body-text">text b j Keeping the inequalities as usual but allowing entries to take on infinite values results in plane partitions <dfn>asymptotic</dfn> to $ \mu $, where $ \mu $ is the partition whose Young diagram appears as the infinite-height squares.</p></div><div class="build build-2"><p class="body-text">text b j Every plane partition is an APP with $ \mu = \emptyset $, and every RPP is an APP for a suitably chosen $ \mu $ (by rotating it $ 180^\circ $).</p></div></div><div id="app-example" class="slide large-canvas"><p class="body-text">text b j Ex: a plane partition of weight $ 13 $ asymptotic to $ \mu = (3, 2, 0, 0, ...) $.</p></div><div id="rpp-example" class="slide large-canvas"><p class="body-text">text b j Ex: an RPP of weight $ 18 $, and the same RPP expressed as an APP.</p></div><div class="slide"><p class="body-text">text h DT and PT</p><div class="build build-0"><p class="body-text">begin-text-block</p><p class="body-text">Donaldson-Thomas and Pandharipande-Thomas (DT and PT) theories are branches of enumerative geometry related to mirror symmetry and string theory.</p><p class="body-text">In both, particular generating functions counting topological vertices arise &mdash; those in DT enumerate APP-like objects, and those in PT enumerate RPP-like objects. Specifically,</p><p class="body-text">end-text-block</p></div><div class="build build-1 centered"><p class="body-text">begin-text-block</p><p class="body-text">$ V_{(\emptyset, \emptyset, \mu)}(q) $: plane partitions asymptotic to $ \mu $.</p><p class="body-text">$ W_{(\emptyset, \emptyset, \mu)}(q) $: RPPs of shape $ \mu $.</p><p class="body-text">$ M(q) $: plane partitions.</p><p class="body-text">end-text-block</p></div><div class="build build-2"><p class="body-text">text b j In each, $ q $ marks the weight of the partition.</p></div></div><div class="slide"><p class="body-text">text h The Main Theorem</p><div class="build build-0"><p class="body-text">begin-text-block</p><p class="body-text">For a partition $ \mu $,</p><p class="body-text">$$V_{(\emptyset, \emptyset, \mu)}(q) = W_{(\emptyset, \emptyset, \mu)}(q) M(q).$$</p><p class="body-text"></p><p class="body-text">end-text-block</p><br></div><div class="build build-1"><p class="body-text">begin-text-block</p><p class="body-text">Combinatorially, every APP $ \alpha $ asymptotic to $ \mu $ corresponds to a pair $ (\rho, \pi) $ of an RPP $ \rho $ of shape $ \mu $ and a plane partition $ \pi $, such that $ |\alpha| = |\rho| + |\pi| $.</p><p class="body-text">A more general version of the theorem was proven algebraically by Helen Jenne, Gautam Webb, and Benjamin Young in 2020, but a simpler combinatorial proof is desirable &mdash; we will give one such.</p><p class="body-text">end-text-block</p></div></div><div id="hooks" class="slide medium-canvas"><p class="body-text">text h Hooks and Hook Lengths</p><div class="build build-0 left-text"><p class="body-text">text b j The <dfn>hook</dfn> corresponding to a box in an APP is the right-angled collection of boxes above and to the left of it. The hook length $ h(i, j) $ of a box is the total number of boxes in its hook.</p></div><div class="build build-1 left-text"><p class="body-text">text b j In an RPP, the direction of hooks is reserved along with the inequalities, and they extend down and right instead.</p></div><div class="build build-2 left-text"><p class="body-text">text b j Ex: $ h(3, 4) = 5 $ in the APP on the right.</p></div></div><div class="slide"><p class="body-text">text h The Hillman-Grassl Correspondence</p><div class="build build-0"><p class="body-text">text b j The generating function $ V_{(\emptyset, \emptyset, \mu)}(q) $ has an elegant formulation in terms of hook lengths.</p></div><div class="build build-1 centered"><p class="body-text">text b j <strong>Thm:</strong> $ \displaystyle V_{(\emptyset, \emptyset, \mu)}(q) = \prod_{(i, j) \notin \mu} \frac{1}{1 - q^{h(i, j)}} $.</p></div><div class="build build-2"><p class="body-text">text b j Combinatorially, APPs are in bijection with multisets of hooks, but it&#x2019;s not immediately clear how that bijection operates.</p></div></div><div id="legos" class="slide large-canvas"><p class="body-text">text b j Ex: how can we create the plane partition on the left using only the hooks on the right?</p></div><div id="zigzag-paths" class="slide medium-canvas"><p class="body-text">text h Hooks and Hook Lengths</p><div class="build build-0 left-text"><p class="body-text">text b j Hillman and Grassl were the first to bijectivize the hook length formula for $ V_{(\emptyset, \emptyset, \mu)}(q) $ by building APPs out of <dfn>zigzag paths</dfn> instead of hooks.</p></div><div class="build build-1 left-text"><p class="body-text">text b j A zigzag path begins at the rightmost nonzero entry at the top of its column. It moves down if the entries are equal and left otherwise, until it can no longer move.</p></div><div class="build build-3 left-text"><p class="body-text">text b j The <dfn>pivot</dfn> of a zigzag path is the box with the path&#x2019;s starting column and ending row (indicated here in blue).</p></div></div><div id="zigzag-paths-2" class="slide medium-canvas"><p class="body-text">text b j A few important properties of zigzag paths:</p><div class="build build-0 left-text"><p class="body-text">text b j Every APP either has a unique zigzag path or has weight zero.</p></div><div class="build build-1 left-text"><p class="body-text">text b j Decrementing the boxes in a zigzag path preserves the plane partition inequalities.</p></div><div class="build build-2 left-text"><p class="body-text">text b j Every zigzag path has length equal to its pivot&#x2019;s hook length.</p></div></div><div class="slide"><p class="body-text">text b j The Hillman-Grassl map is a bijection between APPs and multisets of hooks. It operates on an APP by decrementing its zigzag path, finding the zigzag path of the resulting APP and decrementing <em>it</em>, and so on, until eventually the APP has weight zero. At each step, we record the hook formed by reshaping the decremented path.</p><div class="build build-0"><p class="body-text">text b j The removal of a zigzag path is an invertible operation, and it can be shown that the generated sequence of pivots respects an inverted lexicographic ordering, so given a multiset of pivots, the inverse Hillman-Grassl map is well-defined.</p></div><div class="build build-1"><p class="body-text">text b j Since hooks are in bijection with pivots, we can concisely represent the multiset of hooks as a tableau (an unordered grid of numbers).</p></div></div><div id="hillman-grassl" class="slide full-canvas"></div><div id="bijection-structure" class="slide medium-canvas"><p class="body-text">text h The Structure of the Bijection</p><div class="build build-0 left-text"><p class="body-text">text b j It&#x2019;s generally easier to work with these unordered tableaux than APPs, since we can more freely rearrange the entries.</p></div><div class="build build-1 left-text"><p class="body-text">text b j In order for this to help us find our bijection, though, it needs to be true on the level of <em>hooks</em>, and not just on the level of boxes.</p></div><div class="build build-2 left-text"><p class="body-text">text b j Since every plane partition contains $ n $ distinct $ n $-hooks, we need to show that any APP has exactly enough extra $ n $-hooks to fill up an RPP in the shape of its asymptote.</p></div></div><div id="n-quotients" class="slide medium-canvas"><p class="body-text">text h $ n $-Quotients</p><div class="build build-0 left-text"><p class="body-text">text b j In a standard plane partition, there are $ n $ boxes with hook length $ n $ for every $ n \in \mathbb{N} $. How many are there in an arbitrarily-shaped APP?</p></div><div class="build build-1 left-text"><p class="body-text">text b j Treat the boundary as a sequence of vertical and horizontal edges, read from bottom-left to top-right. Then an $ n $-hook is just a vertical edge followed by a horizontal edge $ n $ positions later in the sequence.</p></div><div class="build build-2 left-text"><p class="body-text">text b j An <dfn>$ n $-quotient</dfn> of an asymptotic Young diagram is the diagram whose boundary consists of every $ n $th edge of the original diagram.</p></div></div><div id="n-quotients-2" class="slide full-canvas"></div><div class="slide"><p class="body-text">text b j $ 1 $-hooks (i.e. corners) in an $ n $-quotient correspond to $ n $-hooks in the original diagram. This is also true of the smaller Young diagram in the asymptote, but for hooks moving down and right.</p><div class="build build-0"><p class="body-text">text b j Since there is always exactly one more corner outside the asymptote than inside it, the $ n $-quotients account for $ n $ distinct $ n $-hooks, plus however many $ n $-hooks are inside the asymptote. This is exactly what we need!</p></div></div><div class="slide"><p class="body-text">text h The Bijection</p><div class="build build-0"><p class="body-text">text b j Given an APP, we apply Hillman-Grassl and organize the resulting tableau by hook length. Reading from bottom-left to top-right, we place the first $ n $ $ n $-hooks into an empty tableau for a plane partition, and the remainder into another tableau of the shape of the asymptote. We then run the inverse Hillman-Grassl algorithm on both tableaux.</p></div></div><div id="the-bijection" class="slide full-canvas"></div><div id="legs" class="slide medium-canvas"><p class="body-text">text h It Has Legs</p><div class="build build-0 left-text"><p class="body-text">text b j The generating functions $ V_{(\emptyset, \emptyset, \mu)}(q) $ and $ W_{(\emptyset, \emptyset, \mu)}(q) $ both have two empty slots that we haven&#x2019;t used so far. Just like $ \mu $, these can be filled with partitions that define other asymptotes, often referred to as <dfn>legs</dfn>.</p></div><div class="build build-1 left-text"><p class="body-text">text b j Ex: the minimal configuration counted by $ V_{(\mu_1, \mu_2, \mu_3)}(q) $ for $ \mu_1 = (1, 1, 1, 1) $, $ \mu_2 = (2, 1) $, and $ \mu_3 = (3, 1) $ (cropped to near the origin)</p></div><div class="build build-2 left-text"><p class="body-text">text b j When all three $ \mu_i \neq \emptyset $ (the so-called three-leg case), RPPs become much more complicated, with floating and overlapping boxes and more. Thankfully, the two-leg case where $ \mu_3 = \emptyset $ has far fewer of these issues.</p></div></div><div id="toggles" class="slide medium-canvas"><p class="body-text">text h Pak</p><div class="build build-0 left-text"><p class="body-text">text b j In 2002, Igor Pak discovered a different bijection between APPs and $ \mathbb{N} $-tableaux. Its basic operation is called a <dfn>toggle</dfn>, which is an involution on a diagonal of an APP.</p></div><div class="build build-1 left-text"><p class="body-text">text b j For each entry $ x $ in a diagonal, we replace $ x $ with $ \min(\mathbf{n}x, \mathbf{w}x) + \max(\mathbf{s}x, \mathbf{e}x) - x $, where the letters indicate the cells immediately north, west, south, and east of $ x $, respectively. In the case where $ \min(\mathbf{n}x, \mathbf{w}x) = \infty $ (i.e. $ x $ is a corner of the APP), we pop off the value $ x - \max(\mathbf{s}x, \mathbf{e}x) $ and store it elsewhere, and $ x $ toggles to $ \infty $, changing the shape of the APP.</p></div></div><div class="slide"><p class="body-text">text h Pak-Sulzgruber</p><div class="build build-0"><p class="body-text">text b j The Pak bijection acts on an APP by choosing a corner, toggling its diagonal and recording the popped value, and repeating until the plane partition has weight zero.</p></div><div class="build build-1"><p class="body-text">text b j Amazingly, the order in which the corners are popped has no effect on the outcome, and if we store every popped value in the square it was popped from, the resulting tableau is weighted by hook length in the same manner as the tableaux in Hillman-Grassl. </p></div><div class="build build-2"><p class="body-text">text b j A description of the bijection using paths similar to the zigzag paths in Hillman-Grassl was independently discovered by Robin Sulzgruber in 2017, and the algorithm is collectively known as Pak-Sulzgruber.</p></div></div><div id="pak-sulzgruber" class="slide full-canvas"></div><div id="interlacing" class="slide medium-canvas"><p class="body-text">text h Interlacing</p><div class="build build-0 left-text"><p class="body-text">text b j The structure of toggles and Pak&#x2019;s description of the bijection lend themselves to an expression of $ M(q) $, the generating function for plane partitions, different from the usual hook length formula.</p></div><div class="build build-1 left-text"><p class="body-text">text b j Given two partitions $ \lambda $ and $ \mu $, we say that $ \lambda $ <dfn>interlaces</dfn> $ \mu $, written $ \lambda \succ \mu $, if $ \lambda $ satisfies the plane partition inequalities when written as a diagonal strip to the left to $ \mu $.</p></div><div class="build build-2 left-text"><p class="body-text">text b j Ex: $ (9, 6, 5, 2, 0, ...) \succ (7, 6, 3, 1, 0, ...) $.</p></div></div><div class="slide"><p class="body-text">text h Vertex Operators</p><div class="build build-0"><p class="body-text">text b j Define three operators $ \Gamma_+(q) $, $ \Gamma_-(q) $, and $ Q $ as follows:</p></div><div class="build build-1 centered"><p class="body-text">begin-text-block</p><p class="body-text">$ \displaystyle \Gamma_+(q) \left| \lambda \right> = \sum_{\mu \succ \lambda} q^{|\mu| - |\lambda|} \left| \mu \right> $.</p><p class="body-text">$ \displaystyle \Gamma_-(q) \left| \lambda \right> = \sum_{\mu \prec \lambda} q^{|\lambda| - |\mu|} \left| \mu \right> $.</p><p class="body-text">$ \displaystyle Q \left| \lambda \right> = q^{|\lambda|} \left| \lambda \right> $.</p><p class="body-text">end-text-block</p></div><div class="build build-2"><p class="body-text">text b j Here we use the convenient bra-ket notation, where $ \{\left| \lambda \right> \mid \lambda \in \text{Par}\} $ is a basis for a formal vector space and $ \{\left< \lambda \right| \mid \lambda \in \text{Par}\} $ is the corresponding dual basis.</p></div></div><div class="slide"><p class="body-text">text b j These gamma operators sum over all possible ways to make a plane partition larger or smaller, one diagonal at a time, and weight them based on the amount of increase or decrease. The $ Q $ operator simply weighs any diagonal it is given, and it commutes neatly with the gammas:</p><div class="build build-0 centered"><p class="body-text">begin-text-block</p><p class="body-text">$ \displaystyle Q\Gamma_+(a) \left| \lambda \right> = \Gamma_+(qa)Q\left| \lambda \right> $.</p><p class="body-text">$ \displaystyle \Gamma_-(a)Q \left| \lambda \right> = Q \Gamma_-(qa) \left| \lambda \right> $.</p><p class="body-text">end-text-block</p></div><div class="build build-1"><p class="body-text">text b j Both of these relations follow directly from the definitions of $ \Gamma_+ $ and $ \Gamma_- $.</p></div></div><div class="slide"><p class="body-text">text b j By building a plane partition one diagonal at a time from right to left, we can express $ M(q) $ in terms of $ \Gamma $s and $ Q $s:</p><div class="build build-0 centered"><p class="body-text">text b j $ \displaystyle M(q) = \left< \emptyset \right| \cdots \Gamma_-(1) Q \Gamma_-(1) Q \Gamma_+(1) Q \Gamma_+(1) \cdots \left| \emptyset \right> $.</p></div><div class="build build-1"><p class="body-text">text b j To make this much simpler to handle, we&#x2019;ll commute the $ Q $s out to the edges where they&#x2019;ll be absorbed. The middle one needs to be split into two copies of $ Q^{1/2} $, and the result is just</p></div><div class="build build-2 centered"><p class="body-text">text b j $ \displaystyle M(q) = \left< \emptyset \right| \cdots \Gamma_-\left(q^{5/2}\right) \Gamma_-\left(q^{3/2}\right) \Gamma_-\left(q^{1/2}\right) \Gamma_+\left(q^{1/2}\right) \Gamma_+\left(q^{3/2}\right) \Gamma_+\left(q^{5/2}\right) \cdots \left| \emptyset \right> $.</p></div></div><div class="slide"><p class="body-text">text h Commuting $ \Gamma $s</p><div class="build build-0"><p class="body-text">text b j For any partitions $ \lambda $ and $ \mu $,</p></div><div class="build build-1 centered"><p class="body-text">text b j $ \displaystyle \left< \mu \right| \Gamma_-(b) \Gamma_+(a) \left| \lambda \right> = \frac{1}{1 - ab} \left< \mu \right| \Gamma_+(b) \Gamma_-(a) \left| \lambda \right> $.</p></div><div class="build build-2"><p class="body-text">text b j A result due to Ben Young and myself gives a bijective proof: a term in the left side arising from $ \nu $ with $ \mu \prec \nu \succ \lambda $ corresponds to the toggle of $ \nu $ with respect to $ \lambda $ and $ \mu $ &mdash; the popped entry is a term of $ \frac{1}{1 - ab} $ and the new partition $ \nu' $ satisfies $ \mu \succ \nu' \prec \lambda $.</p></div></div><div class="slide"><p class="body-text">text b j Commuting every $ \Gamma_+ $ past every $ \Gamma_- $ is therefore equivalent to applying Pak-Sulzgruber, and by placing partitions into the ends, we can make the jump to the 2-leg case:</p><div class="build build-0 centered"><p class="body-text">text b j $ \displaystyle V_{(\mu_1, \mu_2, \emptyset)} = \left< \mu_1 \right| \cdots \Gamma_-\left(q^{5/2}\right) \Gamma_-\left(q^{3/2}\right) \Gamma_-\left(q^{1/2}\right) \Gamma_+\left(q^{1/2}\right) \Gamma_+\left(q^{3/2}\right) \Gamma_+\left(q^{5/2}\right) \cdots \left| \mu_2 \right> $...</p></div><div class="build build-1 centered"><p class="body-text">text b j ...but that&#x2019;s a story for another time.</p></div></div><div id="thanks" class="slide full-canvas"></div></div><p class="body-text"> </p><div style="display: none"><canvas id="hidden-canvas" class="hidden-canvas" style="margin-top: 0 !important; margin-bottom: 0 !important"></canvas><canvas id="hidden-canvas-2" class="hidden-canvas" style="margin-top: 0 !important; margin-bottom: 0 !important"></canvas><canvas id="hidden-canvas-3" class="hidden-canvas" style="margin-top: 0 !important; margin-bottom: 0 !important"></canvas><canvas id="hidden-canvas-4" class="hidden-canvas" style="margin-top: 0 !important; margin-bottom: 0 !important"></canvas></div><p class="body-text">footer</p></section></main><script>
	if (typeof Page === "undefined")
	{
		if (window.location.search !== "")
		{
			window.location.replace("/index.html?page=" + encodeURIComponent(window.location.pathname) + "&" + window.location.search.slice(1));
		}
		
		else
		{
			window.location.replace("/index.html?page=" + encodeURIComponent(window.location.pathname));
		}
	}
	
	
	
	Page.settings = 
	{
		"title": "Bijectivizing the PT-DT Correspondence",
		
		"math_page": true,
		
		"small_margins_on_ultrawide": true
	};
	
	Page.load();
</script></body></html>