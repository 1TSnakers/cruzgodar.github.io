<!DOCTYPE html>
<html lang="en">

<head>
	<title>In Defense of a Dissertation</title>

	<meta property="og:title" content="In Defense of a Dissertation"/>
	<meta property="og:type" content="website"/>
	<meta property="og:url" content="https://cruzgodar.com/slides/in-defense-of-a-dissertation/"/>
	<meta property="og:image" content="https://cruzgodar.com/slides/in-defense-of-a-dissertation/cover.webp"/>
	<meta property="og:locale" content="en_US"/>
	<meta property="og:site_name" content="Cruz Godar"/>

	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
	<meta id="theme-color-meta" name="theme-color" content="#181818">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css2?family=Rubik&display=swap" rel="stylesheet" as="font">

	<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	
	<link rel="stylesheet" type="text/css" href="/style/wilson.min.css">
	<link rel="stylesheet" type="text/css" href="/style/lapsa.min.css">
	
	<link rel="stylesheet" type="text/css" href="/style/lapsa-light.css">

	<style>
		#young-diagram-example #numbers-canvas-container, #regions-example #numbers-canvas-container
		{
			opacity: 0 !important;
		}
	</style>
</head>

<body>
	<div id="lapsa-slide-container">
		<div id="title" class="medium-canvas">
			<h1>In Defense of a Dissertation</h1>
			
			<h2>Cruz Godar</h2>
			
			<p class="lapsa-align-bottom">Made with <a href="/about/index.html"><img class="inline-image" src="/graphics/general-icons/heart.webp"></img></a> and <a href="/slides/lapsa/index.html"><img class="inline-image" src="/graphics/general-icons/lapsa.webp"></img></a></p>

			<div id="canvas-bundle" style="opacity: 0">
				<div>
					<div style="position: absolute; width: 100%">
						<canvas id="output-canvas"></canvas>
					</div>
					
					<div id="numbers-canvas-container" style="width: 100%">
						<canvas id="numbers-canvas" style="opacity: 0"></canvas>
					</div>
				</div>
			</div>
		</div>
		
		
		
		<div>
			<h1>Background</h1>
			
			<p class="build">A <dfn>partition</dfn> of an integer $n$ is a sequence $(a_1, a_2, ... )$ of weakly decreasing nonnegative integers $a_i$ with $\sum_i a_i = n$.</p>
			
			<p class="build">Ex: $(5, 3, 2, 2, 1) = (5, 3, 2, 2, 1, 0, 0, ...)$ is a partition of $13$.</p>
			
			<div class="build">
				<p>The <dfn>Young diagram</dfn> corresponding to a partition $(a_i)$ is the set $\{(i, j) \in \mathbb{N}^2 \mid 1 \leq j \leq a_i\}$.</p>

				<p>(We use the convention of $\mathbb{N} = \{1, 2, ... \}$).</p>
			</div>
			
			<p class="build">We usually treat these as top-left-justified sets of squares in a grid, so that $a_i$ is the length of row $i$, and we freely identify partitions with their Young diagrams.</p>
		</div>
		
		
		
		<div>
			<h1>Asymptotic Young Diagrams and Hooks</h1>
			
			<p class="build">A Young diagram <dfn>asymptotic</dfn> to a partition $\lambda$ is the collection of boxes $\mathbb{N}^2 \setminus \lambda$.</p>

			<p class="build">The <dfn>hook</dfn> corresponding to a box in a Young diagram is the right-angled collection of all boxes directly below and to the right of it. The hook length $h(i, j)$ of a box is the total number of boxes in its hook, and the corner box $(i, j)$ is called the <dfn>pivot</dfn> of the hook.</p>

			<p class="build">In an asymptotic Young diagram, hooks extend up and left (i.e. always toward the boundary).</p>
		</div>



		<div id="hooks" class="large-canvas">
			<p>Ex: the Young diagram of $(4, 3, 3, 2)$ and the hook with pivot $(2, 1)$. The hook length is $h(2, 1) = 5$.</p>
		</div>

		<div id="hooks2" class="large-canvas">
			<p>Ex: the Young diagram asymptotic to $(4, 3, 3, 2)$ and the hook with pivot $(4, 5)$. The hook length is $h(4, 5) = 6$.</p>
		</div>


		
		<div>
			<h1>Plane Partitions</h1>
			
			<p class="build">A <dfn>reverse plane partition (or RPP)</dfn> is a placement of nonnegative integers into a Young diagram, such that the rows and columns weakly increase. We can also think of them as a stacks of boxes in the corner of a room.</p>

			<p class="build">A <dfn>skew plane partition (or SPP)</dfn> is identical, but we place nonnegative integers into an asymptotic Young diagram $\mathbb{N} \setminus \lambda$ that decrease weakly along rows and columns. When $\lambda = \emptyset$, we just call the object a <dfn>plane partition.</dfn></p>
			
			<p class="build">The <dfn>weight</dfn> of an RPP or SPP $\pi$, written $|\pi|$, is just the sum of its entries, or equivalently the total number of boxes stacked.</p>			
		</div>
		
		
		
		<div id="plane-partition-example" class="large-canvas">
			<p>Ex: a plane partition of weight $33$.<p>
		</div>



		<div>
			<h1>Interlacing</h1>
			
			<p class="build">While the rows and columns of RPPs and SPPs contain valuable information, the <em>diagonals</em> of both turn out to be much more useful.</p>
			
			<p class="build">Given partitions $\lambda$ and $\mu$, we say $\lambda$ <dfn>interlaces</dfn> $\mu$, written $\lambda \succ \mu$, if $\lambda_1 \geq \mu_1 \geq \lambda_2 \geq \mu_2 \geq \cdots$ &mdash; in other words, if $\lambda$ and $\mu$ satisfy the plane partition inequalities when placed next to one another as diagonal slices with $\lambda$ coming first.</p>
		</div>



		<div id="interlacing" class="large-canvas">
			<p>Ex: $(5, 3, 1, 1) \succ (3, 2, 1) \succ (2, 2)$.<p>
		</div>



		<div>
			<h1>Vertex Operators</h1>

			<p class="build">Given a partition $\mu$, the set of partitions $\lambda$ with $\lambda \succ \mu$ is a poset product of intervals in $\mathbb{N}$: each $\lambda_i$ is bounded below by $\mu_i$ and above by $\mu_{i - 1}$ (or unbounded for $i = 1$). We use this to build the generating functions for RPPs and SPPs diagonal by diagonal.</p>

			<p class="build">We define a formal $\mathbb{Q}$-linear vector space $\Lambda$ whose basis consists of vectors $\ket{\lambda}$ for partitions $\lambda$, and denote the corresponding dual basis elements by $\bra{\lambda}$.</p>

			<p class="build">We also define a <dfn>weighing operator</dfn> $Q$ by $Q(q)\,\ket{\lambda} = q^{|\lambda|}\,\ket{\lambda}$.</p>
		</div>



		<div>
			<h1>Interlacing Operators</h1>

			<div class="build">
				<p>The two main operators of interest are the <dfn>interlacing operators</dfn>, defined by</p>

				<p style="text-align: center">$\displaystyle \Gamma_+(q)\,\ket{\lambda} = \sum_{\mu \succ \lambda}q^{|\mu| - |\lambda|}\,\ket{\lambda}$</p>

				<p style="text-align: center">$\displaystyle \Gamma_-(q)\,\ket{\lambda} = \sum_{\mu \prec \lambda}q^{|\lambda| - |\mu|}\,\ket{\lambda}$.</p>
			</div>

			<p class="build">While the formula for $\Gamma_+$ nominally contains an infinite sum, we can avoid convergence issues in practice by adding $Q$ operators to produce a generating function.</p>
		</div>



		<div>
			<h1>A Generating Function for Plane Partitions</h1>

			<div class="build">
				<p>By using the interlacing operators, we can express the generating function for plane partitions whose nonzero entries are contained in an $N \times N$ box:</p>

				<p style="text-align: center">$\displaystyle \left< \emptyset \left| \left( \prod_{i = 1}^N Q \Gamma_-(1) \right) Q \left( \prod_{i = 1}^N \Gamma_+(1) Q \right) \right|\, \emptyset \right>$</p>
			</div>

			<p class="build">To convert this into a more useful formula, we need to commute the $Q$ and $\Gamma$ operators.</p>
		</div>



		<div>
			<h1>Commutation Relations</h1>

			<div class="build">
				<p>The $\Gamma$ and $Q$ operators have a simple commutation relation (weighing a slice before or after making it bigger/smaller):</p>

				<p style="text-align: center">$\displaystyle Q(q) \Gamma_+(a) = \Gamma_+(qa) Q(q)$</p>

				<p style="text-align: center">$\displaystyle \Gamma_-(a) Q(q) = Q(q) \Gamma_-(qa)$.</p>
			</div>

			<div class="build">
				<p>By splitting the middle $Q$ and commuting them all outward where they annihilate against the $\bra{\emptyset}$ and $\ket{\emptyset}$, we find that the previous generating function is</p>

				<p style="text-align: center; transform: scale(0.8); margin-left: -9%">$\displaystyle \left< \emptyset \left| \Gamma_-\left( q^{\frac{2N - 1}{2}} \right) \cdots \Gamma_-\left( q^{\frac{3}{2}} \right) \Gamma_-\left( q^{\frac{1}{2}} \right) \Gamma_+\left( q^{\frac{1}{2}} \right) \Gamma_+\left( q^{\frac{3}{2}} \right) \cdots \Gamma_+\left( q^{\frac{2N - 1}{2}} \right)\right|\, \emptyset \right>.$</p>
			</div>
		</div>
		
		
		
		<div>
			<h1>A Generating Function for RPPs</h1>
			
			<p class="build">A famous result (due to Stanley in his Ph.D. thesis) expresses the generating function for RPPs of shape $\lambda$ as a product involving hook lengths:</p>
			
			<p class="build" style="text-align: center"><strong>Thm:</strong> $\displaystyle \sum_\pi q^{|\pi|} = \prod_{(i, j) \in \lambda} \frac{1}{1 - q^{h(i, j)}},$</p>
			
			<p data-build="1">where the sum is taken over all RPPs $\pi$ of shape $\lambda$. Since boxes and hooks are in bijection, the combinatorial interpretation is that RPPs of shape $\lambda$ are in bijection with multi-sets of hooks in a diagram of shape $\lambda$.</p>
		</div>
		
		
		
		<div>
			<h1>Hillman&ndash;Grassl</h1>
			
			<p class="build">The first bijective proof of the hook length formula is due to Hillman and Grassl in 1975. Given a multi-set of hooks, it is not possible to place them unmodified to construct an RPP: for example, with $\lambda = (2, 2)$, including just the hook with pivot $(1, 1)$ makes the tableau (and invalid RPP)</p>
			
			<p data-build="0" style="text-align: center">$\begin{array}{cc} 1 & 1 \\ 1 & 0 \end{array}$</p>
			
			<p class="build">Instead, each hook is reshaped in an invertible manner before it is placed. We can view this process decomposing an RPP into a multi-set of hooks and back again.</p>
		</div>



		<div id="hillman-grassl" class="full-square-canvas"></div>
		
		
		
		<div>
			<h1>Pak</h1>
			
			<p>In 2002, Igor Pak found a different bijection between RPPs and multisets of hooks. In contrast to Hillman-Grassl, Pak&#x2019;s bijection operates on the level of boxes rather than hooks.</p>
			
			<p>For ease of notation, let $\lambda$ be a partition and $x \in \lambda$ (i.e. a box in the Young diagram), and define $\mathbf{n}x$, $\mathbf{s}x$, $\mathbf{e}x$, and $\mathbf{w}x$ to be the boxes above, below, right, and left of $x$, respectively.</p>
		</div>
		
		
		
		<div>
			<p>Given an RPP $\pi$, select an outer corner of the diagram and call it $y$. For every $x$ in the same diagonal as $y$ other than $y$ itself, define the <dfn>toggle</dfn> of $\pi(x)$ to be</p>
			
			<p style="text-align: center">$\displaystyle \pi'(x) = \max(\pi(\mathbf{n}x), \pi(\mathbf{w}x)) + \min(\pi(\mathbf{s}x), \pi(\mathbf{e}x)) - \pi(x).$</p>
			
			<p class="build">In other words, the toggle of $\pi(x)$ is the max of the adjacent entries smaller than it, plus the min of the adjacent entries larger than it, minus itself.</p>
			
			<p class="build">We now replace $\pi(x)$ with $\pi'(x)$ for all $x$ in the diagonal, excluding $y$.</p>
		</div>
		
		
		
		<div>
			<p>We handle the outer corner $y$ differently: it is completely removed from $\pi$, and the value</p>
			
			<p style="text-align: center">$\displaystyle \pi(y) - \max(\pi(\mathbf{n}y), \pi(\mathbf{w}y)),$</p>
			
			<p>which is how much larger $\pi(y)$ is than strictly necessary, is stored in a tableau at the same location. The shape of the RPP is now one box smaller, and we repeat the previous procedure, choosing a new outer corner, until the RPP is empty.</p>
			
			<p class="build">The RPP in the next animation has been rotated 180$^\circ$, so outer corners are in the top-left. For clarity, toggled corners remain in the same diagram, but they are given color.</p>
		</div>
		
		
		
		<div id="pak" class="full-square-canvas"></div>
		
		
		
		<div>
			<p>It can be shown that the order in which corners are chosen does not impact the final result of Pak, and (more easily) that entries in the output tableau contribute weight equal to their hook length.</p>
			
			<p class="build">Toggling a non-corner entry is an involution, and knowing the entry recorded to the tableau from a toggled corner lets us recover the corner&#x2019;s entry in the RPP. Therefore, the inverse bijection is well-defined.</p>
			
			<p class="build">While the algorithm is simple enough, the fact that it outputs multisets of hooks seems to hint at a description closer in style to Hillman-Grassl.</p>
		</div>
		
		
		
		<div>
			<h1>Sulzgruber</h1>
			
			<p class="build">In 2017, Robin Sulzgruber found exactly that: an equivalent formulation of Pak&#x2019;s bijection that removes one hook at a time.</p>
			
			<p class="build">Given a partition $\lambda$, we divide its Young diagram into four regions:</p>
			
			<p class="build">$\mathcal{O}$ consists of diagonals ending in an outer corner.</p>
			
			<p data-build="2">$\mathcal{I}$ consists of diagonals ending in an inner corner.</p>
			
			<p data-build="2">$\mathcal{A}$ consists of diagonals ending in a horizontal edge.</p>
			
			<p data-build="2">$\mathcal{B}$ consists of diagonals ending in a vertical edge.</p>
		</div>
		
		
		
		<div id="regions-example" class="full-square-canvas"></div>
		
		
		
		<div>
			<p>Given an RPP $\pi$, we define the set of <dfn>candidates</dfn> $C(\pi)$ to be the cells $x \in \mathcal{O}$ with $\pi(\mathbf{w}u) < \pi(u)$, along with the cells $x \in \mathcal{A}$ with $\pi(\mathbf{w}u) < \pi(u) > \pi(\mathbf{n}u)$.</p>
			
			<p class="build">We select the minimum candidate $x$ with respect to content order &mdash; that is, whose diagonal is as north-east as possible, with preference within a diagonal given to the south-east end. With $x$ as a starting position, we build a path as follows:</p>
			
			<p class="build">If the current cell $x$ belongs to $\mathcal{O} \cup \mathcal{B}$ and $\pi(\mathbf{nx}) = \pi(x)$, we move one cell north. Otherwise, we move cell east unless that move leaves the diagram, in which case we stop. As with Hillman-Grassl, we decrement this path, store its pivot in a tableau, and repeat until the RPP is empty.</p>
		</div>
		
		
		
		<div id="sulzgruber" class="full-square-canvas"></div>
		
		
		
		<div id="ps-rsk" class="medium-canvas">
			<p class="left-text">Incredibly, Pak and Sulzgruber&#x2019;s maps produce identical results despite wildly differing descriptions. We refer to the map collectively as $\operatorname{PS}$.</p>
			
			<p class="build left-text">There is a surprising connection between $\operatorname{PS}$ and the $\operatorname{RSK}$ algorithm. Given a square tableau $T$, the diagonals of $\operatorname{PS}^{-1}(T)$ give the shapes of restrictions of $P$ and $Q$ in $(P, Q) = \operatorname{RSK}(T)$.</p>
		</div>
		
		
		
		<div id="garver-patrias" class="medium-canvas">
			<h1>Garver-Patrias</h1>
			
			<p class="left-text">This result is stated in a different but equivalent manner in a paper by Garver and Patrias. Given a Young diagram of shape $\lambda$, we first label each box in reading order.</p>
		</div>
		
		
		
		<div id="garver-patrias-2" class="medium-canvas">
			<p class="left-text">Given a tableau $T$ of shape $\lambda$, which is equivalent to a multiset of hooks, we write them in the order the Sulzgruber algorithm inserts them, and then read off the labels of their pivots to form a word $w$. In this example, $w = 145539$.</p>
		</div>
		
		
		
		<div id="garver-patrias-3" class="medium-canvas">
			<p class="left-text">For each diagonal $d$, we form the subword $w_d$ of $w$ by selecting only the labels whose hooks intersect diagonal $d$.</p>
			
			<p class="left-text">Here, $w_{-2} = 14$, $w_{-1} = 1455$, $w_0 = 145539$, $w_1 = 14553$, and $w_2 = 13$.</p>
		</div>
		
		
		
		<div id="garver-patrias-4" class="medium-canvas">
			<p class="left-text">We now run $\operatorname{RSK}$ on each $w_d$ and store the shape of the resulting tableaux in the corresponding diagonal.</p>
			
			<p class="left-text build">For example, the tableau $P$ in $\operatorname{RSK}(w_1) = \operatorname{RSK}(14355)$ is</p>
			
			<p data-build="0" class="left-text" style="text-align: center">$\displaystyle\begin{array}{cccc}1 & 3 & 5 & 5 \\ 4\end{array},$</p>
			
			<p data-build="0" class="left-text">so we place the partition $(4, 1)$ into the diagonal $d = 1$ (in reverse order).</p>
		</div>
		
		
		
		<div>
			<p><strong>Thm:</strong> This process is equivalent to $\operatorname{PS}$.</p>
			
			<p class="build">We can describe $\operatorname{HG}$ in an identical way by changing the labeling order to be right to left, top to bottom, and then changing the hook ordering to match $\operatorname{HG}$&#x2019;s insertion order. The result is a much more clear connection between the two bijections.</p>
		</div>
		
		
		
		<div>
			<h1>What&#x2019;s the Use?</h1>
			
			<p class="build">My research uses these bijections in order to develop new ones between generalizations of plane partitions. A central result deals with plane partitions <dfn>asymptotic</dfn> to a Young diagram $\lambda$, which are analogous to skew semi-standard Young tableaux.</p>
		</div>
		
		
		
		<div id="app" class="large-canvas">
			<p>Ex: a plane partition asymptotic to $\lambda = (3, 2)$.</p>
		</div>
		
		
		
		<div>
			<p><strong>Thm:</strong> With $\operatorname{M}(q)$, $\operatorname{RPP}_\lambda(q)$, and $\operatorname{APP}_\lambda(q)$ denoting the generating functions for plane partitions, RPPs of shape $\lambda$, and plane partitions asymptotic to lambda, respectively,</p>
			
			<p style="text-align: center">$\displaystyle \operatorname{APP}_\lambda(q) = \operatorname{RPP}_\lambda(q)M(q)$.</p>
			
			<p>This relation was formerly known only algebraically, but showing it bijectively was possible using $\operatorname{HG}$. A generalization of the relation was also bijectivized using Pak, and a bijectivizing a further generalization, which was shown algebraically by Jenne, Webb, and Young in 2020, remains an open problem.</p>
		</div>
		
		
		
		<div style="display: flex; flex-direction: column; justify-content: center">
			<h1 style="text-align: center">That&#x2019;s all for now, folks!</h1>
		</div>
	</div>

	<script>
		window.MathJax =
		{
			tex:
			{
				inlineMath: [["$", "$"], ["\\(", "\\)"]]
			}
		};
	</script>

	<script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
	
	<script src="index.js" type="module"></script>
</body>

</html>