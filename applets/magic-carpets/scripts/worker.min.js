onmessage=function(c){gridSize=c.data[0];maxCageSize=c.data[1];uniqueSolution=c.data[2];generateMagicCarpet()};let gridSize=null,maxCageSize=null,uniqueSolution=null,cages=[],cagesByLocation=[],numSolutionsFound=0;
function generateMagicCarpet(){cages=[];cagesByLocation=[];initializeGrid();let c=JSON.parse(JSON.stringify(cages)),b=JSON.parse(JSON.stringify(cagesByLocation));for(;;){let a=!1,f=shuffleArray([...Array(cages.length).keys()]);f.sort((d,g)=>cages[d][2]*cages[d][3]-cages[g][2]*cages[g][3]);for(let d=0;d<f.length;d++)if(expandCage(f[d])){for(let g=0;g<f.length;g++)f[g]>=cages.length&&f[g]--;uniqueSolution?(numSolutionsFound=solvePuzzle(),1!==numSolutionsFound?(cages=JSON.parse(JSON.stringify(c)),cagesByLocation=
JSON.parse(JSON.stringify(b)),numSolutionsFound=1):(a=!0,c=JSON.parse(JSON.stringify(cages)),b=JSON.parse(JSON.stringify(cagesByLocation)))):a=!0}if(!a||cages.length<=gridSize){postMessage([cages.sort((d,g)=>g[3]*gridSize+g[2]-(d[3]*gridSize+d[2]))]);break}}}
function printGrid(){let c="",b=Array(gridSize);for(var a=0;a<gridSize;a++){b[a]=Array(gridSize);for(var f=0;f<gridSize;f++)b[a][f]=0}for(a=0;a<cages.length;a++)b[cages[a][0]+cages[a][4]][cages[a][1]+cages[a][5]]=cages[a][2]*cages[a][3];for(a=0;a<gridSize;a++){for(f=0;f<gridSize;f++)c+=`${0!==b[a][f]?b[a][f]:" "} `;c+="\n"}postMessage(c)}
function initializeGrid(){cages=Array(gridSize*gridSize);cagesByLocation=Array(gridSize);let c=0;for(let b=0;b<gridSize;b++){cagesByLocation[b]=Array(gridSize);for(let a=0;a<gridSize;a++)cages[c]=[b,a,1,1,0,0],cagesByLocation[b][a]=c,c++}}function shuffleArray(c){let b=c.length;for(;0!==b;){const a=Math.floor(Math.random()*b);b--;const f=c[b];c[b]=c[a];c[a]=f}return c}
function expandCage(c){var b=cages[c],a=b[0];const f=b[1];var d=b[2],g=b[3];const n=b[4];b=b[5];var e=[];if(0!==a){var h=cages[cagesByLocation[a-1][f]];h[1]===f&&h[3]===g&&h[2]*h[3]+g*d<=maxCageSize&&e.push([1,0])}0!==f&&(h=cages[cagesByLocation[a][f-1]],h[0]===a&&h[2]===d&&h[2]*h[3]+g*d<=maxCageSize&&e.push([0,1]));if(0===e.length)return!1;e=e[Math.floor(Math.random()*e.length)];a=cagesByLocation[a-e[0]][f-e[1]];.5>Math.random()&&(cages[a][4]=cages[a][2]*e[0]+n,cages[a][5]=cages[a][3]*e[1]+b);cages[a][2]+=
d*e[0];cages[a][3]+=g*e[1];cages.splice(c,1);for(d=0;d<gridSize;d++)for(g=0;g<gridSize;g++)cagesByLocation[d][g]===c&&(cagesByLocation[d][g]=a),cagesByLocation[d][g]>c&&cagesByLocation[d][g]--;return!0}function solvePuzzle(){let c=Array(gridSize);for(var b=0;b<gridSize;b++){c[b]=Array(gridSize);for(let a=0;a<gridSize;a++)c[b][a]=!1}for(b=0;b<cages.length;b++)c[cages[b][0]+cages[b][4]][cages[b][1]+cages[b][5]]=!0;return solvePuzzleStep(0,c)}
function solvePuzzleStep(c,b){if(c===cages.length)return 1;const a=cages[c][0]+cages[c][4],f=cages[c][1]+cages[c][5],d=cages[c][2]*cages[c][3];if(1===d)return solvePuzzleStep(c+1,b);let g=0,n=[];for(let e=1;e<=Math.sqrt(d);e++)0!==d%e||e>gridSize||d/e>gridSize||(n.push(e),d/e!==e&&n.push(d/e));n.forEach(e=>{const h=d/e;var p=Math.max(a-e+1,0);const r=Math.min(a,gridSize-e),t=Math.max(f-h+1,0),u=Math.min(f,gridSize-h);for(;p<=r;p++)for(let q=t;q<=u;q++){var m=!1;for(var k=0;k<e;k++){for(var l=0;l<
h;l++)if(b[p+k][q+l]&&(p+k!==a||q+l!==f)){m=!0;break}if(m)break}if(!m){m=Array(gridSize);for(k=0;k<gridSize;k++)for(m[k]=Array(gridSize),l=0;l<gridSize;l++)m[k][l]=b[k][l];for(k=0;k<e;k++)for(l=0;l<h;l++)m[p+k][q+l]=!0;g+=solvePuzzleStep(c+1,m)}}});return g};
