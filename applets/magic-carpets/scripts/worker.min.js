"use strict";let gridSize=null,maxCageSize=null,uniqueSolution=null,cages=[],cagesByLocation=[],numSolutionsFound=0;function generateMagicCarpet(){cages=[],cagesByLocation=[],initializeGrid();let cagesBackup=JSON.parse(JSON.stringify(cages)),cagesByLocationBackup=JSON.parse(JSON.stringify(cagesByLocation));for(;;){let expandedACage=!1;var cageOrder=shuffleArray([...Array(cages.length).keys()]);cageOrder.sort((a,b)=>cages[a][2]*cages[a][3]-cages[b][2]*cages[b][3]);for(let i=0;i<cageOrder.length;i++)if(expandCage(cageOrder[i])){for(let j=0;j<cageOrder.length;j++)cageOrder[j]>=cages.length&&cageOrder[j]--;uniqueSolution?1!==(numSolutionsFound=solvePuzzle())?(cages=JSON.parse(JSON.stringify(cagesBackup)),cagesByLocation=JSON.parse(JSON.stringify(cagesByLocationBackup)),numSolutionsFound=1):(expandedACage=!0,cagesBackup=JSON.parse(JSON.stringify(cages)),cagesByLocationBackup=JSON.parse(JSON.stringify(cagesByLocation))):expandedACage=!0}if(!expandedACage||cages.length<=gridSize)return void postMessage([cages.sort((a,b)=>b[3]*gridSize+b[2]-(a[3]*gridSize+a[2]))])}}function initializeGrid(){cages=new Array(gridSize*gridSize),cagesByLocation=new Array(gridSize);let index=0;for(let i=0;i<gridSize;i++){cagesByLocation[i]=new Array(gridSize);for(let j=0;j<gridSize;j++)cages[index]=[i,j,1,1,0,0],cagesByLocation[i][j]=index,index++}}function shuffleArray(array){let currentIndex=array.length;for(;0!==currentIndex;){var randomIndex=Math.floor(Math.random()*currentIndex),temp=array[--currentIndex];array[currentIndex]=array[randomIndex],array[randomIndex]=temp}return array}function expandCage(cageIndex){var cage=cages[cageIndex],row=cage[0],col=cage[1],height=cage[2],width=cage[3],rowOffset=cage[4],cage=cage[5],directions=[];if(0!==row&&(neighbor=cages[cagesByLocation[row-1][col]])[1]===col&&neighbor[3]===width&&neighbor[2]*neighbor[3]+width*height<=maxCageSize&&directions.push([1,0]),0!==col){const neighbor=cages[cagesByLocation[row][col-1]];neighbor[0]===row&&neighbor[2]===height&&neighbor[2]*neighbor[3]+width*height<=maxCageSize&&directions.push([0,1])}if(0===directions.length)return!1;var neighbor=directions[Math.floor(Math.random()*directions.length)],neighborIndex=cagesByLocation[row-neighbor[0]][col-neighbor[1]];Math.random()<.5&&(cages[neighborIndex][4]=cages[neighborIndex][2]*neighbor[0]+rowOffset,cages[neighborIndex][5]=cages[neighborIndex][3]*neighbor[1]+cage),cages[neighborIndex][2]+=height*neighbor[0],cages[neighborIndex][3]+=width*neighbor[1],cages.splice(cageIndex,1);for(let i=0;i<gridSize;i++)for(let j=0;j<gridSize;j++)cagesByLocation[i][j]===cageIndex&&(cagesByLocation[i][j]=neighborIndex),cagesByLocation[i][j]>cageIndex&&cagesByLocation[i][j]--;return!0}function solvePuzzle(){var occupiedCageLocations=new Array(gridSize);for(let i=0;i<gridSize;i++){occupiedCageLocations[i]=new Array(gridSize);for(let j=0;j<gridSize;j++)occupiedCageLocations[i][j]=!1}for(let i=0;i<cages.length;i++){var row=cages[i][0]+cages[i][4],col=cages[i][1]+cages[i][5];occupiedCageLocations[row][col]=!0}return solvePuzzleStep(0,occupiedCageLocations)}function solvePuzzleStep(cageIndex,occupiedCageLocations){if(cageIndex===cages.length)return 1;const row=cages[cageIndex][0]+cages[cageIndex][4],col=cages[cageIndex][1]+cages[cageIndex][5],size=cages[cageIndex][2]*cages[cageIndex][3];if(1==size)return solvePuzzleStep(cageIndex+1,occupiedCageLocations);let numSolutions=0;var validSides=[];for(let side=1;side<=Math.sqrt(size);side++)size%side!=0||side>gridSize||size/side>gridSize||(validSides.push(side),size/side!==side&&validSides.push(size/side));return validSides.forEach(side1=>{var side2=size/side1,minRow=Math.max(row-side1+1,0),maxRow=Math.min(row,gridSize-side1),minCol=Math.max(col-side2+1,0),maxCol=Math.min(col,gridSize-side2);for(let i=minRow;i<=maxRow;i++)for(let j=minCol;j<=maxCol;j++){let broken=!1;for(let k=0;k<side1;k++){for(let l=0;l<side2;l++)if(occupiedCageLocations[i+k][j+l]&&(i+k!==row||j+l!==col)){broken=!0;break}if(broken)break}if(!broken){var newOccupiedCageLocations=new Array(gridSize);for(let k=0;k<gridSize;k++){newOccupiedCageLocations[k]=new Array(gridSize);for(let l=0;l<gridSize;l++)newOccupiedCageLocations[k][l]=occupiedCageLocations[k][l]}for(let k=0;k<side1;k++)for(let l=0;l<side2;l++)newOccupiedCageLocations[i+k][j+l]=!0;numSolutions+=solvePuzzleStep(cageIndex+1,newOccupiedCageLocations)}}}),numSolutions}onmessage=function(e){gridSize=e.data[0],maxCageSize=e.data[1],uniqueSolution=e.data[2],generateMagicCarpet()};