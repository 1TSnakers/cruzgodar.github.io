!function(){"use strict";let e=`
  precision highp float;
  
  varying vec2 uv;
  
  uniform float aspectRatioX;
  uniform float aspectRatioY;
  
  uniform vec3 cameraPos;
  uniform vec3 imagePlaneCenterPos;
  uniform vec3 forwardVec;
  uniform vec3 rightVec;
  uniform vec3 upVec;
  
  uniform float focalLength;
  
  uniform vec3 lightPos;
  const float lightBrightness = 1.5;
  
  uniform int imageSize;
  
  uniform int drawSphere;
  
  uniform int maxIterations;
  
  
  
  const float clipDistance = 1000.0;
  uniform int maxMarches;
  uniform float stepFactor;
  const vec3 fogColor = vec3(0.0, 0.0, 0.0);
  const float fogScaling = .1;
  
  uniform float kSlice;
  
  
  uniform vec3 c;
  uniform float juliaProportion;
  
  
  
  vec4 qmul(vec4 z, vec4 w)
  {
   return vec4(z.x*w.x - z.y*w.y - z.z*w.z - z.w*w.w, z.x*w.y + z.y*w.x + z.z*w.w - z.w*w.z, z.x*w.z - z.y*w.w + z.z*w.x + z.w*w.y, z.x*w.w + z.y*w.z - z.z*w.y + z.w*w.x);
  }
  
  
  float distanceEstimator(vec3 pos)
  {
   vec4 z = vec4(pos, kSlice);
   vec4 zPrime = vec4(1.0, 0.0, 0.0, 0.0);
   float r;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    r = length(z);
    
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    zPrime = 2.0 * qmul(z, zPrime);
    
    z = qmul(z, z);
    
    z += mix(vec4(pos, kSlice), vec4(c, kSlice), juliaProportion);
   }
   
   
   r = length(z);
   float distance1 = .5 * r * log(r) / length(zPrime);
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    return distance2;
   }
   
   return distance1;
  }
  
  
  
  vec3 getColor(vec3 pos)
  {
   vec4 z = vec4(pos, kSlice);
   vec4 zPrime = vec4(1.0, 0.0, 0.0, 0.0);
   float r;
   
   vec3 color = vec3(1.0, 1.0, 1.0);
   float colorScale = .5;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    r = length(z);
    
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    zPrime = 2.0 * qmul(z, zPrime);
    
    z = qmul(z, z);
    
    z += mix(vec4(pos, kSlice), vec4(c, kSlice), juliaProportion);
    
    color = mix(color, abs(normalize(z.xyz)), colorScale);
    
    colorScale *= .5;
   }
   
   color /= max(max(color.x, color.y), color.z);
   
   
   r = length(z);
   float distance1 = .5 * r * log(r) / length(zPrime);
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    color = vec3(1.0, 1.0, 1.0);
   }
   
   return color;
  }
  
  
  
  vec3 getSurfaceNormal(vec3 pos)
  {
   float xStep1 = distanceEstimator(pos + vec3(.000001, 0.0, 0.0));
   float yStep1 = distanceEstimator(pos + vec3(0.0, .000001, 0.0));
   float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, .000001));
   
   float xStep2 = distanceEstimator(pos - vec3(.000001, 0.0, 0.0));
   float yStep2 = distanceEstimator(pos - vec3(0.0, .000001, 0.0));
   float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, .000001));
   
   return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
  }
  
  
  
  vec3 computeShading(vec3 pos, int iteration)
  {
   vec3 surfaceNormal = getSurfaceNormal(pos);
   
   vec3 lightDirection = normalize(lightPos - pos);
   
   float dotProduct = dot(surfaceNormal, lightDirection);
   
   float lightIntensity = lightBrightness * max(dotProduct, -.25 * dotProduct);
   
   //The last factor adds ambient occlusion.
   vec3 color = getColor(pos) * lightIntensity * max((1.0 - float(iteration) / float(maxMarches)), 0.0);
   
   
   
   //Apply fog.
   return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
  }
  
  
  
  vec3 raymarch(vec3 startPos)
  {
   //That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.
   vec3 rayDirectionVec = normalize(startPos - cameraPos) * .9 / stepFactor;
   
   vec3 finalColor = fogColor;
   
   float epsilon = 0.0;
   
   float t = 0.0;
   
   float lastDistance = 1000.0;
   
   //int slowedDown = 0;
   
   
   
   for (int iteration = 0; iteration < 1024; iteration++)
   {
    if (iteration == maxMarches)
    {
     break;
    }
    
    
    
    vec3 pos = startPos + t * rayDirectionVec;
    
    //This prevents overstepping, and is honestly a pretty clever fix.
    float distance = min(distanceEstimator(pos), lastDistance);
    lastDistance = distance;
    
    //This lowers the detail far away, which makes everything run nice and fast.
    epsilon = max(.0000006, .5 * t / float(imageSize));
    
    
    
    if (distance < epsilon)
    {
     finalColor = computeShading(pos, iteration);
     break;
    }
    
    //Uncomment to add aggressive understepping when close to the fractal boundary, which helps to prevent flickering but is a significant performance hit.
    /*
    else if (lastDistance / distance > .9999 && slowedDown == 0)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .125;
     
     slowedDown = 1;
    }
    
    else if (lastDistance / distance <= .9999 && slowedDown == 1)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .9;
     
     slowedDown = 0;
    }
    */
    
    else if (t > clipDistance)
    {
     break;
    }
    
    
    
    t += distance;
   }
   
   
   
   return finalColor;
  }
  
  
  
  void main(void)
  {
   //Uncomment to use 2x antialiasing.
   //vec3 finalColor = (raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize)))) / 4.0;
   
   gl_FragColor = vec4(raymarch(imagePlaneCenterPos + rightVec * (uv.x) * aspectRatioX + upVec * (uv.y) / aspectRatioY), 1.0);
  }
 `,t=new Wilson($("#output-canvas"),{renderer:"gpu",shader:e,canvasWidth:500,canvasHeight:500,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:ef,mousedownCallback:es,touchstartCallback:es,mousedragCallback:el,touchmoveCallback:el,mouseupCallback:eu,touchendCallback:eu});t.render.initUniforms(["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","focalLength","lightPos","drawSphere","c","juliaProportion","maxMarches","stepFactor","maxIterations","kSlice"]);let i=!1,o=!1,n=!1,a=!1,r=!1,c=!1,s=!1,l=!1,u=!1,m=!1,_=0,f=[0,0,0,0],p=[0,0,0,0],g=1,d=-1,v=1.21557,h=2.10801,y=0,z=0,w=0,P=0,S=500,k=500,C=500,x=16,A=100,I=[],q=[],V=[],b=[],F=[-1.11619,-2.63802,1.67049],E=2,R=[-.54,-.25,-.668],L=[0,0,0],T=[0,0,0],D=0,B=0,M=0,N=1,O=0,j=0,X=0,Y=0,U=$("#resolution-input");U.addEventListener("input",ef);let H=$("#iterations-input");H.addEventListener("input",()=>{x=parseInt(H.value||16),t.gl.uniform1i(t.uniforms.maxIterations,x),window.requestAnimationFrame(e$)});let J=$("#view-distance-input");J.addEventListener("input",()=>{A=Math.max(parseInt(J.value||100),32),t.gl.uniform1i(t.uniforms.maxMarches,A),window.requestAnimationFrame(e$)});$("#download-button").addEventListener("click",()=>{0===N?t.downloadFrame("the-quaternionic-mandelbrot-set.png"):t.downloadFrame("a-quaternionic-julia-set.png")});let W=$("#c-x-input"),G=$("#c-y-input"),K=$("#c-z-input"),Q=$("#c-w-input"),Z=[W,G,K,Q];for(let ee=0;ee<Z.length;ee++)Z[ee].addEventListener("input",ep);let et=$("#randomize-c-button");et.style.opacity=1,et.addEventListener("click",function e(t=!0){!i&&(L[0]=R[0],L[1]=R[1],L[2]=R[2],T[0]=2*Math.random()-1-L[0],T[1]=2*Math.random()-1-L[1],T[2]=2*Math.random()-1-L[2],W.value=Math.round((L[0]+T[0])*1e6)/1e6,G.value=Math.round((L[1]+T[1])*1e6)/1e6,K.value=Math.round((L[2]+T[2])*1e6)/1e6,j=N,X=0,B=D,M=0,t?eg():(R[0]=L[0]+T[0],R[1]=L[1]+T[1],R[2]=L[2]+T[2]))});let ei=$("#switch-bulb-button");ei.style.opacity=1,ei.addEventListener("click",function e(){!i&&(Page.Animate.changeOpacity(ei,0,Site.opacityAnimationTime),setTimeout(()=>{0===j?ei.textContent="Switch to Mandelbrot Set":ei.textContent="Switch to Julia Set",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(ei,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),0===N?(t.gl.uniform3fv(t.uniforms.c,R),O||t.gl.uniform1i(t.uniforms.drawSphere,1),setTimeout(()=>{Page.Animate.changeOpacity(eo,1,Site.opacityAnimationTime),Page.Animate.changeOpacity(et,1,Site.opacityAnimationTime)},Site.opacityAnimationTime)):(O=!0,t.gl.uniform1i(t.uniforms.drawSphere,0),Page.Animate.changeOpacity(eo,0,Site.opacityAnimationTime),Page.Animate.changeOpacity(et,0,Site.opacityAnimationTime)),X=1-2*(j=N),B=D,M=0,L[0]=R[0],L[1]=R[1],L[2]=R[2],T[0]=0,T[1]=0,T[2]=0,eg())});let eo=$("#switch-movement-button");function e$(e){let m=e-d;if(d=e,0===m)return;t.render.drawFrame();let S=!1,k;i&&(k=.5*Math.sin(Math.PI*Y/120-Math.PI/2)+.5,R[0]=L[0]+T[0]*k,R[1]=L[1]+T[1]*k,R[2]=L[2]+T[2]*k,t.gl.uniform3fv(t.uniforms.c,R),N=j+X*k,t.gl.uniform1f(t.uniforms.juliaProportion,N),D=B+M*k,t.gl.uniform1f(t.uniforms.kSlice,D),121==++Y&&(i=!1),S=!0),o||n||a||r||l||u||c||s?(function e(){if(_=Math.min(Math.max(1e-6,g/20),.02),O){let i=[...F];o||l?(F[0]+=_*q[0],F[1]+=_*q[1],F[2]+=_*q[2]):(n||u)&&(F[0]-=_*q[0],F[1]-=_*q[1],F[2]-=_*q[2]),a?(F[0]+=_*V[0]/E,F[1]+=_*V[1]/E,F[2]+=_*V[2]/E):r&&(F[0]-=_*V[0]/E,F[1]-=_*V[1]/E,F[2]-=_*V[2]/E),f[0]=F[0]-i[0],f[1]=F[1]-i[1],f[2]=F[2]-i[2]}else{let m=[...R],p=D;o||l?(R[0]+=.5*_*q[0],R[1]+=.5*_*q[1],R[2]+=.5*_*q[2]):(n||u)&&(R[0]-=.5*_*q[0],R[1]-=.5*_*q[1],R[2]-=.5*_*q[2]),a?(R[0]+=.5*_*V[0]/E,R[1]+=.5*_*V[1]/E,R[2]+=.5*_*V[2]/E):r&&(R[0]-=.5*_*V[0]/E,R[1]-=.5*_*V[1]/E,R[2]-=.5*_*V[2]/E),c?D+=.5*_:s&&(D-=.5*_),W.value=Math.round(1e6*R[0])/1e6,G.value=Math.round(1e6*R[1])/1e6,K.value=Math.round(1e6*R[2])/1e6,Q.value=Math.round(1e6*D)/1e6,t.gl.uniform3fv(t.uniforms.c,R),t.gl.uniform1f(t.uniforms.kSlice,D),f[0]=R[0]-m[0],f[1]=R[1]-m[1],f[2]=R[2]-m[2],f[3]=D-p}en()}(),S=!0):m>=50&&(y=0,z=0,w=0,P=0,l=!1,u=!1,p[0]=0,p[1]=0,p[2]=0,p[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0),(0!==w||0!==P)&&(v+=w,h+=P,v>=2*Math.PI?v-=2*Math.PI:v<0&&(v+=2*Math.PI),h>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),5e-4>Math.sqrt((w*=.94)*w+(P*=.94)*P)&&(w=0,P=0),en(),S=!0),(0!==p[0]||0!==p[1]||0!==p[2]||0!==p[3])&&(O?(F[0]+=p[0],F[1]+=p[1],F[2]+=p[2]):(R[0]+=p[0],R[1]+=p[1],R[2]+=p[2],D+=p[3],W.value=Math.round(1e6*R[0])/1e6,G.value=Math.round(1e6*R[1])/1e6,K.value=Math.round(1e6*R[2])/1e6,Q.value=Math.round(1e6*D)/1e6,t.gl.uniform3fv(t.uniforms.c,R),t.gl.uniform1f(t.uniforms.kSlice,D)),p[0]*=.94,p[1]*=.94,p[2]*=.94,p[3]*=.94,Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]+p[3]*p[3])<5e-4*_&&(p[0]=0,p[1]=0,p[2]=0,p[3]=0),en(),S=!0),S&&window.requestAnimationFrame(e$)}function en(){var e,i,o;let n;b=(i=V=(e=[(q=[Math.cos(v)*Math.sin(h),Math.sin(v)*Math.sin(h),Math.cos(h)])[1],-q[0],0],n=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),[e[0]/n,e[1]/n,e[2]/n]),o=q,[i[1]*o[2]-i[2]*o[1],i[2]*o[0]-i[0]*o[2],i[0]*o[1]-i[1]*o[0]]),E=(g=function e(t,i,o){let n=[t,i,o,D],a=[1,0,0,0],r=0;for(let c=0;c<4*x&&!((r=Math.sqrt(er(n,n)))>16);c++)a=ec(...n,...a),a[0]*=2,a[1]*=2,a[2]*=2,a[3]*=2,n=ec(...n,...n),n[0]+=(1-N)*t+N*R[0],n[1]+=(1-N)*i+N*R[1],n[2]+=(1-N)*o+N*R[2],n[3]+=D;return .5*Math.log(r)*r/Math.sqrt(er(a,a))}(F[0],F[1],F[2]))/2,V[0]*=E/2,V[1]*=E/2,b[0]*=E/2,b[1]*=E/2,b[2]*=E/2,I=[F[0]+E*q[0],F[1]+E*q[1],F[2]+E*q[2]],t.gl.uniform3fv(t.uniforms.cameraPos,F),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,I),t.gl.uniform3fv(t.uniforms.forwardVec,q),t.gl.uniform3fv(t.uniforms.rightVec,V),t.gl.uniform3fv(t.uniforms.upVec,b),t.gl.uniform1f(t.uniforms.focalLength,E)}function ea(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function er(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function ec(e,t,i,o,n,a,r,c){return[e*n-t*a-i*i-o*c,e*a+t*n+i*c-o*r,e*r-t*c+i*n+o*a,e*c+t*r-i*a+o*n]}function es(e,t,i){y=0,z=0,w=0,P=0,"touchstart"===i.type&&(2===i.touches.length?(l=!0,u=!1,p[0]=0,p[1]=0,p[2]=0,p[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0,window.requestAnimationFrame(e$)):3===i.touches.length?(l=!1,u=!0,p[0]=0,p[1]=0,p[2]=0,p[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0,window.requestAnimationFrame(e$)):(l=!1,u=!1),m=!1)}function el(e,t,i,o,n){if("touchmove"===n.type&&m){m=!1;return}v+=i*Math.PI/2,y=i*Math.PI/2,v>=2*Math.PI?v-=2*Math.PI:v<0&&(v+=2*Math.PI),h+=o*Math.PI/2,z=o*Math.PI/2,h>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),en(),window.requestAnimationFrame(e$)}function eu(e,t,i){"touchend"===i.type&&(l=!1,u=!1,m=!0,0===p[0]&&0===p[1]&&0===p[2]&&(p[0]=f[0],p[1]=f[1],p[2]=f[2],p[3]=f[3],f[0]=0,f[1]=0,f[2]=0,f[3]=0)),"touchend"===i.type&&i.touches,(0===length||"mouseup"===i.type)&&Math.sqrt(y*y+z*z)>=.005&&(w=y,P=z)}function em(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode||69===e.keyCode||81===e.keyCode)&&(f=[0,0,0,0],p=[0,0,0,0],87===e.keyCode?o=!0:83===e.keyCode&&(n=!0),68===e.keyCode?a=!0:65===e.keyCode&&(r=!0),69===e.keyCode?c=!0:81===e.keyCode&&(s=!0),window.requestAnimationFrame(e$))}function e_(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode||69===e.keyCode||81===e.keyCode)&&(0===p[0]&&0===p[1]&&0===p[2]&&0===p[3]&&(p[0]=f[0],p[1]=f[1],p[2]=f[2],p[3]=f[3],f[0]=0,f[1]=0,f[2]=0,f[3]=0),87===e.keyCode?o=!1:83===e.keyCode&&(n=!1),68===e.keyCode?a=!1:65===e.keyCode&&(r=!1),69===e.keyCode?c=!1:81===e.keyCode&&(s=!1))}function ef(){S=Math.max(100,parseInt(U.value||500)),t.fullscreen.currentlyFullscreen?Page.Layout.aspectRatio>=1?(k=S,C=Math.floor(S/Page.Layout.aspectRatio)):(k=Math.floor(S*Page.Layout.aspectRatio),C=S):(k=S,C=S),t.changeCanvasSize(k,C),k>=C?(t.gl.uniform1f(t.uniforms.aspectRatioX,k/C),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,k/C)),t.gl.uniform1i(t.uniforms.imageSize,S),window.requestAnimationFrame(e$)}function ep(){L[0]=R[0],L[1]=R[1],L[2]=R[2],T[0]=(parseFloat(W.value||0)||0)-L[0],T[1]=(parseFloat(G.value||0)||0)-L[1],T[2]=(parseFloat(K.value||0)||0)-L[2],j=N,X=0,B=D,M=(parseFloat(Q.value||0)||0)-B,eg()}function eg(){i||(i=!0,Y=0,window.requestAnimationFrame(e$))}eo.style.opacity=1,eo.addEventListener("click",function e(){O=!O,Page.Animate.changeOpacity(eo,0,Site.opacityAnimationTime),setTimeout(()=>{O?eo.textContent="Change Julia Set":eo.textContent="Move Camera",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(eo,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),O?t.gl.uniform1i(t.uniforms.drawSphere,0):t.gl.uniform1i(t.uniforms.drawSphere,1)}),Page.Load.TextButtons.equalize(),en(),k>=C?(t.gl.uniform1f(t.uniforms.aspectRatioX,k/C),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,k/C)),t.gl.uniform1i(t.uniforms.imageSize,S),t.gl.uniform3fv(t.uniforms.cameraPos,F),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,I),t.gl.uniform3fv(t.uniforms.lightPos,[-5,-5,5]),t.gl.uniform3fv(t.uniforms.forwardVec,q),t.gl.uniform3fv(t.uniforms.rightVec,V),t.gl.uniform3fv(t.uniforms.upVec,b),t.gl.uniform1f(t.uniforms.focalLength,E),t.gl.uniform1i(t.uniforms.drawSphere,0),t.gl.uniform3fv(t.uniforms.c,R),t.gl.uniform1f(t.uniforms.juliaProportion,1),t.gl.uniform1i(t.uniforms.kSlice,0),t.gl.uniform1i(t.uniforms.maxMarches,A),t.gl.uniform1f(t.uniforms.stepFactor,1),t.gl.uniform1i(t.uniforms.maxIterations,x),window.requestAnimationFrame(e$),Page.show(),document.documentElement.addEventListener("keydown",em),Page.temporaryHandlers.keydown.push(em),document.documentElement.addEventListener("keyup",e_),Page.temporaryHandlers.keydown.push(e_)}();