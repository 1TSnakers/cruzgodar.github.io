!function(){"use strict";let e=`
  precision highp float;
  
  varying vec2 uv;
  
  uniform float aspect_ratio_x;
  uniform float aspect_ratio_y;
  
  uniform vec3 camera_pos;
  uniform vec3 image_plane_center_pos;
  uniform vec3 forward_vec;
  uniform vec3 right_vec;
  uniform vec3 up_vec;
  
  uniform float focal_length;
  
  uniform vec3 light_pos;
  const float light_brightness = 1.5;
  
  uniform int image_size;
  
  uniform int draw_sphere;
  
  uniform int max_iterations;
  
  
  
  const float clip_distance = 1000.0;
  uniform int max_marches;
  uniform float step_factor;
  const vec3 fog_color = vec3(0.0, 0.0, 0.0);
  const float fog_scaling = .1;
  
  uniform float k_slice;
  
  
  uniform vec3 c;
  uniform float julia_proportion;
  
  
  
  vec4 qmul(vec4 z, vec4 w)
  {
   return vec4(z.x*w.x - z.y*w.y - z.z*w.z - z.w*w.w, z.x*w.y + z.y*w.x + z.z*w.w - z.w*w.z, z.x*w.z - z.y*w.w + z.z*w.x + z.w*w.y, z.x*w.w + z.y*w.z - z.z*w.y + z.w*w.x);
  }
  
  
  float distance_estimator(vec3 pos)
  {
   vec4 z = vec4(pos, k_slice);
   vec4 z_prime = vec4(1.0, 0.0, 0.0, 0.0);
   float r;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    r = length(z);
    
    if (r > 16.0 || iteration >= max_iterations)
    {
     break;
    }
    
    z_prime = 2.0 * qmul(z, z_prime);
    
    z = qmul(z, z);
    
    z += mix(vec4(pos, k_slice), vec4(c, k_slice), julia_proportion);
   }
   
   
   r = length(z);
   float distance_1 = .5 * r * log(r) / length(z_prime);
   float distance_2 = length(pos - c) - .05;
   
   
   
   if (distance_2 < distance_1 && draw_sphere == 1)
   {
    return distance_2;
   }
   
   return distance_1;
  }
  
  
  
  vec3 get_color(vec3 pos)
  {
   vec4 z = vec4(pos, k_slice);
   vec4 z_prime = vec4(1.0, 0.0, 0.0, 0.0);
   float r;
   
   vec3 color = vec3(1.0, 1.0, 1.0);
   float color_scale = .5;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    r = length(z);
    
    if (r > 16.0 || iteration >= max_iterations)
    {
     break;
    }
    
    z_prime = 2.0 * qmul(z, z_prime);
    
    z = qmul(z, z);
    
    z += mix(vec4(pos, k_slice), vec4(c, k_slice), julia_proportion);
    
    color = mix(color, abs(normalize(z.xyz)), color_scale);
    
    color_scale *= .5;
   }
   
   color /= max(max(color.x, color.y), color.z);
   
   
   r = length(z);
   float distance_1 = .5 * r * log(r) / length(z_prime);
   float distance_2 = length(pos - c) - .05;
   
   
   
   if (distance_2 < distance_1 && draw_sphere == 1)
   {
    color = vec3(1.0, 1.0, 1.0);
   }
   
   return color;
  }
  
  
  
  vec3 get_surface_normal(vec3 pos)
  {
   float x_step_1 = distance_estimator(pos + vec3(.000001, 0.0, 0.0));
   float y_step_1 = distance_estimator(pos + vec3(0.0, .000001, 0.0));
   float z_step_1 = distance_estimator(pos + vec3(0.0, 0.0, .000001));
   
   float x_step_2 = distance_estimator(pos - vec3(.000001, 0.0, 0.0));
   float y_step_2 = distance_estimator(pos - vec3(0.0, .000001, 0.0));
   float z_step_2 = distance_estimator(pos - vec3(0.0, 0.0, .000001));
   
   return normalize(vec3(x_step_1 - x_step_2, y_step_1 - y_step_2, z_step_1 - z_step_2));
  }
  
  
  
  vec3 compute_shading(vec3 pos, int iteration)
  {
   vec3 surface_normal = get_surface_normal(pos);
   
   vec3 light_direction = normalize(light_pos - pos);
   
   float dot_product = dot(surface_normal, light_direction);
   
   float light_intensity = light_brightness * max(dot_product, -.25 * dot_product);
   
   //The last factor adds ambient occlusion.
   vec3 color = get_color(pos) * light_intensity * max((1.0 - float(iteration) / float(max_marches)), 0.0);
   
   
   
   //Apply fog.
   return mix(color, fog_color, 1.0 - exp(-distance(pos, camera_pos) * fog_scaling));
  }
  
  
  
  vec3 raymarch(vec3 start_pos)
  {
   //That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.
   vec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9 / step_factor;
   
   vec3 final_color = fog_color;
   
   float epsilon = 0.0;
   
   float t = 0.0;
   
   float last_distance = 1000.0;
   
   //int slowed_down = 0;
   
   
   
   for (int iteration = 0; iteration < 1024; iteration++)
   {
    if (iteration == max_marches)
    {
     break;
    }
    
    
    
    vec3 pos = start_pos + t * ray_direction_vec;
    
    //This prevents overstepping, and is honestly a pretty clever fix.
    float distance = min(distance_estimator(pos), last_distance);
    last_distance = distance;
    
    //This lowers the detail far away, which makes everything run nice and fast.
    epsilon = max(.0000006, .5 * t / float(image_size));
    
    
    
    if (distance < epsilon)
    {
     final_color = compute_shading(pos, iteration);
     break;
    }
    
    //Uncomment to add aggressive understepping when close to the fractal boundary, which helps to prevent flickering but is a significant performance hit.
    /*
    else if (last_distance / distance > .9999 && slowed_down == 0)
    {
     ray_direction_vec = normalize(start_pos - camera_pos) * .125;
     
     slowed_down = 1;
    }
    
    else if (last_distance / distance <= .9999 && slowed_down == 1)
    {
     ray_direction_vec = normalize(start_pos - camera_pos) * .9;
     
     slowed_down = 0;
    }
    */
    
    else if (t > clip_distance)
    {
     break;
    }
    
    
    
    t += distance;
   }
   
   
   
   return final_color;
  }
  
  
  
  void main(void)
  {
   //Uncomment to use 2x antialiasing.
   //vec3 final_color = (raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size)))) / 4.0;
   
   gl_FragColor = vec4(raymarch(image_plane_center_pos + right_vec * (uv.x) * aspect_ratio_x + up_vec * (uv.y) / aspect_ratio_y), 1.0);
  }
 `,t=new Wilson(Page.element.querySelector("#output-canvas"),{renderer:"gpu",shader:e,canvas_width:500,canvas_height:500,use_fullscreen:!0,true_fullscreen:!0,use_fullscreen_button:!0,enter_fullscreen_button_icon_path:"/graphics/general-icons/enter-fullscreen.png",exit_fullscreen_button_icon_path:"/graphics/general-icons/exit-fullscreen.png",switch_fullscreen_callback:em,mousedown_callback:ec,touchstart_callback:ec,mousedrag_callback:es,touchmove_callback:es,mouseup_callback:el,touchend_callback:el});t.render.init_uniforms(["aspect_ratio_x","aspect_ratio_y","image_size","camera_pos","image_plane_center_pos","forward_vec","right_vec","up_vec","focal_length","light_pos","draw_sphere","c","julia_proportion","max_marches","step_factor","max_iterations","k_slice"]);let o=!1,i=!1,$=!1,n=!1,a=!1,r=!1,c=!1,s=!1,l=!1,u=!1,m=0,f=[0,0,0,0],_=[0,0,0,0],p=1,d=-1,g=1.21557,v=2.10801,y=0,h=0,z=0,w=0,x=500,k=500,q=500,C=16,b=100,A=[],I=[],P=[],S=[],L=[-1.11619,-2.63802,1.67049],E=2,F=[-.54,-.25,-.668],T=[0,0,0],j=[0,0,0],N=0,U=0,B=0,J=1,M=0,D=0,G=0,H=0,K=Page.element.querySelector("#resolution-input");K.addEventListener("input",em);let O=Page.element.querySelector("#iterations-input");O.addEventListener("input",()=>{C=parseInt(O.value||16),t.gl.uniform1i(t.uniforms.max_iterations,C),window.requestAnimationFrame(ei)});let Q=Page.element.querySelector("#view-distance-input");Q.addEventListener("input",()=>{b=Math.max(parseInt(Q.value||100),32),t.gl.uniform1i(t.uniforms.max_marches,b),window.requestAnimationFrame(ei)});Page.element.querySelector("#download-button").addEventListener("click",()=>{0===J?t.download_frame("the-quaternionic-mandelbrot-set.png"):t.download_frame("a-quaternionic-julia-set.png")});let R=Page.element.querySelector("#c-x-input"),V=Page.element.querySelector("#c-y-input"),W=Page.element.querySelector("#c-z-input"),X=Page.element.querySelector("#c-w-input"),Y=[R,V,W,X];for(let Z=0;Z<Y.length;Z++)Y[Z].addEventListener("input",ef);let ee=Page.element.querySelector("#randomize-c-button");ee.style.opacity=1,ee.addEventListener("click",function e(t=!0){!o&&(T[0]=F[0],T[1]=F[1],T[2]=F[2],j[0]=2*Math.random()-1-T[0],j[1]=2*Math.random()-1-T[1],j[2]=2*Math.random()-1-T[2],R.value=Math.round((T[0]+j[0])*1e6)/1e6,V.value=Math.round((T[1]+j[1])*1e6)/1e6,W.value=Math.round((T[2]+j[2])*1e6)/1e6,D=J,G=0,U=N,B=0,t?e_():(F[0]=T[0]+j[0],F[1]=T[1]+j[1],F[2]=T[2]+j[2]))});let et=Page.element.querySelector("#switch-bulb-button");et.style.opacity=1,et.addEventListener("click",function e(){!o&&(Page.Animate.change_opacity(et,0,Site.opacity_animation_time),setTimeout(()=>{0===D?et.textContent="Switch to Mandelbrot Set":et.textContent="Switch to Julia Set",Page.Load.TextButtons.equalize(),Page.Animate.change_opacity(et,1,Site.opacity_animation_time)},Site.opacity_animation_time),0===J?(t.gl.uniform3fv(t.uniforms.c,F),M||t.gl.uniform1i(t.uniforms.draw_sphere,1),setTimeout(()=>{Page.Animate.change_opacity(eo,1,Site.opacity_animation_time),Page.Animate.change_opacity(ee,1,Site.opacity_animation_time)},Site.opacity_animation_time)):(M=!0,t.gl.uniform1i(t.uniforms.draw_sphere,0),Page.Animate.change_opacity(eo,0,Site.opacity_animation_time),Page.Animate.change_opacity(ee,0,Site.opacity_animation_time)),G=1-2*(D=J),U=N,B=0,T[0]=F[0],T[1]=F[1],T[2]=F[2],j[0]=0,j[1]=0,j[2]=0,e_())});let eo=Page.element.querySelector("#switch-movement-button");function ei(e){let u=e-d;if(d=e,0===u)return;t.render.draw_frame();let x=!1,k;o&&(k=.5*Math.sin(Math.PI*H/120-Math.PI/2)+.5,F[0]=T[0]+j[0]*k,F[1]=T[1]+j[1]*k,F[2]=T[2]+j[2]*k,t.gl.uniform3fv(t.uniforms.c,F),J=D+G*k,t.gl.uniform1f(t.uniforms.julia_proportion,J),N=U+B*k,t.gl.uniform1f(t.uniforms.k_slice,N),121==++H&&(o=!1),x=!0),i||$||n||a||s||l||r||c?(function e(){if(m=Math.min(Math.max(1e-6,p/20),.02),M){let o=[...L];i||s?(L[0]+=m*I[0],L[1]+=m*I[1],L[2]+=m*I[2]):($||l)&&(L[0]-=m*I[0],L[1]-=m*I[1],L[2]-=m*I[2]),n?(L[0]+=m*P[0]/E,L[1]+=m*P[1]/E,L[2]+=m*P[2]/E):a&&(L[0]-=m*P[0]/E,L[1]-=m*P[1]/E,L[2]-=m*P[2]/E),f[0]=L[0]-o[0],f[1]=L[1]-o[1],f[2]=L[2]-o[2]}else{let u=[...F],_=N;i||s?(F[0]+=.5*m*I[0],F[1]+=.5*m*I[1],F[2]+=.5*m*I[2]):($||l)&&(F[0]-=.5*m*I[0],F[1]-=.5*m*I[1],F[2]-=.5*m*I[2]),n?(F[0]+=.5*m*P[0]/E,F[1]+=.5*m*P[1]/E,F[2]+=.5*m*P[2]/E):a&&(F[0]-=.5*m*P[0]/E,F[1]-=.5*m*P[1]/E,F[2]-=.5*m*P[2]/E),r?N+=.5*m:c&&(N-=.5*m),R.value=Math.round(1e6*F[0])/1e6,V.value=Math.round(1e6*F[1])/1e6,W.value=Math.round(1e6*F[2])/1e6,X.value=Math.round(1e6*N)/1e6,t.gl.uniform3fv(t.uniforms.c,F),t.gl.uniform1f(t.uniforms.k_slice,N),f[0]=F[0]-u[0],f[1]=F[1]-u[1],f[2]=F[2]-u[2],f[3]=N-_}e$()}(),x=!0):u>=50&&(y=0,h=0,z=0,w=0,s=!1,l=!1,_[0]=0,_[1]=0,_[2]=0,_[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0),(0!==z||0!==w)&&(g+=z,v+=w,g>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),v>Math.PI-.01?v=Math.PI-.01:v<.01&&(v=.01),5e-4>Math.sqrt((z*=.94)*z+(w*=.94)*w)&&(z=0,w=0),e$(),x=!0),(0!==_[0]||0!==_[1]||0!==_[2]||0!==_[3])&&(M?(L[0]+=_[0],L[1]+=_[1],L[2]+=_[2]):(F[0]+=_[0],F[1]+=_[1],F[2]+=_[2],N+=_[3],R.value=Math.round(1e6*F[0])/1e6,V.value=Math.round(1e6*F[1])/1e6,W.value=Math.round(1e6*F[2])/1e6,X.value=Math.round(1e6*N)/1e6,t.gl.uniform3fv(t.uniforms.c,F),t.gl.uniform1f(t.uniforms.k_slice,N)),_[0]*=.94,_[1]*=.94,_[2]*=.94,_[3]*=.94,Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2]+_[3]*_[3])<5e-4*m&&(_[0]=0,_[1]=0,_[2]=0,_[3]=0),e$(),x=!0),x&&window.requestAnimationFrame(ei)}function e$(){var e,o,i;let $;S=(o=P=(e=[(I=[Math.cos(g)*Math.sin(v),Math.sin(g)*Math.sin(v),Math.cos(v)])[1],-I[0],0],$=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),[e[0]/$,e[1]/$,e[2]/$]),i=I,[o[1]*i[2]-o[2]*i[1],o[2]*i[0]-o[0]*i[2],o[0]*i[1]-o[1]*i[0]]),E=(p=function e(t,o,i){let $=[t,o,i,N],n=[1,0,0,0],a=0;for(let r=0;r<4*C&&!((a=Math.sqrt(ea($,$)))>16);r++)n=er(...$,...n),n[0]*=2,n[1]*=2,n[2]*=2,n[3]*=2,$=er(...$,...$),$[0]+=(1-J)*t+J*F[0],$[1]+=(1-J)*o+J*F[1],$[2]+=(1-J)*i+J*F[2],$[3]+=N;return .5*Math.log(a)*a/Math.sqrt(ea(n,n))}(L[0],L[1],L[2]))/2,P[0]*=E/2,P[1]*=E/2,S[0]*=E/2,S[1]*=E/2,S[2]*=E/2,A=[L[0]+E*I[0],L[1]+E*I[1],L[2]+E*I[2]],t.gl.uniform3fv(t.uniforms.camera_pos,L),t.gl.uniform3fv(t.uniforms.image_plane_center_pos,A),t.gl.uniform3fv(t.uniforms.forward_vec,I),t.gl.uniform3fv(t.uniforms.right_vec,P),t.gl.uniform3fv(t.uniforms.up_vec,S),t.gl.uniform1f(t.uniforms.focal_length,E)}function en(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function ea(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}function er(e,t,o,i,$,n,a,r){return[e*$-t*n-o*o-i*r,e*n+t*$+o*r-i*a,e*a-t*r+o*$+i*n,e*r+t*a-o*n+i*$]}function ec(e,t,o){y=0,h=0,z=0,w=0,"touchstart"===o.type&&(2===o.touches.length?(s=!0,l=!1,_[0]=0,_[1]=0,_[2]=0,_[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0,window.requestAnimationFrame(ei)):3===o.touches.length?(s=!1,l=!0,_[0]=0,_[1]=0,_[2]=0,_[3]=0,f[0]=0,f[1]=0,f[2]=0,f[3]=0,window.requestAnimationFrame(ei)):(s=!1,l=!1),u=!1)}function es(e,t,o,i,$){if("touchmove"===$.type&&u){u=!1;return}g+=o*Math.PI/2,y=o*Math.PI/2,g>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),v+=i*Math.PI/2,h=i*Math.PI/2,v>Math.PI-.01?v=Math.PI-.01:v<.01&&(v=.01),e$(),window.requestAnimationFrame(ei)}function el(e,t,o){"touchend"===o.type&&(s=!1,l=!1,u=!0,0===_[0]&&0===_[1]&&0===_[2]&&(_[0]=f[0],_[1]=f[1],_[2]=f[2],_[3]=f[3],f[0]=0,f[1]=0,f[2]=0,f[3]=0)),"touchend"===o.type&&o.touches,(0===length||"mouseup"===o.type)&&Math.sqrt(y*y+h*h)>=.005&&(z=y,w=h)}function e8(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode||69===e.keyCode||81===e.keyCode)&&(f=[0,0,0,0],_=[0,0,0,0],87===e.keyCode?i=!0:83===e.keyCode&&($=!0),68===e.keyCode?n=!0:65===e.keyCode&&(a=!0),69===e.keyCode?r=!0:81===e.keyCode&&(c=!0),window.requestAnimationFrame(ei))}function eu(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode||69===e.keyCode||81===e.keyCode)&&(0===_[0]&&0===_[1]&&0===_[2]&&0===_[3]&&(_[0]=f[0],_[1]=f[1],_[2]=f[2],_[3]=f[3],f[0]=0,f[1]=0,f[2]=0,f[3]=0),87===e.keyCode?i=!1:83===e.keyCode&&($=!1),68===e.keyCode?n=!1:65===e.keyCode&&(a=!1),69===e.keyCode?r=!1:81===e.keyCode&&(c=!1))}function em(){x=Math.max(100,parseInt(K.value||500)),t.fullscreen.currently_fullscreen?Page.Layout.aspect_ratio>=1?(k=x,q=Math.floor(x/Page.Layout.aspect_ratio)):(k=Math.floor(x*Page.Layout.aspect_ratio),q=x):(k=x,q=x),t.change_canvas_size(k,q),k>=q?(t.gl.uniform1f(t.uniforms.aspect_ratio_x,k/q),t.gl.uniform1f(t.uniforms.aspect_ratio_y,1)):(t.gl.uniform1f(t.uniforms.aspect_ratio_x,1),t.gl.uniform1f(t.uniforms.aspect_ratio_y,k/q)),t.gl.uniform1i(t.uniforms.image_size,x),window.requestAnimationFrame(ei)}function ef(){T[0]=F[0],T[1]=F[1],T[2]=F[2],j[0]=(parseFloat(R.value||0)||0)-T[0],j[1]=(parseFloat(V.value||0)||0)-T[1],j[2]=(parseFloat(W.value||0)||0)-T[2],D=J,G=0,U=N,B=(parseFloat(X.value||0)||0)-U,e_()}function e_(){o||(o=!0,H=0,window.requestAnimationFrame(ei))}eo.style.opacity=1,eo.addEventListener("click",function e(){M=!M,Page.Animate.change_opacity(eo,0,Site.opacity_animation_time),setTimeout(()=>{M?eo.textContent="Change Julia Set":eo.textContent="Move Camera",Page.Load.TextButtons.equalize(),Page.Animate.change_opacity(eo,1,Site.opacity_animation_time)},Site.opacity_animation_time),M?t.gl.uniform1i(t.uniforms.draw_sphere,0):t.gl.uniform1i(t.uniforms.draw_sphere,1)}),Page.Load.TextButtons.equalize(),e$(),k>=q?(t.gl.uniform1f(t.uniforms.aspect_ratio_x,k/q),t.gl.uniform1f(t.uniforms.aspect_ratio_y,1)):(t.gl.uniform1f(t.uniforms.aspect_ratio_x,1),t.gl.uniform1f(t.uniforms.aspect_ratio_y,k/q)),t.gl.uniform1i(t.uniforms.image_size,x),t.gl.uniform3fv(t.uniforms.camera_pos,L),t.gl.uniform3fv(t.uniforms.image_plane_center_pos,A),t.gl.uniform3fv(t.uniforms.light_pos,[-5,-5,5]),t.gl.uniform3fv(t.uniforms.forward_vec,I),t.gl.uniform3fv(t.uniforms.right_vec,P),t.gl.uniform3fv(t.uniforms.up_vec,S),t.gl.uniform1f(t.uniforms.focal_length,E),t.gl.uniform1i(t.uniforms.draw_sphere,0),t.gl.uniform3fv(t.uniforms.c,F),t.gl.uniform1f(t.uniforms.julia_proportion,1),t.gl.uniform1i(t.uniforms.k_slice,0),t.gl.uniform1i(t.uniforms.max_marches,b),t.gl.uniform1f(t.uniforms.step_factor,1),t.gl.uniform1i(t.uniforms.max_iterations,C),window.requestAnimationFrame(ei),Page.show(),document.documentElement.addEventListener("keydown",e8),Page.temporary_handlers.keydown.push(e8),document.documentElement.addEventListener("keyup",eu),Page.temporary_handlers.keydown.push(eu)}();