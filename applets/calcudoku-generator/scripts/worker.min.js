onmessage=function(c){gridSize=c.data[0];maxCageSize=c.data[1];importScripts("/applets/calcudoku-generator/scripts/solver.js");Module.onRuntimeInitialized=function(){importScripts("/scripts/wasm-arrays.min.js");generateCalcudokuGrid()}};let gridSize=null,maxCageSize=null,grid=[],cages=[],cagesByLocation=[],numSolutionsFound=0;
function generateCalcudokuGrid(){grid=[];cages=[];cagesByLocation=[];generateNumberGrid();assignInitialCages();let c=JSON.parse(JSON.stringify(cages)),a=JSON.parse(JSON.stringify(cagesByLocation));for(;;){let b=!1,d=shuffleArray([...Array(cages.length).keys()]);d.sort((f,g)=>cages[f][2].length-cages[g][2].length);for(let f=0;f<d.length;f++){if(-1!==expandCages(d[f])){b=!0;for(let g=0;g<d.length;g++)d[g]>=cages.length&&d[g]--}numSolutionsFound=wasmSolvePuzzle(cages);1!==numSolutionsFound?(cages=JSON.parse(JSON.stringify(c)),
cagesByLocation=JSON.parse(JSON.stringify(a)),numSolutionsFound=1):(c=JSON.parse(JSON.stringify(cages)),a=JSON.parse(JSON.stringify(cagesByLocation)),postMessage([grid,cages,cagesByLocation]))}if(!1===b)break}}function shuffleArray(c){let a=c.length;for(;0!==a;){const b=Math.floor(Math.random()*a);--a;let d=c[a];c[a]=c[b];c[b]=d}return c}
function generateNumberGrid(){grid=[];for(var c=0;c<gridSize;c++){grid[c]=[];for(var a=0;a<gridSize;a++)grid[c][a]=0}for(c=0;c<gridSize;c++)for(a=0;a<gridSize;a++)grid[c][a]=(a+c)%gridSize+1;c=shuffleArray([shuffleGridRows,shuffleGridRows,shuffleGridColumns,shuffleGridColumns,shuffleGridDigits,shuffleGridDigits]);for(a=0;6>a;a++)c[a]()}
function shuffleGridRows(){const c=shuffleArray([...Array(gridSize).keys()]);let a=[];for(var b=0;b<gridSize;b++){a[b]=[];for(let d=0;d<gridSize;d++)a[b][d]=0}for(b=0;b<gridSize;b++)a[b]=JSON.parse(JSON.stringify(grid[c[b]]));grid=JSON.parse(JSON.stringify(a))}
function shuffleGridColumns(){const c=shuffleArray([...Array(gridSize).keys()]);let a=[];for(var b=0;b<gridSize;b++){a[b]=[];for(var d=0;d<gridSize;d++)a[b][d]=0}for(b=0;b<gridSize;b++)for(d=0;d<gridSize;d++)a[b][d]=grid[b][c[d]];grid=JSON.parse(JSON.stringify(a))}
function shuffleGridDigits(){const c=shuffleArray([...Array(gridSize).keys()]);let a=[];for(var b=0;b<gridSize;b++){a[b]=[];for(var d=0;d<gridSize;d++)a[b][d]=0}for(b=0;b<gridSize;b++)for(d=0;d<gridSize;d++)a[b][d]=c[grid[b][d]-1]+1;grid=JSON.parse(JSON.stringify(a))}
function assignInitialCages(){cages=[];cagesByLocation=[];cagesByLocation=[];for(let c=0;c<gridSize;c++){cagesByLocation[c]=[];for(let a=0;a<gridSize;a++){const b=grid[c][a];cages.push(["",b,[[c,a]],b,b,b]);cagesByLocation[c][a]=cages.length-1}}}
function expandCages(c){var a=cages[c][2][0][0];var b=cages[c][2][0][1];if(.5>Math.random())if(0!==a&&cagesByLocation[a-1][b]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a-1][b]))a=cagesByLocation[a-1][b];else if(a!==gridSize-1&&cagesByLocation[a+1][b]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a+1][b]))a=cagesByLocation[a+1][b];else if(0!==b&&cagesByLocation[a][b-1]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a][b-1]))a=cagesByLocation[a][b-
1];else if(b!==gridSize-1&&cagesByLocation[a][b+1]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a][b+1]))a=cagesByLocation[a][b+1];else return;else if(0!==b&&cagesByLocation[a][b-1]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a][b-1]))a=cagesByLocation[a][b-1];else if(b!==gridSize-1&&cagesByLocation[a][b+1]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a][b+1]))a=cagesByLocation[a][b+1];else if(0!==a&&cagesByLocation[a-1][b]!==c&&tryToAddCageToCage(cagesByLocation[a][b],
cagesByLocation[a-1][b]))a=cagesByLocation[a-1][b];else if(a!==gridSize-1&&cagesByLocation[a+1][b]!==c&&tryToAddCageToCage(cagesByLocation[a][b],cagesByLocation[a+1][b]))a=cagesByLocation[a+1][b];else return;addCageToCage(c,a);cages.splice(c,1);for(a=0;a<gridSize;a++)for(b=0;b<gridSize;b++)cagesByLocation[a][b]>c&&cagesByLocation[a][b]--}
function tryToAddCageToCage(c,a){if(cages[a][2].length+cages[c][2].length>maxCageSize)return!1;if(""===cages[a][0]||"+"===cages[a][0]||"x"===cages[a][0]||"-"===cages[a][0]&&cages[a][4]+cages[c][4]<=2*Math.max(cages[a][3],cages[c][3]))return!0;if(":"===cages[a][0]){const b=Math.max(cages[a][3],cages[c][3]);if(0===b*b%(cages[a][5]*cages[c][5]))return!0}return!1}
function addCageToCage(c,a){if(""===cages[a][0]){var b=["+","x"];let f=[cages[a][1]+cages[c][4],cages[a][1]*cages[c][5]];var d=Math.max(cages[a][1],cages[c][3]);2*d>=cages[a][1]+cages[c][4]&&(b.push("-"),f.push(2*d-(cages[a][1]+cages[c][4])));0===d*d%(cages[a][1]*cages[c][5])&&(b.push(":"),f.push(d*d/(cages[a][1]*cages[c][5])));b.includes(":")&&.5>Math.random()?(d=b.indexOf(":"),cages[a][0]=b[d],cages[a][1]=f[d]):(d=Math.floor(Math.random()*b.length),cages[a][0]=b[d],cages[a][1]=f[d])}else"+"===cages[a][0]?
cages[a][1]+=cages[c][4]:"x"===cages[a][0]?cages[a][1]*=cages[c][5]:"-"===cages[a][0]?cages[a][1]=2*Math.max(cages[a][3],cages[c][3])-(cages[a][4]+cages[c][4]):":"===cages[a][0]&&(b=Math.max(cages[a][3],cages[c][3]),cages[a][1]=b*b/(cages[a][5]*cages[c][5]));cages[a][2]=cages[a][2].concat(cages[c][2]);cages[a][3]=Math.max(cages[a][3],cages[c][3]);cages[a][4]+=cages[c][4];cages[a][5]*=cages[c][5];for(b=0;b<cages[c][2].length;b++)cagesByLocation[cages[c][2][b][0]][cages[c][2][b][1]]=a}
function wasmSolvePuzzle(){let c=[];var a={"":0,"+":1,x:2,"-":3,":":4};let b=[],d=[],f=[],g=[],h=[];for(var e=0;e<cages.length;e++)c[e]=a[cages[e][0]],b[e]=cages[e][1],d[e]=cages[e][2].length,f[e]=cages[e][3],g[e]=cages[e][4],h[e]=cages[e][5];a=[];for(e=0;e<gridSize;e++)a=a.concat(cagesByLocation[e]);return ccallArrays("solve_puzzle","number","number array array array array array array array".split(" "),[gridSize,c,b,d,f,g,h,a],{heapIn:"HEAPU32"})}
function pairInArray(c,a){for(let b=0;b<a.length;b++)if(a[b][0]===c[0]&&a[b][1]===c[1])return b;return-1};
