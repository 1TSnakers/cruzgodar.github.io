import{dotProduct,magnitude,mat3TimesVector,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";import{animate,clamp}from"/scripts/src/utils.min.js";const minRadius2=.1,fixedRadius2=1,foldingLimit=1,numIterations=32;function sphereFold(z,dz){var o,i=dotProduct(z,z);return i<minRadius2?(o=fixedRadius2/minRadius2,z[0]*=o,z[1]*=o,z[2]*=o,dz*=o):i<fixedRadius2&&(o=fixedRadius2/i,z[0]*=o,z[1]*=o,z[2]*=o,dz*=o),dz}function boxFold(z){z[0]=2*clamp(z[0],-foldingLimit,foldingLimit)-z[0],z[1]=2*clamp(z[1],-foldingLimit,foldingLimit)-z[1],z[2]=2*clamp(z[2],-foldingLimit,foldingLimit)-z[2]}class Mandelbox extends RaymarchApplet{constructor({canvas}){super({canvas:canvas,resolution:500,addGlsl:`
			const float minRadius2 = 0.01;
			const float fixedRadius2 = 0.5;
			const float foldingLimit = 1.0;


			void sphereFold(inout vec3 z, inout float dz)
			{
				float r2 = dot(z, z);

				if (r2 < minRadius2)
				{ 
					// linear inner scaling
					float temp = fixedRadius2 / minRadius2;
					z *= temp;
					dz *= temp;
				}

				else if (r2 < fixedRadius2)
				{ 
					// this is the actual sphere inversion
					float temp = fixedRadius2 / r2;
					z *= temp;
					dz *= temp;
				}
			}

			void boxFold(inout vec3 z)
			{
				z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;
			}
		`,distanceEstimatorGlsl:`
			pos = pos * (scale > 0.0 ? (scale + 1.0) / (scale - 1.0) : 1.0);
			vec3 initialPos = mix(pos, c, juliaProportion);

			float dr = 1.0;

			for (int iteration = 0; iteration < ${numIterations}; iteration++)
			{
				boxFold(pos);
				sphereFold(pos, dr);

				pos = scale * pos + initialPos;
				dr = dr * abs(scale) + 1.0;

				pos = rotationMatrix * pos;
			}

			return length(pos) / abs(dr);
		`,getColorGlsl:`
			pos = pos * (scale > 0.0 ? (scale + 1.0) / (scale - 1.0) : 1.0);
			vec3 initialPos = mix(pos, c, juliaProportion);

			float dr = 1.0;

			vec3 color = vec3(1.0, 1.0, 1.0);
			float colorScale = .5;

			for (int iteration = 0; iteration < ${numIterations}; iteration++)
			{
				boxFold(pos);
				sphereFold(pos, dr);

				pos = scale * pos + initialPos;
				dr = dr * abs(scale) + 1.0;

				color = mix(color, abs(normalize(pos)), colorScale);
				colorScale *= .5;

				pos = rotationMatrix * pos;
			}
			
			color /= max(max(color.x, color.y), color.z);
			
			return color;
		`,uniformsGlsl:`
			uniform float scale;
			uniform vec3 c;
			uniform float juliaProportion;
			uniform mat3 rotationMatrix;
		`,uniforms:{scale:2,c:[0,0,0],juliaProportion:0,rotationMatrix:[[1,0,0],[0,1,0],[0,0,1]]},theta:4.6601,phi:2.272,cameraPos:[4,0,0],lightPos:[-10,0,15],fogScaling:.025,lightBrightness:1.1,stepFactor:.9,minEpsilon:5e-6})}distanceEstimator(x,y,z){var o=this.uniforms.scale,i=this.uniforms.c,t=this.uniforms.juliaProportion,a=this.uniforms.rotationMatrix,s=0<o?(o+1)/(o-1):1,r=[(1-t)*(x*=s)+t*i[0],(1-t)*(y*=s)+t*i[1],(1-t)*(z*=s)+t*i[2]];let n=[x,y,z],e=1;for(let l=0;l<numIterations;l++)boxFold(n),e=sphereFold(n,e),n[0]=o*n[0]+r[0],n[1]=o*n[1]+r[1],n[2]=o*n[2]+r[2],e=e*Math.abs(o)+1,n=mat3TimesVector(a,n);return magnitude(n)/Math.abs(e)}switchBox(instant){const o=this.uniforms.juliaProportion,i=0===this.uniforms.juliaProportion?1:0;animate(t=>{this.setUniforms({juliaProportion:(1-t)*o+t*i}),this.needNewFrame=!0},instant?0:650,"easeOutQuad")}}export{Mandelbox};