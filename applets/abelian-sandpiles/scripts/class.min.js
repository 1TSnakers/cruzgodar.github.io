import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{siteSettings}from"/scripts/src/settings.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class AbelianSandpile extends AnimationFrameApplet{wilsonUpdate;numGrains;floodGrains;resolution=319;resolutionUpdate;computationsPerFrame=20;lastPixelData;constructor({canvas}){super(canvas);var e=this.createHiddenCanvas(!1),t={shaders:{init:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			
			uniform float stepSize;
			
			uniform vec4 startGrains;
			uniform vec4 floodGrains;
			
			
			
			void main(void)
			{
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;

				if (center.y - center.x > stepSize / 4.0)
				{
					gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
					return;
				}

				if (length(center) < stepSize)
				{
					gl_FragColor = startGrains;
					return;
				}
				
				gl_FragColor = floodGrains;
			}
		`,update:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			
			uniform float stepSize;

			const float amountNearby = 4.0;
			const float divisor = 256.0 / amountNearby;

			

			// The general idea: this is carrying in reverse. The largest place is supposed to be divided by four, so we
			// start by extracting the portion that is too small for it to see and adding it to the next place down (not
			// dividing by 256 effectively multiplies it by 256). Then what's left is divided by 4 and effectively floored.

			void quotientState(inout vec4 state)
			{
				state.y += mod(floor(state.x * 256.0), amountNearby);
				state.x = floor(state.x * divisor) / 256.0;
				
				state.z += mod(floor(state.y * 256.0), amountNearby);
				state.y = floor(state.y * divisor) / 256.0;
				
				state.w += mod(floor(state.z * 256.0), amountNearby);
				state.z = floor(state.z * divisor) / 256.0;
				
				state.w = floor(state.w * divisor) / 256.0;
			}
			
			void main(void)
			{
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;

				if (
					center.y > center.x + stepSize / 2.0
					|| abs(center.x - 1.0) < stepSize
				) {
					gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
					return;
				}

				vec4 state = texture2D(uTexture, center);
				float leftover = mod(floor(256.0 * state.w), amountNearby) / 256.0;

				vec4 stateUp;
				vec4 stateDown;
				vec4 stateLeft;
				vec4 stateRight = texture2D(uTexture, center + vec2(stepSize, 0.0));

				if (length(center) < stepSize)
				{
					stateDown = stateRight;
					stateUp = stateRight;
					stateLeft = stateRight;

					// gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
					// return;
				}

				else if (abs(center.y) < stepSize)
				{
					stateUp = texture2D(uTexture, center + vec2(0.0, stepSize));
					stateDown = stateUp;
					stateLeft = texture2D(uTexture, center + vec2(-stepSize, 0.0));

					// gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
					// return;
				}

				else if (abs(center.x - center.y) < stepSize / 4.0)
				{
					stateDown = texture2D(uTexture, center + vec2(0.0, -stepSize));
					stateUp = stateDown;
					stateLeft = stateRight;

					// gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);
					// return;
				}

				else
				{
					stateUp = texture2D(uTexture, center + vec2(0.0, stepSize));
					stateDown = texture2D(uTexture, center + vec2(0.0, -stepSize));
					stateLeft = texture2D(uTexture, center + vec2(-stepSize, 0.0));

					// gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
					// return;
				}

				quotientState(stateUp);
				quotientState(stateDown);
				quotientState(stateLeft);
				quotientState(stateRight);
				
				
				//The new state should be what used to be here, mod 4, plus the floor of 1/4 of each of the neighbors.
				vec4 newState = vec4(0.0, 0.0, 0.0, leftover) + stateUp + stateDown + stateLeft + stateRight;
				
				newState.z += floor(newState.w) / 256.0;
				newState.w = mod(newState.w, 1.0);
				
				newState.y += floor(newState.z) / 256.0;
				newState.z = mod(newState.z, 1.0);
				
				newState.x += floor(newState.y) / 256.0;
				newState.y = mod(newState.y, 1.0);
				
				gl_FragColor = newState;
			}
		`},uniforms:{init:{stepSize:0,startGrains:[0,0,0,0],floodGrains:[0,0,0,0]},update:{stepSize:0}},canvasWidth:Math.ceil(this.resolution/2)},e=(this.wilsonUpdate=new WilsonGPU(e,t),{shader:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;

			uniform vec3 color1;
			uniform vec3 color2;
			uniform vec3 color3;
			
			void main(void)
			{
				vec2 modUv = abs(uv);

				if (modUv.y > modUv.x)
				{
					modUv = vec2(modUv.y, modUv.x);
				}

				vec2 state = floor(256.0 * texture2D(uTexture, modUv).zw);
				
				if (state.x != 0.0)
				{
					gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
					return;
				}
				
				if (state.y == 1.0)
				{
					gl_FragColor = vec4(color1, 1.0);
					return;
				}
				
				if (state.y == 2.0)
				{
					gl_FragColor = vec4(color2, 1.0);
					return;
				}
				
				if (state.y == 3.0)
				{
					gl_FragColor = vec4(color3, 1.0);
					return;
				}
				
				if (state.y >= 4.0)
				{
					float brightness = (state.y - 3.0) / 512.0 + .5;
					gl_FragColor = vec4(brightness, brightness, brightness, 1.0);
					return;
				}
				
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
		`,uniforms:{color1:[0,0,0],color2:[0,0,0],color3:[0,0,0]},canvasWidth:this.resolution,reduceMotion:siteSettings.reduceMotion,fullscreenOptions:{useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}});this.wilson=new WilsonGPU(canvas,e),this.canvas.style.imageRendering="pixelated"}run({resolution=100,numGrains=1e4,floodGrains=0,computationsPerFrame=25,palette=[[229,190,237],[149,147,217],[124,144,219]]}){this.resolution=resolution+1-resolution%2,this.resolutionUpdate=Math.ceil(this.resolution/2),this.numGrains=numGrains,this.floodGrains=floodGrains,this.computationsPerFrame=computationsPerFrame;var e=[Math.floor(this.numGrains/16777216)%256/256,Math.floor(this.numGrains/65536)%256/256,Math.floor(this.numGrains/256)%256/256,this.numGrains%256/256];this.wilsonUpdate.setUniform({shader:"init",name:"stepSize",value:1/this.resolutionUpdate}),this.wilsonUpdate.setUniform({shader:"init",name:"startGrains",value:e}),this.wilsonUpdate.setUniform({shader:"init",name:"floodGrains",value:[0,0,0,this.floodGrains/256]}),this.wilsonUpdate.setUniform({shader:"update",name:"stepSize",value:1/this.resolutionUpdate}),this.wilsonUpdate.resizeCanvas({width:this.resolutionUpdate}),this.wilson.setUniform({name:"color1",value:[palette[0][0]/255,palette[0][1]/255,palette[0][2]/255]}),this.wilson.setUniform({name:"color2",value:[palette[1][0]/255,palette[1][1]/255,palette[1][2]/255]}),this.wilson.setUniform({name:"color3",value:[palette[2][0]/255,palette[2][1]/255,palette[2][2]/255]}),this.wilson.resizeCanvas({width:this.resolution}),this.wilson.createFramebufferTexturePair({id:"output",width:this.resolutionUpdate,height:this.resolutionUpdate,textureType:"unsignedByte"}),this.wilson.useFramebuffer(null),this.wilsonUpdate.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilsonUpdate.createFramebufferTexturePair({id:"1",textureType:"unsignedByte"}),this.wilsonUpdate.useTexture("0"),this.wilsonUpdate.useFramebuffer(null),this.wilsonUpdate.useShader("update"),this.wilsonUpdate.setTexture({id:"0",data:null}),this.wilsonUpdate.setTexture({id:"1",data:null}),this.wilsonUpdate.useShader("init"),this.wilsonUpdate.useTexture("1"),this.wilsonUpdate.useFramebuffer("0"),this.wilsonUpdate.drawFrame(),this.wilsonUpdate.useTexture("0"),this.resume()}drawFrame(){this.wilsonUpdate.useShader("update");for(let e=0;e<this.computationsPerFrame;e++)this.wilsonUpdate.useFramebuffer("1"),this.wilsonUpdate.drawFrame(),this.wilsonUpdate.useTexture("1"),this.wilsonUpdate.useFramebuffer("0"),this.wilsonUpdate.drawFrame(),this.wilsonUpdate.useTexture("0");var s=this.wilsonUpdate.readPixels();if(this.wilson.setTexture({id:"output",data:s}),this.wilson.drawFrame(),this.lastPixelData){let e=!1;for(let t=0;t<s.length;t++)if(s[t]!==this.lastPixelData[t]){e=!0;break}if(!e)return void this.pause()}this.lastPixelData=s,this.needNewFrame=!0}}export{AbelianSandpile};