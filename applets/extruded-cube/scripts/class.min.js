import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class ExtrudedCube extends RaymarchApplet{maxIterations=16;cameraPos=[1.749,1.75,1.751];theta=1.25*Math.PI;phi=2.1539;constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:`
			float scaleCenter = (scale + 1.0) / (scale - 1.0) * separation;

			vec3 mutablePos = abs(pos);

			float totalDistance = (max(max(mutablePos.x, mutablePos.y), mutablePos.z) - 1.0);

			for (int iteration = 0; iteration < maxIterations; iteration++)
			{
				if (iteration == iterations)
				{
					break;
				}

				if (mutablePos.x > max(mutablePos.y, mutablePos.z))
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(scaleCenter, 0.0, 0.0);
				}

				else if (mutablePos.y > max(mutablePos.x, mutablePos.z))
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(0.0, scaleCenter, 0.0);
				}

				else
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(0.0, 0.0, scaleCenter);
				}

				mutablePos = abs(mutablePos);

				totalDistance = min(
					totalDistance,
					(max(max(mutablePos.x, mutablePos.y), mutablePos.z) - 1.0)
						/ pow(scale, float(iteration + 1))
				);
			}
			
			return totalDistance;
		`,getColorGlsl:`	
			vec3 color = vec3(0.25);

			float scaleCenter = (scale + 1.0) / (scale - 1.0) * separation;

			vec3 mutablePos = abs(pos);

			for (int iteration = 0; iteration < maxIterations; iteration++)
			{
				if (iteration == iterations)
				{
					break;
				}

				if (mutablePos.x > max(mutablePos.y, mutablePos.z))
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(scaleCenter, 0.0, 0.0);

					color += vec3(0.0, 0.75, 1.0) * pow(2.0, -float(iteration + 1));
				}

				else if (mutablePos.y > max(mutablePos.x, mutablePos.z))
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(0.0, scaleCenter, 0.0);

					color += vec3(0.75, 0.0, 1.0) * pow(2.0, -float(iteration + 1));
				}

				else
				{
					mutablePos = scale * mutablePos - (scale - 1.0) * vec3(0.0, 0.0, scaleCenter);

					color += vec3(0.0, 0.0, 1.0) * pow(2.0, -float(iteration + 1));
				}

				mutablePos = abs(mutablePos);
			}
			
			return color;
		`,addGlsl:`
			const int maxIterations = 16;
		`,uniforms:{iterations:["int",16],scale:["float",3],separation:["float",1]}})}distanceEstimator(x,y,z){var a=(this.uniforms.scale+1)/(this.uniforms.scale-1)*this.uniforms.separation;let t=[Math.abs(x),Math.abs(y),Math.abs(z)],e=Math.max(Math.max(t[0],t[1]),t[2])-1;for(let s=0;s<this.maxIterations;s++)t=t[0]>Math.max(t[1],t[2])?[this.uniforms.scale*t[0]-(this.uniforms.scale-1)*a,this.uniforms.scale*t[1],this.uniforms.scale*t[2]]:t[1]>Math.max(t[0],t[2])?[this.uniforms.scale*t[0],this.uniforms.scale*t[1]-(this.uniforms.scale-1)*a,this.uniforms.scale*t[2]]:[this.uniforms.scale*t[0],this.uniforms.scale*t[1],this.uniforms.scale*t[2]-(this.uniforms.scale-1)*a],t=[Math.abs(t[0]),Math.abs(t[1]),Math.abs(t[2])],e=Math.min(e,(Math.max(Math.max(t[0],t[1]),t[2])-1)/Math.pow(this.uniforms.scale,s+1));return Math.abs(e)}}export{ExtrudedCube};