"use strict";onmessage=async function(e){numVertices=e.data[0],gridSize=e.data[1],await drawChaosGame()};let numVertices=null,gridSize=null,image=[],vertices=[],centerRow=null,centerCol=null,currentRow=null,currentCol=null,numPixelsAtMax=0;function drawChaosGame(){return new Promise((r,e)=>{image=new Uint8ClampedArray(gridSize*gridSize*4);for(let r=0;r<gridSize;r++)for(let e=0;e<gridSize;e++)image[4*(gridSize*r+e)]=0,image[4*(gridSize*r+e)+1]=0,image[4*(gridSize*r+e)+2]=0,image[4*(gridSize*r+e)+3]=255;var i=2*Math.floor(numVertices/2)*Math.PI/numVertices,t=gridSize/2-gridSize/2.5,i=gridSize/2-gridSize/2.5*Math.cos(i),t=t+(gridSize-i);centerRow=Math.floor(t/2+gridSize/2.5),centerCol=Math.floor(gridSize/2),currentRow=centerRow,currentCol=centerCol,vertices=[];for(let e=0;e<numVertices;e++){var a=e/numVertices*2*Math.PI,o=Math.floor(-Math.cos(a)*gridSize/2.5+centerRow),a=Math.floor(Math.sin(a)*gridSize/2.5+centerCol);vertices.push([o,a])}let n=0;for(;;){n%(100*gridSize)==0&&postMessage([image]);var c=Math.floor(Math.random()*numVertices),c=(currentRow=Math.floor((currentRow+vertices[c][0])/2),currentCol=Math.floor((currentCol+vertices[c][1])/2),(Math.atan2(currentCol-gridSize/2,currentRow-gridSize/2)+Math.PI)/(2*Math.PI)),g=HSVtoRGB(c,((currentRow-gridSize/2)*(currentRow-gridSize/2)+(currentCol-gridSize/2)*(currentCol-gridSize/2))/(gridSize*gridSize/13),1);g[0]/=255,g[1]/=255,g[2]/=255;for(let e=0;e<3;e++)if(image[4*(gridSize*currentRow+currentCol)+e]+=8*g[e],255<=image[4*(gridSize*currentRow+currentCol)+e]&&(numPixelsAtMax++,image[4*(gridSize*currentRow+currentCol)+e]=255,.004<numPixelsAtMax/(gridSize*gridSize)))return postMessage([image]),void r();n++}postMessage([image]),r()})}function HSVtoRGB(e,r,i){let t,a,o,n,c,g,u,l;switch(g=i*(1-r),u=i*(1-(c=6*e-(n=Math.floor(6*e)))*r),l=i*(1-(1-c)*r),n%6){case 0:t=i,a=l,o=g;break;case 1:t=u,a=i,o=g;break;case 2:t=g,a=i,o=l;break;case 3:t=g,a=u,o=i;break;case 4:t=l,a=g,o=i;break;case 5:t=i,a=g,o=u}return[Math.round(255*t),Math.round(255*a),Math.round(255*o)]}