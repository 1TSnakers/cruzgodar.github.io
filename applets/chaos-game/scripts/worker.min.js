onmessage=async function(d){numVertices=d.data[0];gridSize=d.data[1];await drawChaosGame()};let numVertices=null,gridSize=null,image=[],vertices=[],centerRow=null,centerCol=null,currentRow=null,currentCol=null,numPixelsAtMax=0;
function drawChaosGame(){return new Promise((d,b)=>{image=new Uint8ClampedArray(gridSize*gridSize*4);for(b=0;b<gridSize;b++)for(var a=0;a<gridSize;a++)image[4*(gridSize*b+a)]=0,image[4*(gridSize*b+a)+1]=0,image[4*(gridSize*b+a)+2]=0,image[4*(gridSize*b+a)+3]=255;centerRow=Math.floor((gridSize/2-gridSize/2.5+(gridSize-(gridSize/2-gridSize/2.5*Math.cos(2*Math.floor(numVertices/2)*Math.PI/numVertices))))/2+gridSize/2.5);centerCol=Math.floor(gridSize/2);currentRow=centerRow;currentCol=centerCol;vertices=
[];for(b=0;b<numVertices;b++)a=b/numVertices*2*Math.PI,vertices.push([Math.floor(-Math.cos(a)*gridSize/2.5+centerRow),Math.floor(Math.sin(a)*gridSize/2.5+centerCol)]);for(b=0;;){0===b%(100*gridSize)&&postMessage([image]);a=Math.floor(Math.random()*numVertices);currentRow=Math.floor((currentRow+vertices[a][0])/2);currentCol=Math.floor((currentCol+vertices[a][1])/2);a=HSVtoRGB((Math.atan2(currentCol-gridSize/2,currentRow-gridSize/2)+Math.PI)/(2*Math.PI),((currentRow-gridSize/2)*(currentRow-gridSize/
2)+(currentCol-gridSize/2)*(currentCol-gridSize/2))/(gridSize*gridSize/13),1);a[0]/=255;a[1]/=255;a[2]/=255;for(let c=0;3>c;c++)if(image[4*(gridSize*currentRow+currentCol)+c]+=8*a[c],255<=image[4*(gridSize*currentRow+currentCol)+c]&&(numPixelsAtMax++,image[4*(gridSize*currentRow+currentCol)+c]=255,.004<numPixelsAtMax/(gridSize*gridSize))){postMessage([image]);d();return}b++}})}
function HSVtoRGB(d,b,a){let c,e,f,h,k,g;h=Math.floor(6*d);k=6*d-h;d=a*(1-b);g=a*(1-k*b);b=a*(1-(1-k)*b);switch(h%6){case 0:c=a;e=b;f=d;break;case 1:c=g;e=a;f=d;break;case 2:c=d;e=a;f=b;break;case 3:c=d;e=g;f=a;break;case 4:c=b;e=d;f=a;break;case 5:c=a,e=d,f=g}return[Math.round(255*c),Math.round(255*e),Math.round(255*f)]};
