"use strict";onmessage=async function(e){numVertices=e.data[0],gridSize=e.data[1],await drawChaosGame()};let numVertices=null,gridSize=null,image=[],vertices=[],centerRow=null,centerCol=null,currentRow=null,currentCol=null,numPixelsAtMax=0;function drawChaosGame(){return new Promise((e,r)=>{image=new Uint8ClampedArray(gridSize*gridSize*4);for(let i=0;i<gridSize;i++)for(let t=0;t<gridSize;t++)image[4*(gridSize*i+t)]=0,image[4*(gridSize*i+t)+1]=0,image[4*(gridSize*i+t)+2]=0,image[4*(gridSize*i+t)+3]=255;let o=gridSize/2-gridSize/2.5,n=gridSize/2-gridSize/2.5*Math.cos(2*Math.floor(numVertices/2)*Math.PI/numVertices);centerRow=Math.floor((o+(gridSize-n))/2+gridSize/2.5),centerCol=Math.floor(gridSize/2),currentRow=centerRow,currentCol=centerCol,vertices=[];for(let c=0;c<numVertices;c++){let l=c/numVertices*2*Math.PI,u=Math.floor(-Math.cos(l)*gridSize/2.5+centerRow),g=Math.floor(Math.sin(l)*gridSize/2.5+centerCol);vertices.push([u,g])}let a=0;for(;;){a%(100*gridSize)==0&&postMessage([image]);let d=Math.floor(Math.random()*numVertices);currentRow=Math.floor((currentRow+vertices[d][0])/2);let S=(Math.atan2((currentCol=Math.floor((currentCol+vertices[d][1])/2))-gridSize/2,currentRow-gridSize/2)+Math.PI)/(2*Math.PI),z=HSVtoRGB(S,((currentRow-gridSize/2)*(currentRow-gridSize/2)+(currentCol-gridSize/2)*(currentCol-gridSize/2))/(gridSize*gridSize/13),1);z[0]/=255,z[1]/=255,z[2]/=255;for(let s=0;s<3;s++)if(image[4*(gridSize*currentRow+currentCol)+s]+=8*z[s],image[4*(gridSize*currentRow+currentCol)+s]>=255&&(numPixelsAtMax++,image[4*(gridSize*currentRow+currentCol)+s]=255,numPixelsAtMax/(gridSize*gridSize)>.004)){postMessage([image]),e();return}a++}postMessage([image]),e()})}function HSVtoRGB(e,r,i){let t,o,n,c,l,u,g,a;switch(c=Math.floor(6*e),l=6*e-c,u=i*(1-r),g=i*(1-l*r),a=i*(1-(1-l)*r),c%6){case 0:t=i,o=a,n=u;break;case 1:t=g,o=i,n=u;break;case 2:t=u,o=i,n=a;break;case 3:t=u,o=g,n=i;break;case 4:t=a,o=u,n=i;break;case 5:t=i,o=u,n=g}return[Math.round(255*t),Math.round(255*o),Math.round(255*n)]}