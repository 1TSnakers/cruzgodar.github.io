onmessage=async function(b){gridSize=b.data[0];K=b.data[1];orbitSeparation=b.data[2];await drawKickedRotator()};let gridSize=null,K=null,orbitSeparation=null,image=[],currentRow=null,currentCol=null,currentP=null,currentTheta=null;const maxRepetitions=50;
function drawKickedRotator(){const b=Math.floor(gridSize/2);for(let e=1;e<gridSize/2;e+=orbitSeparation+1){image=Array(gridSize*gridSize);for(var c=0;c<gridSize;c++)for(var a=0;a<gridSize;a++)image[gridSize*c+a]=0;c=6/7*e/(gridSize/2);a=calculateOrbit(Math.floor(gridSize/2+e),b+(Math.floor(Math.random()*(2*orbitSeparation+1))-orbitSeparation),c);if(-1!==a){if(.45>a)for(a=0;a<gridSize;a++)for(let d=0;d<gridSize;d++)0!==image[gridSize*a+d]&&(image[gridSize*(gridSize-a-1)+gridSize-d-1]=image[gridSize*
a+d]);postMessage([image,c])}}}
function calculateOrbit(b,c,a){a=0;currentRow=b;currentCol=c;if(0!==image[gridSize*currentRow+currentCol])return-1;currentP=2*(1-currentRow/gridSize)*Math.PI;currentTheta=currentCol/gridSize*2*Math.PI;for(b=0;;){image[gridSize*currentRow+currentCol]++;b++;currentRow<gridSize/2&&a++;if(300===image[gridSize*currentRow+currentCol])break;currentP+=K*Math.sin(currentTheta);for(currentTheta+=currentP;currentP>=2*Math.PI;)currentP-=2*Math.PI;for(;currentTheta>=2*Math.PI;)currentTheta-=2*Math.PI;for(;0>currentP;)currentP+=
2*Math.PI;for(;0>currentTheta;)currentTheta+=2*Math.PI;currentRow=Math.floor((1-currentP/(2*Math.PI))*gridSize);currentCol=Math.floor(currentTheta/(2*Math.PI)*gridSize)}return a/b};
