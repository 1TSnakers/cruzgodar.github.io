"use strict";onmessage=async function(r){gridSize=r.data[0],K=r.data[1],orbitSeparation=r.data[2],await drawKickedRotator()};let gridSize=null,K=null,orbitSeparation=null,image=[],currentRow=null,currentCol=null,currentP=null,currentTheta=null;const maxRepetitions=50;function drawKickedRotator(){let r=Math.floor(gridSize/2);for(let e=1;e<gridSize/2;e+=orbitSeparation+1){image=Array(gridSize*gridSize);for(let i=0;i<gridSize;i++)for(let t=0;t<gridSize;t++)image[gridSize*i+t]=0;let n=6/7*e/(gridSize/2),o=calculateOrbit(Math.floor(gridSize/2+e),r+(Math.floor(Math.random()*(2*orbitSeparation+1))-orbitSeparation),n);if(-1!==o){if(o<.45)for(let a=0;a<gridSize;a++)for(let u=0;u<gridSize;u++)0!==image[gridSize*a+u]&&(image[gridSize*(gridSize-a-1)+gridSize-u-1]=image[gridSize*a+u]);postMessage([image,n])}}}function calculateOrbit(r,e,i){let t=0;if(0!==image[gridSize*(currentRow=r)+(currentCol=e)])return -1;currentP=(1-currentRow/gridSize)*(2*Math.PI),currentTheta=currentCol/gridSize*(2*Math.PI);let n=0;for(;image[gridSize*currentRow+currentCol]++,n++,currentRow<gridSize/2&&t++,300!==image[gridSize*currentRow+currentCol];){for(currentP+=K*Math.sin(currentTheta),currentTheta+=currentP;currentP>=2*Math.PI;)currentP-=2*Math.PI;for(;currentTheta>=2*Math.PI;)currentTheta-=2*Math.PI;for(;currentP<0;)currentP+=2*Math.PI;for(;currentTheta<0;)currentTheta+=2*Math.PI;currentRow=Math.floor((1-currentP/(2*Math.PI))*gridSize),currentCol=Math.floor(currentTheta/(2*Math.PI)*gridSize)}return t/n}