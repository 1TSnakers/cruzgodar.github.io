"use strict";let numVertices=null,numIterations=null,gridSize=null,maximumSpeed=null,polygons=[];async function drawFiniteSubdivisions(){polygons=[[]];var middleAngle=2*Math.floor(numVertices/2)*Math.PI/numVertices,topRow=gridSize/2-gridSize/2.5,middleAngle=gridSize/2-gridSize/2.5*Math.cos(middleAngle),topRow=topRow+(gridSize-middleAngle),centerRow=Math.floor(topRow/2+gridSize/2.5),centerCol=Math.floor(gridSize/2);for(let i=0;i<numVertices;i++){var angle=i/numVertices*2*Math.PI,row=Math.floor(-Math.cos(angle)*gridSize/2.5+centerRow),angle=Math.floor(Math.sin(angle)*gridSize/2.5+centerCol);polygons[0].push([row,angle])}await drawOuterPolygon();for(let i=0;i<numIterations;i++)await drawLines(calculateLines())}async function drawOuterPolygon(){if(maximumSpeed)for(let j=0;j<numVertices;j++){const rgb=HSVtoRGB((2*j+1)/(2*numVertices),1,1),color=`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;postMessage([polygons[0][j][0],polygons[0][j][1],polygons[0][(j+1)%numVertices][0],polygons[0][(j+1)%numVertices][1],color])}else for(let i=0;i<120;i++){for(let j=0;j<numVertices;j++){var rgb=HSVtoRGB((2*j+1)/(2*numVertices),1,1),rgb=`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;postMessage([polygons[0][j][0],polygons[0][j][1],polygons[0][j][0]+(i+1)/120*(polygons[0][(j+1)%numVertices][0]-polygons[0][j][0]),polygons[0][j][1]+(i+1)/120*(polygons[0][(j+1)%numVertices][1]-polygons[0][j][1]),rgb])}await new Promise(resolve=>setTimeout(resolve,8))}}function calculateLines(){var newLines=[],newPolygons=[];for(let i=0;i<polygons.length;i++){let barycenterRow=0,barycenterCol=0;for(let j=0;j<polygons[i].length;j++)barycenterRow+=polygons[i][j][0],barycenterCol+=polygons[i][j][1];barycenterRow/=polygons[i].length,barycenterCol/=polygons[i].length;for(let j=0;j<polygons[i].length;j++)newLines.push([polygons[i][j],[barycenterRow,barycenterCol]]),newPolygons.push([[barycenterRow,barycenterCol],polygons[i][j],polygons[i][(j+1)%polygons[i].length]])}return polygons=newPolygons,newLines}async function drawLines(newLines){if(!1===maximumSpeed)for(let i=0;i<120;i++){for(let j=0;j<newLines.length;j++){var rgb=HSVtoRGB(j/(newLines.length-1),1,1),rgb=`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;postMessage([newLines[j][0][0],newLines[j][0][1],newLines[j][0][0]+(i+1)/120*(newLines[j][1][0]-newLines[j][0][0])+1,newLines[j][0][1]+(i+1)/120*(newLines[j][1][1]-newLines[j][0][1]),rgb])}await new Promise(resolve=>setTimeout(resolve,8))}else for(let j=0;j<newLines.length;j++){const rgb=HSVtoRGB(j/(newLines.length-1),1,1),color=`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;postMessage([newLines[j][0][0],newLines[j][0][1],newLines[j][1][0],newLines[j][1][1],color])}}function HSVtoRGB(h,s,v){let r,g,b;var i=Math.floor(6*h),h=6*h-i,p=v*(1-s),q=v*(1-h*s),t=v*(1-(1-h)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q}return[Math.round(255*r),Math.round(255*g),Math.round(255*b)]}onmessage=e=>{numVertices=e.data[0],numIterations=e.data[1],gridSize=e.data[2],maximumSpeed=e.data[3],drawFiniteSubdivisions()};