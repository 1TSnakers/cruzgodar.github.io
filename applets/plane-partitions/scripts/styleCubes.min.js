import anime from"/scripts/anime.min.js";async function colorCubes(array,coordinates,hue){if(0!==coordinates.length){const r=[];coordinates.forEach(xyz=>{array.cubes[xyz[0]][xyz[1]][xyz[2]].material.forEach(material=>r.push(material.color))}),r.forEach(color=>color.getRGB(color));var a=this.cubeLightness+ +Math.min(this.cubeLightness,1-this.cubeLightness),e=0===a?0:2*(1-this.cubeLightness/a),e=this.wilson.utils.hsvToRgb(hue,e,a);await anime({targets:r,r:e[0]/255,g:e[1]/255,b:e[2]/255,duration:this.animationTime,delay:(element,index)=>Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad",update:()=>r.forEach(color=>color.setRGB(color.r,color.g,color.b))}).finished}}async function uncolorCubes(array,coordinates){const a=[];coordinates.forEach(xyz=>{array.cubes[xyz[0]][xyz[1]][xyz[2]].material.forEach(material=>a.push(material.color))}),a.forEach(color=>color.getHSL(color)),await anime({targets:a,s:0,duration:this.animationTime,easing:"easeOutQuad",update:()=>a.forEach(color=>color.setHSL(color.h,color.s,this.cubeLightness))}).finished}async function raiseCubes(array,coordinates,height){var a=this.in2dView?0:this.animationTime;const e=[];coordinates.forEach(xyz=>{e.push(array.cubes[xyz[0]][xyz[1]][xyz[2]].position),array.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot raise cubes from an infinite height")}),await anime({targets:e,y:height,duration:a,easing:"easeInOutQuad"}).finished}async function lowerCubes(array,coordinates){var a=this.in2dView?0:this.animationTime;const e=[];coordinates.forEach(xyz=>{e.push(array.cubes[xyz[0]][xyz[1]][xyz[2]].position),array.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot lower cubes onto an infinite height")}),await anime({targets:e,y:(element,index)=>array.numbers[coordinates[index][0]][coordinates[index][1]],duration:a,easing:"easeInOutQuad"}).finished,coordinates.forEach(xyz=>{array.cubes[xyz[0]][xyz[1]][array.numbers[xyz[0]][xyz[1]]]=array.cubes[xyz[0]][xyz[1]][xyz[2]],array.cubes[xyz[0]][xyz[1]][xyz[2]]=void 0})}async function moveCubes(sourceArray,sourceCoordinates,targetArray,targetCoordinates,updateCubeArray=!0){const a=[];if(sourceCoordinates.forEach(xyz=>{a.push(sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]].position),targetArray.cubeGroup.attach(sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]]),sourceArray.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot move cubes from an infinite height")}),await anime({targets:a,x:(element,index)=>targetCoordinates[index][1]-(targetArray.footprint-1)/2,y:(element,index)=>targetCoordinates[index][2],z:(element,index)=>targetCoordinates[index][0]-(targetArray.footprint-1)/2,duration:this.animationTime,easing:"easeInOutQuad"}).finished,updateCubeArray){const r=sourceCoordinates.map(xyz=>sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]]);sourceCoordinates.forEach(xyz=>sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]]),targetCoordinates.forEach((xyz,index)=>{targetArray.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot move cubes to an infinite height"),targetArray.cubes[xyz[0]][xyz[1]][xyz[2]]&&!sourceCoordinates.some(e=>e[0]===xyz[0]&&e[1]===xyz[1]&&e[2]===xyz[2])&&console.warn(`Moving a cube to a location that's already occupied: ${xyz}. This is probably not what you want to do.`),targetArray.cubes[xyz[0]][xyz[1]][xyz[2]]=r[index]})}}async function revealCubes(array,coordinates){if(0!==coordinates.length){const a=[];coordinates.forEach(xyz=>{array.cubes[xyz[0]][xyz[1]][xyz[2]].material.forEach(material=>a.push(material)),array.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot reveal cubes at an infinite height")}),await anime({targets:a,opacity:1,duration:this.animationTime/2,delay:(element,index)=>Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad"}).finished}}async function deleteCubes(array,coordinates,instant=!1,noAnimation=!1){const a=[];coordinates.forEach(xyz=>{array.cubes[xyz[0]][xyz[1]][xyz[2]].material.forEach(material=>a.push(material))}),await anime({targets:a,opacity:0,duration:this.animationTime/2*!noAnimation,delay:(element,index)=>!instant*Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad"}).finished,a.forEach(material=>material.dispose()),coordinates.forEach(xyz=>{array.cubeGroup.remove(array.cubes[xyz[0]][xyz[1]][xyz[2]]),array.cubes[xyz[0]][xyz[1]][xyz[2]]=void 0})}async function deleteFloor(array,coordinates){const a=[];coordinates.forEach(xyz=>{array.floor[xyz[0]][xyz[1]].material.forEach(material=>a.push(material))}),await anime({targets:a,opacity:0,duration:this.animationTime/2,easing:"easeOutQuad"}).finished,a.forEach(material=>material.dispose()),coordinates.forEach(xyz=>{array.cubeGroup.remove(array.floor[xyz[0]][xyz[1]]),array.cubes[xyz[0]][xyz[1]]=void 0})}export{colorCubes,uncolorCubes,raiseCubes,lowerCubes,moveCubes,revealCubes,deleteCubes,deleteFloor};