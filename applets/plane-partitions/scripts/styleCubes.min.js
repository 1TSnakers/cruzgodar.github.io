import anime from"/scripts/anime.min.js";import{hsvToRgb}from"/scripts/applets/applet.min.js";async function colorCubes(array,coordinates,hue,saturation=1){if(0!==coordinates.length){const o=[];for(const t of coordinates)for(const r of array.cubes[t[0]][t[1]][t[2]].material)o.push(r.color);for(const n of o)n.getRGB(n);var e=this.cubeLightness+ +Math.min(this.cubeLightness,1-this.cubeLightness),a=0===e?0:2*(1-this.cubeLightness/e),a=hsvToRgb(hue,saturation*a,e);await anime({targets:o,r:a[0]/255,g:a[1]/255,b:a[2]/255,duration:this.animationTime,delay:(element,index)=>Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad",update:()=>{for(const e of o)e.setRGB(e.r,e.g,e.b);this.needNewFrame=!0},complete:()=>{for(const e of o)e.setRGB(e.r,e.g,e.b);this.needNewFrame=!0}}).finished}}async function uncolorCubes(array,coordinates){const a=[];for(const e of coordinates)for(const o of array.cubes[e[0]][e[1]][e[2]].material)a.push(o.color);for(const t of a)t.getHSL(t);await anime({targets:a,s:0,duration:this.animationTime,easing:"easeOutQuad",update:()=>{for(const e of a)e.setHSL(e.h,e.s,this.cubeLightness);this.needNewFrame=!0},complete:()=>{for(const e of a)e.setHSL(e.h,e.s,this.cubeLightness);this.needNewFrame=!0}}).finished}async function colorWalls(array,hue,saturation=1){const a=[];for(const t of array.floor.concat(array.leftWall).concat(array.rightWall))for(const r of t)for(const n of r.material)a.push(n.color);for(const i of a)i.getRGB(i);var e=this.cubeLightness+ +Math.min(this.cubeLightness,1-this.cubeLightness),o=0===e?0:2*(1-this.cubeLightness/e),o=hsvToRgb(hue,saturation*o,e);await anime({targets:a,r:o[0]/255,g:o[1]/255,b:o[2]/255,duration:this.animationTime,delay:(element,index)=>Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad",update:()=>{for(const e of a)e.setRGB(e.r,e.g,e.b);this.needNewFrame=!0},complete:()=>{for(const e of a)e.setRGB(e.r,e.g,e.b);this.needNewFrame=!0}}).finished}async function raiseCubes(array,coordinates,height){var e=this.in2dView?0:this.animationTime,a=[];for(const o of coordinates)a.push(array.cubes[o[0]][o[1]][o[2]].position),array.numbers[o[0]][o[1]]===1/0&&console.error("Cannot raise cubes from an infinite height");await anime({targets:a,y:height,duration:e,easing:"easeInOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished}async function lowerCubes(array,coordinates){var e=this.in2dView?0:this.animationTime,a=[];for(const o of coordinates)a.push(array.cubes[o[0]][o[1]][o[2]].position),array.numbers[o[0]][o[1]]===1/0&&console.error("Cannot lower cubes onto an infinite height");await anime({targets:a,y:(element,index)=>array.numbers[coordinates[index][0]][coordinates[index][1]],duration:e,easing:"easeInOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished;for(const t of coordinates)array.cubes[t[0]][t[1]][array.numbers[t[0]][t[1]]]=array.cubes[t[0]][t[1]][t[2]],array.cubes[t[0]][t[1]][t[2]]=void 0}async function moveCubes(sourceArray,sourceCoordinates,targetArray,targetCoordinates,updateCubeArray=!0){var e=[];for(const xyz of sourceCoordinates)e.push(sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]].position),targetArray.cubeGroup.attach(sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]]),sourceArray.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot move cubes from an infinite height");if(await anime({targets:e,x:(_,index)=>targetCoordinates[index][1]-(targetArray.footprint-1)/2,y:(_,index)=>targetCoordinates[index][2],z:(_,index)=>targetCoordinates[index][0]-(targetArray.footprint-1)/2,duration:this.animationTime,easing:"easeInOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished,updateCubeArray){var a=sourceCoordinates.map(xyz=>sourceArray.cubes[xyz[0]][xyz[1]][xyz[2]]);for(const[index,xyz]of targetCoordinates.entries())targetArray.numbers[xyz[0]][xyz[1]]===1/0&&console.error("Cannot move cubes to an infinite height"),targetArray.cubes[xyz[0]][xyz[1]][xyz[2]]&&!sourceCoordinates.some(e=>e[0]===xyz[0]&&e[1]===xyz[1]&&e[2]===xyz[2])&&console.warn(`Moving a cube to a location that's already occupied: ${xyz}. This is probably not what you want to do.`),targetArray.cubes[xyz[0]][xyz[1]][xyz[2]]=a[index]}}async function revealCubes(array,coordinates){if(0!==coordinates.length){var e=[];for(const a of coordinates){for(const o of array.cubes[a[0]][a[1]][a[2]].material)e.push(o);array.numbers[a[0]][a[1]]===1/0&&console.error("Cannot reveal cubes at an infinite height")}await anime({targets:e,opacity:1,duration:this.animationTime/2,delay:(element,index)=>Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished}}async function deleteCubes(array,coordinates,allAtOnce=!1,noAnimation=!1){var e=[];for(const a of coordinates)for(const o of array.cubes[a[0]][a[1]][a[2]].material)e.push(o);await anime({targets:e,opacity:0,duration:this.animationTime/2*!noAnimation,delay:(element,index)=>!allAtOnce*Math.floor(index/6)*this.animationTime/10,easing:"easeOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished;for(const t of e)t.dispose();for(const r of coordinates)array.cubeGroup.remove(array.cubes[r[0]][r[1]][r[2]]),array.cubes[r[0]][r[1]][r[2]]=void 0}async function deleteFloor(array,coordinates){var e=[];for(const a of coordinates)for(const o of array.floor[a[0]][a[1]].material)e.push(o);await anime({targets:e,opacity:0,duration:this.animationTime/2,easing:"easeOutQuad",update:()=>this.needNewFrame=!0,complete:()=>this.needNewFrame=!0}).finished;for(const t of e)t.dispose();for(const r of coordinates)array.cubeGroup.remove(array.floor[r[0]][r[1]]),array.cubes[r[0]][r[1]]=void 0}export{colorCubes,uncolorCubes,colorWalls,raiseCubes,lowerCubes,moveCubes,revealCubes,deleteCubes,deleteFloor};