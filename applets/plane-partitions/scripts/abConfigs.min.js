import{verifyPp}from"./parseAndVerify.min.js";import{clamp}from"/scripts/src/utils.min.js";const absoluteMinAEntry=-5;function isValidABConfig({lambda,mu,nu,A,B}){if(!verifyPp(A)||!verifyPp(B))return!1;for(;lambda.length<nu[0];)lambda.push(0);for(;mu.length<nu.length;)mu.push(0);var e=[];let a=0,t=0;for(;A[a][0]===1/0;)a++;for(;A[0][t]===1/0;)t++;if(A[a-1][t-1]!==1/0)throw new Error("Infinite part of A is not rectangular!");for(let p=0;p<A.length;p++)for(let n=0;n<A[p].length;n++){const C=p-a,M=n-t;if(!(C<0&&M<0)){const x=0<=C&&C<nu.length&&0<=M&&M<nu[C];var r=0<=M?lambda[M]:1/0,l=0<=C?mu[C]:1/0;if(A[p][n]>Math.min(r,l))return!1;if(0<=C&&0<=M){if(B[C][M]<0)return!1;if(x&&B[C][M]>Math.max(r,l))return!1;if(!x&&B[C][M]>Math.min(r,l))return!1;if(!x&&A[p][n]!==-1/0)return!1}else if(A[p][n]<0)return!1;var[i,o]=C<0?[lambda[M],0]:M<0?[mu[C],0]:x?[Math.min(lambda[M],mu[C]),Math.max(lambda[M],mu[C])]:[0,Math.min(lambda[M],mu[C])];for(let a=x?absoluteMinAEntry:0;a<Math.max(i,o);a++){var[u,m]=(()=>{if(C<0)return[1,1];if(M<0)return[1,2];if(a<0)return[1,3];if(x&&a<Math.min(lambda[M],mu[C]))return[3,0];if(!x)return[2,3];if(a>=lambda[M])return[2,1];if(a>=mu[C])return[2,2];throw new Error("Region/label code is broken")})(),g=A[p][n]<=a&&a<i,f=0<=C&&0<=M&&B[C][M]<=a&&a<o,s=0<=C&&0<=M&&a<o&&0<=a;(1===u&&g||2===u&&!f&&s||3===u&&(g&&!f||!g&&f))&&e.push([C,M,a,m,u])}}}for(var h=[],b=structuredClone(e),d=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]];0!==b.length;){let a=[],n=[b[0]];for(b.splice(0,1);0!==n.length;){var c=[];for(const w of n)for(const j of d){var v=boxIsInArray([w[0]+j[0],w[1]+j[1],w[2]+j[2]],b);-1!==v&&(c.push(b[v]),b.splice(v,1))}a=a.concat(n),n=c}h.push(a)}for(let E=0;E<h.length;E++){var n=new Set(h[E].map(box=>box[3]));if(n.delete(0),1<n.size)return[!1,void 0];if(0!==n.size){var[y]=n;for(const I of h[E])e[boxIsInArray(I,e)][3]=y}}return[!0,e,h]}function boxIsInArray(box,array){for(let n=0;n<array.length;n++){var a=array[n];if(a[0]===box[0]&&a[1]===box[1]&&a[2]===box[2])return n}return-1}function getAsciiLabel(box,boxes){var a=boxIsInArray(box,boxes);return-1===a?"∅":0===(a=boxes[a][3])?"*":""+a}function getMinimalABConfig({lambda,mu,nu,negativeWidth=2}){for(;lambda.length<nu[0];)lambda.push(0);for(;mu.length<nu.length;)mu.push(0);var n=new Array(negativeWidth+mu.length),e=new Array(mu.length);for(let l=0;l<n.length;l++){n[l]=new Array(negativeWidth+lambda.length),l>=negativeWidth&&(e[l-negativeWidth]=new Array(lambda.length));for(let a=0;a<n[l].length;a++){const i=l-negativeWidth,o=a-negativeWidth;if(i<0&&o<0)n[l][a]=1/0;else{const u=0<=i&&i<nu.length&&0<=o&&o<nu[i];var[t,r]=i<0?[lambda[o],0]:o<0?[mu[i],0]:u?[Math.min(lambda[o],mu[i]),Math.max(lambda[o],mu[i])]:[-1/0,Math.min(lambda[o],mu[i])];n[l][a]=t,0<=i&&0<=o&&(e[i][o]=r)}}}return[n,e]}function iterateThroughEntries({lambda,mu,nu,A,B,i,j}){for(;lambda.length<nu[0];)lambda.push(0);for(;mu.length<nu.length;)mu.push(0);let a=0,n=0;for(;A[a][0]===1/0;)a++;for(;A[0][n]===1/0;)n++;var r=i-a,l=j-n;if(!(r<0&&l<0)){var e=0<=r&&r<nu.length&&0<=l&&l<nu[r],o=0<=r&&0<=l&&!e?-1/0:Math.min(0===i?lambda[l]:A[i-1][j],0===j?mu[r]:A[i][j-1]),u=Math.max(Math.max(i===A.length-1?-1/0:A[i+1][j],j===A[0].length-1?-1/0:A[i][j+1]),e?absoluteMinAEntry:0),m=0<=r&&0<=l?Math.min(0==r?Math.max(lambda[l],mu[r]):B[r-1][l],0==l?Math.max(lambda[l],mu[r]):B[r][l-1]):1/0,g=0<=r&&0<=l?Math.max(r==B.length-1?0:B[1+r][l],l==B[0].length-1?0:B[r][1+l]):1/0,f=structuredClone(A),s=structuredClone(B);let t="";if(o===-1/0)for(let a=m;a>=g;a--){s[r][l]=a;var h=isValidABConfig({lambda:lambda,mu:mu,nu:nu,A:f,B:s});if(h[0]){let a=getAsciiLabel([r,l,f[i][j]],h[1]);"∅"===a&&0<=r&&0<=l&&(a=getAsciiLabel([r,l,s[r][l]],h[1])),t=t+a+" "}else t+="  "}else if(m===1/0)for(let n=o;n>=u;n--){f[i][j]=n;var b=isValidABConfig({lambda:lambda,mu:mu,nu:nu,A:f,B:s});if(b[0]){let a=getAsciiLabel([r,l,f[i][j]],b[1]);"∅"===a&&0<=r&&0<=l&&(a=getAsciiLabel([r,l,s[r][l]],b[1])),t=t+(n===absoluteMinAEntry?"v":a)+"\n"}else t+="\n"}else for(let e=o;e>=u;e--){for(let a=m;a>=g;a--){f[i][j]=e,s[r][l]=a;var d=isValidABConfig({lambda:lambda,mu:mu,nu:nu,A:f,B:s});if(d[0]){let a=getAsciiLabel([r,l,f[i][j]],d[1]);"∅"===a&&0<=r&&0<=l&&(a=getAsciiLabel([r,l,s[r][l]],d[1])),t=t+(e===absoluteMinAEntry?"v":a)+" "}else t+="  "}t+="\n"}return t}}function printABConfig({A,B}){let n="",e=0,a=0;for(;A[e][0]===1/0;)e++;for(;A[0][a]===1/0;)a++;let t=2;for(let u=0;u<A[0].length;u++)for(let a=0;a<A.length;a++){var r=Math.abs(A[a][u])===1/0?1:(""+A[a][u]).length;t=Math.max(t,r+1)}for(let m=0;m<A.length;m++){var l=m-e;for(let a=0;a<A[m].length;a++){var i=A[m][a]===1/0?"^":A[m][a]===-1/0?"v":""+A[m][a],o=t-i.length;n+=" ".repeat(o-1)+i+" "}if(0<=l){n+="  ";for(let a=0;a<B[l].length;a++)n+=B[l][a]+" "}n+="\n"}console.log(n)}function testAllEntriesOfABConfig({lambda,mu,nu,A,B,onlyUnboundedBelow=!1}){let n=0,e=0;for(;A[n][0]===1/0;)n++;for(;A[0][e]===1/0;)e++;for(let u=0;u<A.length;u++)for(let a=0;a<A.length;a++){var t,r,l,i,o;u<n&&a<e||(t=this.iterateThroughEntries({A:A,B:B,lambda:lambda,mu:mu,nu:nu,i:u,j:a}),onlyUnboundedBelow||(console.log(u,a),console.log(t)),r=u-n,l=a-e,0<=r&&0<=l&&r<nu.length&&l==nu[r]-1&&(nu[r]--,i=structuredClone(A),o=structuredClone(B),i[u][a]=-1/0,o[r][l]=Math.min(lambda[l],mu[r]),onlyUnboundedBelow&&(console.log(u,a),console.log(t)),console.log(this.iterateThroughEntries({A:i,B:o,lambda:lambda,mu:mu,nu:nu,i:u,j:a})),nu[r]++))}}function getArrayVersionOfABConfig({lambda,mu,nu,A,B}){let n=0,e=0;for(;A[n][0]===1/0;)n++;for(;A[0][e]===1/0;)e++;var t=new Array(16),r=new Array(16);for(let o=0;o<16;o++){t[o]=new Array(16),r[o]=new Array(16);for(let a=0;a<16;a++){var l=o-8+n,i=a-8+e;if(0<=l&&l<A.length&&0<=i&&i<A[l].length)t[o][a]=clamp(A[l][i]+8,0,16);else{const u=a-8<0?1/0:a-8>=lambda.length?0:lambda[a-8],m=o-8<0?1/0:o-8>=mu.length?0:mu[o-8];l=0<=o-8&&o-8<nu.length&&a-8<nu[o-8]||o-8<0||a-8<0?Math.min(u,m):-1/0;t[o][a]=clamp(l+8,0,16)}16===t[o][a]&&(t[o][a]=1/0),o<B.length&&a<B[o].length?r[o][a]=B[o][a]:r[o][a]=0}}return[t,r]}function getABConfigRegions({bigA,bigB,lambda,mu,nu}){var e=[],t=[],r=[],l=[];for(let s=0;s<bigA.length;s++)for(let n=0;n<bigA[s].length;n++)if(bigA[s][n]!==1/0){var i=s-8,o=n-8,u=0<=i&&i<nu.length&&0<=o&&o<nu[i],m=bigA[s][n],g=0<=i&&0<=o?bigB[i][o]+8:0;for(let a=0;a<Math.max(m,g);a++){var f=a-8;switch(u+(0<=o&&o<lambda.length&&0<=f&&f<lambda[o])+(0<=i&&i<mu.length&&0<=f&&f<mu[i])){case 1:e.push([s,n,a]);break;case 2:t.push([i,o,f]);break;case 3:r.push([s,n,a]),l.push([i,o,f])}}}return[e,t,r,l]}async function colorABConfigRegions({bigA,bigB,lambda,mu,nu,arrayA,arrayB}){var a=getABConfigRegions({bigA:bigA,bigB:bigB,lambda:lambda,mu:mu,nu:nu});await this.colorCubes(arrayA,a[0],.05,.5),await this.colorCubes(arrayA,a[2],.7,.6),await this.colorCubes(arrayB,a[1],.15,.6),await this.colorCubes(arrayB,a[3],.7,.6)}async function colorABConfigs({bigA,bigB,lambda,mu,nu,arrayB}){var a=getABConfigRegions({bigA:bigA,bigB:bigB,lambda:lambda,mu:mu,nu:nu});await this.colorWalls(arrayB,.69,.75),await this.colorCubes(arrayB,a[1],.69,.75),await this.colorCubes(arrayB,a[3],.69,.75)}export{isValidABConfig,getMinimalABConfig,iterateThroughEntries,printABConfig,testAllEntriesOfABConfig,getArrayVersionOfABConfig,colorABConfigRegions,colorABConfigs};