import{generateRandomPlanePartition,generateRandomTableau}from"./generateRandomData.min.js";import{parseArray,verifyPp,verifySsyt}from"./parseAndVerify.min.js";import{sleep}from"/scripts/src/utils.min.js";async function runExample(index){if(1===index||2===index){for(;1<this.arrays.length;)await this.removeArray(1),await sleep(this.animationTime/2);var i;0===this.arrays.length?(i=parseArray(generateRandomPlanePartition()),await this.addNewArray({index:this.arrays.length,numbers:i})):verifyPp(this.arrays[0].numbers)||(await this.removeArray(0),await sleep(this.animationTime/2),i=parseArray(generateRandomPlanePartition()),await this.addNewArray({index:this.arrays.length,numbers:i})),1===index?(await this.runAlgorithm("hillmanGrassl",0),await sleep(3*this.animationTime),await this.runAlgorithm("hillmanGrasslInverse",0)):(await this.runAlgorithm("pak",0),await sleep(3*this.animationTime),await this.showHexView(),await sleep(this.animationTime),await this.runAlgorithm("sulzgruberInverse",0))}else if(3===index){for(;0<this.arrays.length;)await this.removeArray(0),await sleep(this.animationTime/2);await this.addNewArray({index:this.arrays.length,numbers:generateRandomTableau()}),await this.show2dView(),await sleep(this.animationTime),await this.runAlgorithm("rskInverse",0),await sleep(3*this.animationTime),await this.runAlgorithm("rsk",0)}}async function runAlgorithm(name,index,subAlgorithm=!1){if(subAlgorithm||!this.currentlyRunningAlgorithm){this.currentlyRunningAlgorithm=!0;var e=this.algorithmData[name],t=e.inputType.length;if(index>this.arrays.length-1||index<0)console.log(`No array at index ${index}!`),this.currentlyRunningAlgorithm=!1;else if(1<t&&index>this.arrays.length-t)console.log(`No array at index ${index+t-1}! (This algorithm needs ${t} arrays)`),this.currentlyRunningAlgorithm=!1;else{for(let i=0;i<t;i++){var a=e.inputType[i];if("pp"===a&&!verifyPp(this.arrays[index+i].numbers))return console.log(`Array at index ${index+i} is not a plane partition!`),void(this.currentlyRunningAlgorithm=!1);if("ssyt"===a&&!verifySsyt(this.arrays[index+i].numbers))return console.log(`Array at index ${index+i} is not an SSYT!`),void(this.currentlyRunningAlgorithm=!1)}if(1<t&&void 0!==e.sameShape&&e.sameShape){var n=new Array(t);let e=0;for(let i=0;i<t;i++)e=Math.max(e,this.arrays[index+i].numbers.length);for(let a=0;a<t;a++){n[a]=new Array(e);for(let i=0;i<e;i++)n[a][i]=0;for(let r=0;r<this.arrays[index+a].numbers.length;r++){let i=0;for(;i<this.arrays[index+a].numbers[r].length&&0!==this.arrays[index+a].numbers[r][i];)i++;n[a][r]=i}}for(let r=1;r<t;r++)for(let i=0;i<e;i++)if(n[r][i]!==n[0][i])return this.displayError("Arrays are not the same shape!"),void(this.currentlyRunningAlgorithm=!1)}for(let r=0;r<t;r++){var s=[],h=this.arrays[index+r].numbers;for(let e=0;e<h.length;e++)for(let r=0;r<h.length;r++)if(h[e][r]!==1/0)for(let i=0;i<h[e][r];i++)s.push([e,r,i]);this.uncolorCubes(this.arrays[index+r],s)}await e.method.bind(this)(index),this.subAlgorithm||(this.currentlyRunningAlgorithm=!1)}}}export{runExample,runAlgorithm};