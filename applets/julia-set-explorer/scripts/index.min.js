!function(){"use strict";let e=`
  precision highp float;
  
  varying vec2 uv;
  
  uniform int juliaMode;
  uniform int doublePrecision;
  
  uniform float aspectRatio;
  
  uniform vec2 worldCenterX;
  uniform vec2 worldCenterY;
  uniform float worldSize;
  
  uniform float a;
  uniform float b;
  uniform int numIterations;
  uniform float brightnessScale;
  
  
  
  float timesFrc(float a, float b)
  {
   return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);
  }

  float plusFrc(float a, float b)
  {
   return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);
  }

  float minusFrc(float a, float b)
  {
   return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);
  }

  // Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)
  // Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/
  // Add: res = dsAdd(a, b) => res = a + b
  vec2 add (vec2 dsa, vec2 dsb)
  {
   vec2 dsc;
   float t1, t2, e;
   t1 = plusFrc(dsa.x, dsb.x);
   e = minusFrc(t1, dsa.x);
   t2 = plusFrc(plusFrc(plusFrc(minusFrc(dsb.x, e), minusFrc(dsa.x, minusFrc(t1, e))), dsa.y), dsb.y);
   dsc.x = plusFrc(t1, t2);
   dsc.y = minusFrc(t2, minusFrc(dsc.x, t1));
   return dsc;
  }

  // Subtract: res = dsSub(a, b) => res = a - b
  vec2 sub (vec2 dsa, vec2 dsb)
  {
   vec2 dsc;
   float e, t1, t2;
   t1 = minusFrc(dsa.x, dsb.x);
   e = minusFrc(t1, dsa.x);
   t2 = minusFrc(plusFrc(plusFrc(minusFrc(minusFrc(0.0, dsb.x), e), minusFrc(dsa.x, minusFrc(t1, e))), dsa.y), dsb.y);
   dsc.x = plusFrc(t1, t2);
   dsc.y = minusFrc(t2, minusFrc(dsc.x, t1));
   return dsc;
  }

  // Compare: res = -1 if a < b // = 0 if a == b // = 1 if a > b
  float cmp(vec2 dsa, vec2 dsb)
  {
   if (dsa.x < dsb.x)
   {
    return -1.;
   }
   
   if (dsa.x > dsb.x)
   {
    return 1.;
   }
   
   if (dsa.y < dsb.y)
   {
    return -1.;
   }
   
   if (dsa.y > dsb.y)
   {
    return 1.;
   }
   
   return 0.;
  }

  // Multiply: res = dsMul(a, b) => res = a * b

  vec2 mul (vec2 dsa, vec2 dsb)
  {
   vec2 dsc;
   float c11, c21, c2, e, t1, t2;
   float a1, a2, b1, b2, cona, conb, split = 8193.;
   cona = timesFrc(dsa.x, split);
   conb = timesFrc(dsb.x, split);
   a1 = minusFrc(cona, minusFrc(cona, dsa.x));
   b1 = minusFrc(conb, minusFrc(conb, dsb.x));
   a2 = minusFrc(dsa.x, a1);
   b2 = minusFrc(dsb.x, b1);
   c11 = timesFrc(dsa.x, dsb.x);
   c21 = plusFrc(timesFrc(a2, b2), plusFrc(timesFrc(a2, b1), plusFrc(timesFrc(a1, b2), minusFrc(timesFrc(a1, b1), c11))));
   c2 = plusFrc(timesFrc(dsa.x, dsb.y), timesFrc(dsa.y, dsb.x));
   t1 = plusFrc(c11, c2);
   e = minusFrc(t1, c11);
   t2 = plusFrc(plusFrc(timesFrc(dsa.y, dsb.y), plusFrc(minusFrc(c2, e), minusFrc(c11, minusFrc(t1, e)))), c21);
   dsc.x = plusFrc(t1, t2);
   dsc.y = minusFrc(t2, minusFrc(dsc.x, t1));
   return dsc;
  }

  // create double-single number from float
  vec2 set(float a)
  {
   return vec2(a, 0.0);
  }

  float rand(vec2 co)
  {
   // implementation found at: lumina.sourceforge.net/Tutorials/Noise.html
   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
  }

  vec2 complexMul(vec2 a, vec2 b)
  {
   return vec2(a.x*b.x - a.y*b.y,a.x*b.y + a.y * b.x);
  }

  // double complex multiplication
  vec4 dcMul(vec4 a, vec4 b)
  {
   return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));
  }

  vec4 dcAdd(vec4 a, vec4 b)
  {
   return vec4(add(a.xy,b.xy),add(a.zw,b.zw));
  }

  // Length of double complex
  vec2 dcLength(vec4 a)
  {
   return add(mul(a.xy,a.xy),mul(a.zw,a.zw));
  }

  vec4 dcSet(vec2 a)
  {
   return vec4(a.x,0.,a.y,0.);
  }

  vec4 dcSet(vec2 a, vec2 ad)
  {
   return vec4(a.x, ad.x,a.y,ad.y);
  }

  // Multiply double-complex with double
  vec4 dcMul(vec4 a, vec2 b)
  {
   return vec4(mul(a.xy,b),mul(a.wz,b));
  }
  
  
  
  void main(void)
  {
   if (doublePrecision == 0)
   {
    vec2 z;
    
    if (aspectRatio >= 1.0)
    {
     z = vec2(uv.x * aspectRatio * worldSize + worldCenterX.x, uv.y * worldSize + worldCenterY.x);
    }
    
    else
    {
     z = vec2(uv.x * worldSize + worldCenterX.x, uv.y / aspectRatio * worldSize + worldCenterY.x);
    }
    
    vec3 color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
    float brightness = exp(-length(z));
    
    
    
    if (juliaMode == 0)
    {
     vec2 c = z;
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       return;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      
      brightness += exp(-length(z));
     }
     
     
     gl_FragColor = vec4(brightness / brightnessScale * color, 1.0);
    }
    
    
    
    else if (juliaMode == 1)
    {
     vec2 c = vec2(a, b);
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       return;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      
      brightness += exp(-length(z));
     }
     
     
     gl_FragColor = vec4(brightness / brightnessScale * color, 1.0);
    }
    
    
    
    else
    {
     vec2 c = z;
     
     bool broken = false;
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       
       broken = true;
       
       break;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      
      brightness += exp(-length(z));
     }
     
     
     
     if (!broken)
     {
      gl_FragColor = vec4(.5 * brightness / brightnessScale * color, 1.0);
     }
     
     
     
     z = vec2(uv.x * aspectRatio * 2.0, uv.y * 2.0);
     color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
     brightness = exp(-length(z));
     
     broken = false;
     
     c = vec2(a, b);
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor.xyz /= 4.0;
       
       broken = true;
       
       break;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
      
      brightness += exp(-length(z));
     }
     
     if (!broken)
     {
      gl_FragColor += vec4(brightness / brightnessScale * color, 0.0);
     }
    }
   }
   
   
   
   else
   {
    vec4 z;
    
    if (aspectRatio >= 1.0)
    {
     z = dcAdd(dcMul(vec4(uv.x * aspectRatio, 0.0, uv.y, 0.0), vec2(worldSize, 0.0)), vec4(worldCenterX, worldCenterY));
    }
    
    else
    {
     z = dcAdd(dcMul(vec4(uv.x, 0.0, uv.y / aspectRatio, 0.0), vec2(worldSize, 0.0)), vec4(worldCenterX, worldCenterY));
    }
    
    vec3 color = normalize(vec3(abs(z.x + z.z) / 2.0, abs(z.x) / 2.0, abs(z.z) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
    float brightness = exp(-length(z));
    
    
    
    if (juliaMode == 0)
    {
     vec4 c = z;
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       return;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = dcAdd(dcMul(z, z), c);
      
      brightness += exp(-length(z));
     }
     
     
     gl_FragColor = vec4(brightness / brightnessScale * color, 1.0);
    }
    
    else if (juliaMode == 1)
    {
     vec4 c = vec4(a, 0.0, b, 0.0);
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       return;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = dcAdd(dcMul(z, z), c);
      
      brightness += exp(-length(z));
     }
     
     
     gl_FragColor = vec4(brightness / brightnessScale * color, 1.0);
    }
    
    else
    {
     vec4 c = z;
     
     bool broken = false;
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
       
       broken = true;
       
       break;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = dcAdd(dcMul(z, z), c);
      
      brightness += exp(-length(z));
     }
     
     
     
     if (!broken)
     {
      gl_FragColor = vec4(.5 * brightness / brightnessScale * color, 1.0);
     }
     
     
     
     z = c;
     color = normalize(vec3(abs(z.x + z.z) / 2.0, abs(z.x) / 2.0, abs(z.z) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
     brightness = exp(-length(z));
     
     broken = false;
     
     c = vec4(a, 0.0, b, 0.0);
     
     for (int iteration = 0; iteration < 3001; iteration++)
     {
      if (iteration == numIterations)
      {
       gl_FragColor.xyz /= 4.0;
       
       broken = true;
       
       break;
      }
      
      if (length(z) >= 4.0)
      {
       break;
      }
      
      z = dcAdd(dcMul(z, z), c);
      
      brightness += exp(-length(z));
     }
     
     if (!broken)
     {
      gl_FragColor += vec4(brightness / brightnessScale * color, 0.0);
     }
    }
   } 
  }
 `,r=new Wilson(Page.element.querySelector("#output-canvas"),{renderer:"gpu",shader:e,canvasWidth:1e3,canvasHeight:1e3,worldWidth:4,worldHeight:4,worldCenterX:-.75,worldCenterY:0,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:M,mousedownCallback:C,touchstartCallback:C,mousemoveCallback:function e(r,t,i,n,l){2===o&&"mousemove"===l.type&&(s=r,u=t,window.requestAnimationFrame(q))},mousedragCallback:k,touchmoveCallback:k,mouseupCallback:S,touchendCallback:S,wheelCallback:function e(r,t,o,i){$=r,m=t,.3>Math.abs(o/100)?(l+=o/100,l=Math.min(l,1)):v+=.05*Math.sign(o),A()},pinchCallback:function e(t,n,a,c){2!==o&&(i>=1?(l-=a/r.worldWidth*10,f=-a/r.worldWidth*10):(l-=a/r.worldHeight*10,f=-a/r.worldHeight*10),l=Math.min(l,1),$=t,m=n,A())}});r.render.initUniforms(["juliaMode","doublePrecision","aspectRatio","worldCenterX","worldCenterY","worldSize","a","b","numIterations","brightnessScale"]),r.gl.uniform1i(r.uniforms.doublePrecision,0);let t=new Wilson(Page.element.querySelector("#hidden-canvas"),{renderer:"gpu",shader:e,canvasWidth:100,canvasHeight:100});t.render.initUniforms(["juliaMode","doublePrecision","aspectRatio","worldCenterX","worldCenterY","worldSize","a","b","numIterations","brightnessScale"]),t.gl.uniform1i(t.uniforms.doublePrecision,0);let o=0,i=1,n=100,l=0,a=!1,c=[],s=0,u=1,d=1e3,$=0,m=0,b=0,_=0,f=0,g=0,h=0,v=0,z=-1,w=Page.element.querySelector("#resolution-input");w.addEventListener("input",()=>{d=parseInt(w.value||1e3),r.changeCanvasSize(d,d),window.requestAnimationFrame(q)});let x=Page.element.querySelector("#force-floats-checkbox");x.addEventListener("input",()=>{if(x.checked){try{F.checked=!1}catch(e){}p=!1}x.checked&&a?(a=!1,t.gl.uniform1i(t.uniforms.doublePrecision,0),r.gl.uniform1i(r.uniforms.doublePrecision,0),r.canvas.style.borderColor="rgb(127, 127, 127)",window.requestAnimationFrame(q)):x.checked||a||!(l<-16)||(a=!0,t.gl.uniform1i(t.uniforms.doublePrecision,1),r.gl.uniform1i(r.uniforms.doublePrecision,1),r.canvas.style.borderColor="rgb(127, 0, 0)",window.requestAnimationFrame(q))});let p=!1,F=Page.element.querySelector("#force-doubles-checkbox");DEBUG?F.addEventListener("input",()=>{F.checked&&(x.checked=!1),F.checked&&!a?(a=!0,t.gl.uniform1i(t.uniforms.doublePrecision,1),r.gl.uniform1i(r.uniforms.doublePrecision,1),r.canvas.style.borderColor="rgb(127, 0, 0)",window.requestAnimationFrame(q)):!F.checked&&a&&l>-16&&(a=!1,t.gl.uniform1i(t.uniforms.doublePrecision,0),r.gl.uniform1i(r.uniforms.doublePrecision,0),r.canvas.style.borderColor="rgb(127, 127, 127)",window.requestAnimationFrame(q)),p=F.checked}):Page.element.querySelectorAll(".checkbox-row")[1].remove();Page.element.querySelector("#download-button").addEventListener("click",()=>{r.downloadFrame("a-julia-set.png")});let y=Page.element.querySelector("#switch-julia-mode-button");function C(e,t,i){g=0,h=0,v=0,b=0,_=0,f=0,2===o&&"mousedown"===i.type&&(o=1,r.worldCenterX=0,r.worldCenterY=0,r.worldWidth=4,r.worldHeight=4,l=0,c=[],Page.Animate.changeOpacity(y,1,Site.opacityAnimationTime),window.requestAnimationFrame(q))}function k(e,t,i,n,l){2===o&&"touchmove"===l.type?(s=e,u=t):(r.worldCenterX-=i,r.worldCenterY-=n,b=-i/r.worldWidth,_=-n/r.worldHeight,r.worldCenterX=Math.min(Math.max(r.worldCenterX,-2),2),r.worldCenterY=Math.min(Math.max(r.worldCenterY,-2),2)),window.requestAnimationFrame(q)}function S(e,t,i){2===o&&"touchend"===i.type?(o=1,r.worldCenterX=0,r.worldCenterY=0,r.worldWidth=4,r.worldHeight=4,l=0,c=[],Page.Animate.changeOpacity(y,1,Site.opacityAnimationTime),window.requestAnimationFrame(q)):(Math.sqrt(b*b+_*_)>=.0025&&(g=b,h=_),Math.abs(f)>=.01&&(v=f)),window.requestAnimationFrame(q)}function A(){if(i>=1){let e=r.input.getZoomedWorldCenter($,m,4*Math.pow(2,l)*i,4*Math.pow(2,l));r.worldWidth=4*Math.pow(2,l)*i,r.worldHeight=4*Math.pow(2,l),r.worldCenterX=e[0],r.worldCenterY=e[1]}else{let o=r.input.getZoomedWorldCenter($,m,4*Math.pow(2,l),4*Math.pow(2,l)/i);r.worldWidth=4*Math.pow(2,l),r.worldHeight=4*Math.pow(2,l)/i,r.worldCenterX=o[0],r.worldCenterY=o[1]}n=-(30*l)+200,a||!(l<-16)||x.checked?a&&l>-16&&!p&&(a=!1,t.gl.uniform1i(t.uniforms.doublePrecision,0),r.gl.uniform1i(r.uniforms.doublePrecision,0),r.canvas.style.borderColor="rgb(127, 127, 127)"):(a=!0,t.gl.uniform1i(t.uniforms.doublePrecision,1),r.gl.uniform1i(r.uniforms.doublePrecision,1),r.canvas.style.borderColor="rgb(127, 0, 0)"),window.requestAnimationFrame(q)}function q(e){let a=e-z;if(z=e,0===a)return;let d=P(r.worldCenterX),w=P(r.worldCenterY);t.gl.uniform1i(t.uniforms.juliaMode,o),t.gl.uniform2fv(t.uniforms.worldCenterX,d),t.gl.uniform2fv(t.uniforms.worldCenterY,w),t.gl.uniform1f(t.uniforms.worldSize,Math.min(r.worldHeight,r.worldWidth)/2),t.gl.uniform1i(t.uniforms.numIterations,n),t.gl.uniform1f(t.uniforms.a,s),t.gl.uniform1f(t.uniforms.b,u),t.gl.uniform1f(t.uniforms.brightnessScale,20*(Math.abs(l)+1)),t.render.drawFrame();let x=t.render.getPixelData(),p=Array(1e4);for(let F=0;F<1e4;F++)p[F]=x[4*F]+x[4*F+1]+x[4*F+2];p.sort((e,r)=>e-r);let y=(p[Math.floor(9600)]+p[Math.floor(9800)])/255*15*(Math.abs(l/2)+1);c.push(y);let C=c.length;C>10&&c.shift(),y=Math.max(c.reduce((e,r)=>e+r)/C,.5),r.gl.uniform1i(r.uniforms.juliaMode,o),r.gl.uniform1f(r.uniforms.aspectRatio,i),r.gl.uniform2fv(r.uniforms.worldCenterX,d),r.gl.uniform2fv(r.uniforms.worldCenterY,w),r.gl.uniform1f(r.uniforms.worldSize,Math.min(r.worldHeight,r.worldWidth)/2),r.gl.uniform1i(r.uniforms.numIterations,n),r.gl.uniform1f(r.uniforms.a,s),r.gl.uniform1f(r.uniforms.b,u),r.gl.uniform1f(r.uniforms.brightnessScale,y),r.render.drawFrame(),a>=50&&(g=0,h=0,v=0,b=0,_=0,f=0),(0!==g||0!==h||0!==v)&&(r.worldCenterX+=g*r.worldWidth,r.worldCenterY+=h*r.worldHeight,r.worldCenterX=Math.min(Math.max(r.worldCenterX,-2),2),r.worldCenterY=Math.min(Math.max(r.worldCenterY,-2),2),25e-5>Math.sqrt((g*=.96)*g+(h*=.96)*h)&&(g=0,h=0),l+=v,l=Math.min(l,1),A($,m),.001>Math.abs(v*=.93)&&(v=0),window.requestAnimationFrame(q))}function M(){r.fullscreen.currentlyFullscreen?(i=window.innerWidth/window.innerHeight)>=1?(r.changeCanvasSize(d,Math.floor(d/i)),r.worldWidth=4*Math.pow(2,l)*i,r.worldHeight=4*Math.pow(2,l)):(r.changeCanvasSize(Math.floor(d*i),d),r.worldWidth=4*Math.pow(2,l),r.worldHeight=4*Math.pow(2,l)/i):(i=1,r.changeCanvasSize(d,d),r.worldWidth=4*Math.pow(2,l),r.worldHeight=4*Math.pow(2,l)),window.requestAnimationFrame(q)}function P(e){let r=new Float32Array(2),t=536870913*e,o=t-(t-e);return r[0]=o,r[1]=e-o,[r[0],r[1]]}y.style.opacity=1,y.addEventListener("click",()=>{Page.Animate.changeOpacity(y,0,Site.opacityAnimationTime),setTimeout(()=>{2===o?y.textContent="Return to Mandelbrot Set":0===o&&(y.textContent="Pick Julia Set",Page.Animate.changeOpacity(y,1,Site.opacityAnimationTime))},Site.opacityAnimationTime),0===o?(o=2,s=0,u=0,g=0,h=0,v=0,b=0,_=0,f=0,c=[],window.requestAnimationFrame(q)):1===o&&(o=0,r.worldCenterX=-.75,r.worldCenterY=0,r.worldWidth=4,r.worldHeight=4,l=0,c=[],window.requestAnimationFrame(q))}),r.gl.uniform1f(r.uniforms.aspectRatio,1),t.gl.uniform1f(t.uniforms.aspectRatio,1),window.requestAnimationFrame(q),Page.show(),window.addEventListener("resize",M),Page.temporaryHandlers.resize.push(M)}();