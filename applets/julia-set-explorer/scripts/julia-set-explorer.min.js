!function(){"use strict";let c=`
		precision highp float;
		
		varying vec2 uv;
		
		uniform int julia_mode;
		uniform int double_precision;
		
		uniform float aspect_ratio;
		
		uniform vec2 world_center_x;
		uniform vec2 world_center_y;
		uniform float world_size;
		
		uniform float a;
		uniform float b;
		uniform int num_iterations;
		uniform float brightness_scale;
		
		
		
		float times_frc(float a, float b)
		{
			return mix(0.0, a * b, b != 0.0 ? 1.0 : 0.0);
		}

		float plus_frc(float a, float b)
		{
			return mix(a, a + b, b != 0.0 ? 1.0 : 0.0);
		}

		float minus_frc(float a, float b)
		{
			return mix(a, a - b, b != 0.0 ? 1.0 : 0.0);
		}

		// Double emulation based on GLSL Mandelbrot Shader by Henry Thasler (www.thasler.org/blog)
		// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/
		// Add: res = ds_add(a, b) => res = a + b
		vec2 add (vec2 dsa, vec2 dsb)
		{
			vec2 dsc;
			float t1, t2, e;
			t1 = plus_frc(dsa.x, dsb.x);
			e = minus_frc(t1, dsa.x);
			t2 = plus_frc(plus_frc(plus_frc(minus_frc(dsb.x, e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);
			dsc.x = plus_frc(t1, t2);
			dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));
			return dsc;
		}

		// Subtract: res = ds_sub(a, b) => res = a - b
		vec2 sub (vec2 dsa, vec2 dsb)
		{
			vec2 dsc;
			float e, t1, t2;
			t1 = minus_frc(dsa.x, dsb.x);
			e = minus_frc(t1, dsa.x);
			t2 = minus_frc(plus_frc(plus_frc(minus_frc(minus_frc(0.0, dsb.x), e), minus_frc(dsa.x, minus_frc(t1, e))), dsa.y), dsb.y);
			dsc.x = plus_frc(t1, t2);
			dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));
			return dsc;
		}

		// Compare: res = -1 if a < b // = 0 if a == b // = 1 if a > b
		float cmp(vec2 dsa, vec2 dsb)
		{
			if (dsa.x < dsb.x)
			{
				return -1.;
			}
			
			if (dsa.x > dsb.x)
			{
				return 1.;
			}
			
			if (dsa.y < dsb.y)
			{
				return -1.;
			}
			
			if (dsa.y > dsb.y)
			{
				return 1.;
			}
			
			return 0.;
		}

		// Multiply: res = ds_mul(a, b) => res = a * b

		vec2 mul (vec2 dsa, vec2 dsb)
		{
			vec2 dsc;
			float c11, c21, c2, e, t1, t2;
			float a1, a2, b1, b2, cona, conb, split = 8193.;
			cona = times_frc(dsa.x, split);
			conb = times_frc(dsb.x, split);
			a1 = minus_frc(cona, minus_frc(cona, dsa.x));
			b1 = minus_frc(conb, minus_frc(conb, dsb.x));
			a2 = minus_frc(dsa.x, a1);
			b2 = minus_frc(dsb.x, b1);
			c11 = times_frc(dsa.x, dsb.x);
			c21 = plus_frc(times_frc(a2, b2), plus_frc(times_frc(a2, b1), plus_frc(times_frc(a1, b2), minus_frc(times_frc(a1, b1), c11))));
			c2 = plus_frc(times_frc(dsa.x, dsb.y), times_frc(dsa.y, dsb.x));
			t1 = plus_frc(c11, c2);
			e = minus_frc(t1, c11);
			t2 = plus_frc(plus_frc(times_frc(dsa.y, dsb.y), plus_frc(minus_frc(c2, e), minus_frc(c11, minus_frc(t1, e)))), c21);
			dsc.x = plus_frc(t1, t2);
			dsc.y = minus_frc(t2, minus_frc(dsc.x, t1));
			return dsc;
		}

		// create double-single number from float
		vec2 set(float a)
		{
			return vec2(a, 0.0);
		}

		float rand(vec2 co)
		{
			// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}

		vec2 complexMul(vec2 a, vec2 b)
		{
			return vec2(a.x*b.x - a.y*b.y,a.x*b.y + a.y * b.x);
		}

		// double complex multiplication
		vec4 dcMul(vec4 a, vec4 b)
		{
			return vec4(sub(mul(a.xy,b.xy),mul(a.zw,b.zw)),add(mul(a.xy,b.zw),mul(a.zw,b.xy)));
		}

		vec4 dcAdd(vec4 a, vec4 b)
		{
			return vec4(add(a.xy,b.xy),add(a.zw,b.zw));
		}

		// Length of double complex
		vec2 dcLength(vec4 a)
		{
			return add(mul(a.xy,a.xy),mul(a.zw,a.zw));
		}

		vec4 dcSet(vec2 a)
		{
			return vec4(a.x,0.,a.y,0.);
		}

		vec4 dcSet(vec2 a, vec2 ad)
		{
			return vec4(a.x, ad.x,a.y,ad.y);
		}

		// Multiply double-complex with double
		vec4 dcMul(vec4 a, vec2 b)
		{
			return vec4(mul(a.xy,b),mul(a.wz,b));
		}
		
		
		
		void main(void)
		{
			if (double_precision == 0)
			{
				vec2 z;
				
				if (aspect_ratio >= 1.0)
				{
					z = vec2(uv.x * aspect_ratio * world_size + world_center_x.x, uv.y * world_size + world_center_y.x);
				}
				
				else
				{
					z = vec2(uv.x * world_size + world_center_x.x, uv.y / aspect_ratio * world_size + world_center_y.x);
				}
				
				vec3 color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
				float brightness = exp(-length(z));
				
				
				
				if (julia_mode == 0)
				{
					vec2 c = z;
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							return;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
						
						brightness += exp(-length(z));
					}
					
					
					gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
				}
				
				
				
				else if (julia_mode == 1)
				{
					vec2 c = vec2(a, b);
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							return;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
						
						brightness += exp(-length(z));
					}
					
					
					gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
				}
				
				
				
				else
				{
					vec2 c = z;
					
					bool broken = false;
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							
							broken = true;
							
							break;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
						
						brightness += exp(-length(z));
					}
					
					
					
					if (!broken)
					{
						gl_FragColor = vec4(.5 * brightness / brightness_scale * color, 1.0);
					}
					
					
					
					z = vec2(uv.x * aspect_ratio * 2.0, uv.y * 2.0);
					color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
					brightness = exp(-length(z));
					
					broken = false;
					
					c = vec2(a, b);
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor.xyz /= 4.0;
							
							broken = true;
							
							break;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
						
						brightness += exp(-length(z));
					}
					
					if (!broken)
					{
						gl_FragColor += vec4(brightness / brightness_scale * color, 0.0);
					}
				}
			}
			
			
			
			else
			{
				vec4 z;
				
				if (aspect_ratio >= 1.0)
				{
					z = dcAdd(dcMul(vec4(uv.x * aspect_ratio, 0.0, uv.y, 0.0), vec2(world_size, 0.0)), vec4(world_center_x, world_center_y));
				}
				
				else
				{
					z = dcAdd(dcMul(vec4(uv.x, 0.0, uv.y / aspect_ratio, 0.0), vec2(world_size, 0.0)), vec4(world_center_x, world_center_y));
				}
				
				vec3 color = normalize(vec3(abs(z.x + z.z) / 2.0, abs(z.x) / 2.0, abs(z.z) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
				float brightness = exp(-length(z));
				
				
				
				if (julia_mode == 0)
				{
					vec4 c = z;
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							return;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = dcAdd(dcMul(z, z), c);
						
						brightness += exp(-length(z));
					}
					
					
					gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
				}
				
				else if (julia_mode == 1)
				{
					vec4 c = vec4(a, 0.0, b, 0.0);
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							return;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = dcAdd(dcMul(z, z), c);
						
						brightness += exp(-length(z));
					}
					
					
					gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
				}
				
				else
				{
					vec4 c = z;
					
					bool broken = false;
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
							
							broken = true;
							
							break;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = dcAdd(dcMul(z, z), c);
						
						brightness += exp(-length(z));
					}
					
					
					
					if (!broken)
					{
						gl_FragColor = vec4(.5 * brightness / brightness_scale * color, 1.0);
					}
					
					
					
					z = c;
					color = normalize(vec3(abs(z.x + z.z) / 2.0, abs(z.x) / 2.0, abs(z.z) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
					brightness = exp(-length(z));
					
					broken = false;
					
					c = vec4(a, 0.0, b, 0.0);
					
					for (int iteration = 0; iteration < 3001; iteration++)
					{
						if (iteration == num_iterations)
						{
							gl_FragColor.xyz /= 4.0;
							
							broken = true;
							
							break;
						}
						
						if (length(z) >= 4.0)
						{
							break;
						}
						
						z = dcAdd(dcMul(z, z), c);
						
						brightness += exp(-length(z));
					}
					
					if (!broken)
					{
						gl_FragColor += vec4(brightness / brightness_scale * color, 0.0);
					}
				}
			}	
		}
	`,a=new Wilson(Page.element.querySelector("#output-canvas"),{renderer:"gpu",shader:c,canvas_width:1e3,canvas_height:1e3,world_width:4,world_height:4,world_center_x:-0.75,world_center_y:0,use_fullscreen:!0,true_fullscreen:!0,use_fullscreen_button:!0,enter_fullscreen_button_icon_path:"/graphics/general-icons/enter-fullscreen.png",exit_fullscreen_button_icon_path:"/graphics/general-icons/exit-fullscreen.png",switch_fullscreen_callback:e,mousedown_callback:A,touchstart_callback:A,mousemove_callback:function(a,b,d,e,c){2===h&&"mousemove"===c.type&&(n=a,o=b,window.requestAnimationFrame(g))},mousedrag_callback:B,touchmove_callback:B,mouseup_callback:C,touchend_callback:C,wheel_callback:function(b,c,a,d){r=b,s=c,.3>Math.abs(a/100)?(k+=a/100,k=Math.min(k,1)):y+=.05*Math.sign(a),D()},pinch_callback:function(c,d,b,e){2!==h&&(i>=1?(k-=b/a.world_width*10,v=-b/a.world_width*10):(k-=b/a.world_height*10,v=-b/a.world_height*10),k=Math.min(k,1),r=c,s=d,D())}});a.render.init_uniforms(["julia_mode","double_precision","aspect_ratio","world_center_x","world_center_y","world_size","a","b","num_iterations","brightness_scale"]),a.gl.uniform1i(a.uniforms.double_precision,0);let b=new Wilson(Page.element.querySelector("#hidden-canvas"),{renderer:"gpu",shader:c,canvas_width:100,canvas_height:100});b.render.init_uniforms(["julia_mode","double_precision","aspect_ratio","world_center_x","world_center_y","world_size","a","b","num_iterations","brightness_scale"]),b.gl.uniform1i(b.uniforms.double_precision,0);let h=0,i=1,j=100,k=0,l=!1,m=[],n=0,o=1,p=1e3,q=100,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=-1,f=Page.element.querySelector("#resolution-input");f.addEventListener("input",()=>{p=parseInt(f.value||1e3),a.change_canvas_size(p,p)}),Page.element.querySelector("#download-button").addEventListener("click",()=>{a.download_frame("a-julia-set.png")});let d=Page.element.querySelector("#switch-julia-mode-button");function A(c,e,b){w=0,x=0,y=0,t=0,u=0,v=0,2===h&&"mousedown"===b.type&&(h=1,a.world_center_x=0,a.world_center_y=0,a.world_width=4,a.world_height=4,k=0,m=[],Page.Animate.change_opacity(d,1,Site.opacity_animation_time),window.requestAnimationFrame(g))}function B(d,e,b,c,f){2===h&&"touchmove"===f.type?(n=d,o=e):(a.world_center_x-=b,a.world_center_y-=c,t=-b/a.world_width,u=-c/a.world_height,a.world_center_x=Math.min(Math.max(a.world_center_x,-2),2),a.world_center_y=Math.min(Math.max(a.world_center_y,-2),2)),window.requestAnimationFrame(g)}function C(c,e,b){2===h&&"touchend"===b.type?(h=1,a.world_center_x=0,a.world_center_y=0,a.world_width=4,a.world_height=4,k=0,m=[],Page.Animate.change_opacity(d,1,Site.opacity_animation_time),window.requestAnimationFrame(g)):(Math.sqrt(t*t+u*u)>=.0025&&(w=t,x=u),Math.abs(v)>=.01&&(y=v)),window.requestAnimationFrame(g)}function D(){if(i>=1){let c=a.input.get_zoomed_world_center(r,s,4*Math.pow(2,k)*i,4*Math.pow(2,k));a.world_width=4*Math.pow(2,k)*i,a.world_height=4*Math.pow(2,k),a.world_center_x=c[0],a.world_center_y=c[1]}else{let d=a.input.get_zoomed_world_center(r,s,4*Math.pow(2,k),4*Math.pow(2,k)/i);a.world_width=4*Math.pow(2,k),a.world_height=4*Math.pow(2,k)/i,a.world_center_x=d[0],a.world_center_y=d[1]}j=-(30*k)+200,!l&&k< -16?(l=!0,b.gl.uniform1i(b.uniforms.double_precision,1),a.gl.uniform1i(a.uniforms.double_precision,1),a.canvas.style.borderColor="rgb(127, 0, 0)",console.log("Using double precision")):l&&k> -16&&(l=!1,b.gl.uniform1i(b.uniforms.double_precision,0),a.gl.uniform1i(a.uniforms.double_precision,0),a.canvas.style.borderColor="rgb(127, 127, 127)",console.log("Using single precision")),window.requestAnimationFrame(g)}function g(l){let p=l-z;if(z=l,0===p)return;let A=E(a.world_center_x),B=E(a.world_center_y);b.gl.uniform1i(b.uniforms.julia_mode,h),b.gl.uniform2fv(b.uniforms.world_center_x,A),b.gl.uniform2fv(b.uniforms.world_center_y,B),b.gl.uniform1f(b.uniforms.world_size,Math.min(a.world_height,a.world_width)/2),b.gl.uniform1i(b.uniforms.num_iterations,j),b.gl.uniform1f(b.uniforms.a,n),b.gl.uniform1f(b.uniforms.b,o),b.gl.uniform1f(b.uniforms.brightness_scale,20*(Math.abs(k)+1)),b.render.draw_frame();let e=b.render.get_pixel_data(),d=new Array(q*q);for(let c=0;c<q*q;c++)d[c]=e[4*c]+e[4*c+1]+e[4*c+2];d.sort((a,b)=>a-b);let f=(d[Math.floor(q*q*.96)]+d[Math.floor(q*q*.98)])/255*15*(Math.abs(k/2)+1);m.push(f);let C=m.length;C>10&&m.shift(),f=Math.max(m.reduce((a,b)=>a+b)/C,.5),a.gl.uniform1i(a.uniforms.julia_mode,h),a.gl.uniform1f(a.uniforms.aspect_ratio,i),a.gl.uniform2fv(a.uniforms.world_center_x,A),a.gl.uniform2fv(a.uniforms.world_center_y,B),a.gl.uniform1f(a.uniforms.world_size,Math.min(a.world_height,a.world_width)/2),a.gl.uniform1i(a.uniforms.num_iterations,j),a.gl.uniform1f(a.uniforms.a,n),a.gl.uniform1f(a.uniforms.b,o),a.gl.uniform1f(a.uniforms.brightness_scale,f),a.render.draw_frame(),p>=50&&(w=0,x=0,y=0,t=0,u=0,v=0),(0!==w||0!==x||0!==y)&&(a.world_center_x+=w*a.world_width,a.world_center_y+=x*a.world_height,a.world_center_x=Math.min(Math.max(a.world_center_x,-2),2),a.world_center_y=Math.min(Math.max(a.world_center_y,-2),2),25e-5>Math.sqrt((w*=.96)*w+(x*=.96)*x)&&(w=0,x=0),k+=y,k=Math.min(k,1),D(r,s),.001>Math.abs(y*=.93)&&(y=0),window.requestAnimationFrame(g))}function e(){a.fullscreen.currently_fullscreen?(i=window.innerWidth/window.innerHeight)>=1?(a.change_canvas_size(p,Math.floor(p/i)),a.world_width=4*Math.pow(2,k)*i,a.world_height=4*Math.pow(2,k)):(a.change_canvas_size(Math.floor(p*i),p),a.world_width=4*Math.pow(2,k),a.world_height=4*Math.pow(2,k)/i):(i=1,a.change_canvas_size(p,p),a.world_width=4*Math.pow(2,k),a.world_height=4*Math.pow(2,k)),window.requestAnimationFrame(g)}function E(b){let a=new Float32Array(2),c=536870913*b,d=c-(c-b);return a[0]=d,a[1]=b-d,[a[0],a[1]]}d.style.opacity=1,d.addEventListener("click",()=>{Page.Animate.change_opacity(d,0,Site.opacity_animation_time),setTimeout(()=>{2===h?d.textContent="Return to Mandelbrot Set":0===h&&(d.textContent="Pick Julia Set",Page.Animate.change_opacity(d,1,Site.opacity_animation_time))},Site.opacity_animation_time),0===h?(h=2,n=0,o=0,w=0,x=0,y=0,t=0,u=0,v=0,m=[],window.requestAnimationFrame(g)):1===h&&(h=0,a.world_center_x=-0.75,a.world_center_y=0,a.world_width=4,a.world_height=4,k=0,m=[],window.requestAnimationFrame(g))}),a.gl.uniform1f(a.uniforms.aspect_ratio,1),b.gl.uniform1f(b.uniforms.aspect_ratio,1),window.requestAnimationFrame(g),Page.show(),window.addEventListener("resize",e),Page.temporary_handlers.resize.push(e)}()