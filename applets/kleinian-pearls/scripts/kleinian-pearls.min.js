!function(){"use strict";let t=document.querySelector("#output-canvas").getContext("webgl"),e=Math.min(document.querySelector("#output-canvas").offsetWidth,document.querySelector("#output-canvas").offsetHeight),n=!1,o=!1,a=!1,i=0,r=0,c=0,u=!1,s=!1,l=!1,m=!1,_=!1,f=!1,p=0,d=1,v=1,h=Math.PI/2,g=Math.PI/2,y=300,z=300,w=300,x=300,b=900,M=48,S=[],q=[],A=[],k=[],P=[3.98,.25,.95],L=1.902,E=.042,F=1,I=6,D=1.902,C=1.902,U=.042,T=.042,R=1,Y=1,H=2,N=[0,0,5],X=0;document.querySelector("#output-canvas").setAttribute("width",z),document.querySelector("#output-canvas").setAttribute("height",w),document.querySelector("#dim-input").addEventListener("input",function(){Q(0)}),document.querySelector("#generate-high-res-image-button").addEventListener("click",function(){let e=y;y=parseInt(document.querySelector("#high-res-dim-input").value||2e3),document.querySelector("#output-canvas").setAttribute("width",y),document.querySelector("#output-canvas").setAttribute("height",y),t.viewport(0,0,y,y),V();let n=document.createElement("a");n.download="kleinian-pearls.png",n.href=document.querySelector("#output-canvas").toDataURL(),n.click(),n.remove(),y=e,document.querySelector("#output-canvas").setAttribute("width",y),document.querySelector("#output-canvas").setAttribute("height",y),t.viewport(0,0,y,y),V()});let B=document.querySelectorAll("#klein-r-input, #klein-i-input, #box-size-input");for(let t=0;t<B.length;t++)B[t].addEventListener("input",Z);document.querySelector("#randomize-parameters-button").addEventListener("click",function(t=!0){if(o)return;y!==x&&Q(y=x);D=L,C=.1*Math.random()-.075+2-D,U=E,T=.1*Math.random()-.05-U,R=F,Y=.2*Math.random()-.1+1-R,document.querySelector("#klein-r-input").value=Math.round(1e6*(D+C))/1e6,document.querySelector("#klein-i-input").value=Math.round(1e6*(U+T))/1e6,document.querySelector("#box-size-input").value=Math.round(1e6*(R+Y))/1e6,tt()}),window.addEventListener("resize",J),setTimeout(J,500),Page.Applets.Canvases.to_resize=[document.querySelector("#output-canvas")],Page.Applets.Canvases.resize_callback=function(){Page.Applets.Canvases.is_fullscreen?Page.Layout.aspect_ratio>=1?(z=y,w=Math.floor(y/Page.Layout.aspect_ratio)):(z=Math.floor(y*Page.Layout.aspect_ratio),w=y):(z=y,w=y),e=Math.min(document.querySelector("#output-canvas").offsetWidth,document.querySelector("#output-canvas").offsetHeight),document.querySelector("#output-canvas").setAttribute("width",z),document.querySelector("#output-canvas").setAttribute("height",w),z>=w?(t.uniform1f(G.aspect_ratio_x_uniform,z/w),t.uniform1f(G.aspect_ratio_y_uniform,1)):(t.uniform1f(G.aspect_ratio_x_uniform,1),t.uniform1f(G.aspect_ratio_y_uniform,z/w)),t.uniform1i(G.image_size_uniform,y),t.viewport(0,0,z,w),J(),window.requestAnimationFrame(V)},Page.Applets.Canvases.true_fullscreen=!0,Page.Applets.Canvases.set_up_resizer(),document.querySelector("#output-canvas").addEventListener("mousedown",function(t){a=!0,r=t.clientX,c=t.clientY,n||o||(n=!0,i=Date.now(),Q(y=x),window.requestAnimationFrame(V))}),document.querySelector("#output-canvas").addEventListener("mousemove",function(t){if(a){t.preventDefault();let n=t.clientX,o=t.clientY,a=n-r,i=o-c;(h+=a/e*Math.PI)>=2*Math.PI?h-=2*Math.PI:h<0&&(h+=2*Math.PI),(g-=i/e*Math.PI)>Math.PI-.01?g=Math.PI-.01:g<.01&&(g=.01),r=n,c=o,$()}}),document.querySelector("#output-canvas").addEventListener("mouseup",function(t){!(n=(a=!1)||u||s||l||m||_||f)&&Date.now()-i>300&&(Q(y=b),window.requestAnimationFrame(V))}),document.querySelector("#output-canvas").addEventListener("touchstart",function(t){a=!0,r=t.touches[0].clientX,c=t.touches[0].clientY,2===t.touches.length?(_=!0,f=!1):3===t.touches.length&&(f=!0,_=!1),n||o||(n=!0,i=Date.now(),Q(y=x),window.requestAnimationFrame(V))}),document.querySelector("#output-canvas").addEventListener("touchmove",function(t){t.preventDefault();let n=t.touches[0].clientX,o=t.touches[0].clientY,a=n-r,i=o-c;Math.abs(a)>20||Math.abs(i)>20||((h+=a/e*Math.PI)>=2*Math.PI?h-=2*Math.PI:h<0&&(h+=2*Math.PI),(g-=i/e*Math.PI)>Math.PI-.01?g=Math.PI-.01:g<.01&&(g=.01),r=n,c=o,$())}),document.querySelector("#output-canvas").addEventListener("touchend",function(t){2===t.touches.length?(_=!0,f=!1):3===t.touches.length?(f=!0,_=!1):(_=!1,f=!1,0===t.touches.length&&(a=!1)),!(n=a||u||s||l||m||_||f)&&Date.now()-i>300&&(Q(y=b),window.requestAnimationFrame(V))}),document.documentElement.addEventListener("keydown",function(t){"INPUT"===document.activeElement.tagName||87!==t.keyCode&&83!==t.keyCode&&68!==t.keyCode&&65!==t.keyCode||(87===t.keyCode?u=!0:83===t.keyCode&&(s=!0),68===t.keyCode?l=!0:65===t.keyCode&&(m=!0),n||o||(n=!0,i=Date.now(),Q(y=x),window.requestAnimationFrame(V)))}),document.documentElement.addEventListener("keyup",function(t){87===t.keyCode?u=!1:83===t.keyCode&&(s=!1),68===t.keyCode?l=!1:65===t.keyCode&&(m=!1),!(n=a||u||s||l||m||_||f)&&Date.now()-i>300&&(Q(y=b),window.requestAnimationFrame(V))}),setTimeout(function(){let e=O(t,t.VERTEX_SHADER,W),n=O(t,t.FRAGMENT_SHADER,j);G=t.createProgram(),t.attachShader(G,e),t.attachShader(G,n),t.linkProgram(G),t.getProgramParameter(G,t.LINK_STATUS)||(console.log(`Couldn't link shader program: ${t.getShaderInfoLog(shader)}`),t.deleteProgram(G));t.useProgram(G);let o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,-1,1,0,1,-1,0,1,1,0]),t.STATIC_DRAW),G.position_attribute=t.getAttribLocation(G,"position"),t.enableVertexAttribArray(G.position_attribute),t.vertexAttribPointer(G.position_attribute,3,t.FLOAT,!1,0,0),$(),G.aspect_ratio_x_uniform=t.getUniformLocation(G,"aspect_ratio_x"),G.aspect_ratio_y_uniform=t.getUniformLocation(G,"aspect_ratio_y"),G.image_size_uniform=t.getUniformLocation(G,"image_size"),G.camera_pos_uniform=t.getUniformLocation(G,"camera_pos"),G.image_plane_center_pos_uniform=t.getUniformLocation(G,"image_plane_center_pos"),G.forward_vec_uniform=t.getUniformLocation(G,"forward_vec"),G.right_vec_uniform=t.getUniformLocation(G,"right_vec"),G.up_vec_uniform=t.getUniformLocation(G,"up_vec"),G.focal_length_uniform=t.getUniformLocation(G,"focal_length"),G.light_pos_uniform=t.getUniformLocation(G,"light_pos"),G.klein_r_uniform=t.getUniformLocation(G,"klein_r"),G.klein_i_uniform=t.getUniformLocation(G,"klein_i"),G.box_size_uniform=t.getUniformLocation(G,"box_size"),G.rotate_factor_uniform=t.getUniformLocation(G,"rotate_factor"),z>=w?(t.uniform1f(G.aspect_ratio_x_uniform,z/w),t.uniform1f(G.aspect_ratio_y_uniform,1)):(t.uniform1f(G.aspect_ratio_x_uniform,1),t.uniform1f(G.aspect_ratio_y_uniform,z/w));t.uniform1i(G.image_size_uniform,y),t.uniform3fv(G.camera_pos_uniform,P),t.uniform3fv(G.image_plane_center_pos_uniform,S),t.uniform3fv(G.forward_vec_uniform,q),t.uniform3fv(G.right_vec_uniform,A),t.uniform3fv(G.up_vec_uniform,k),t.uniform1f(G.focal_length_uniform,H),t.uniformMatrix3fv(G.rotation_matrix_uniform,!1,[1,0,0,0,1,0,0,0,1]),t.uniform3fv(G.light_pos_uniform,N),t.uniform1f(G.klein_r_uniform,L),t.uniform1f(G.klein_i_uniform,E),t.uniform1f(G.box_size_uniform,F),t.uniform1f(G.rotate_factor_uniform,I),t.viewport(0,0,z,w),window.requestAnimationFrame(V)},500);const W="\n\t\tattribute vec3 position;\n\t\tvarying vec2 uv;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tgl_Position = vec4(position, 1.0);\n\n\t\t\t//Interpolate quad coordinates in the fragment shader.\n\t\t\tuv = position.xy;\n\t\t}\n\t",j="\n\t\tprecision highp float;\n\t\t\n\t\tvarying vec2 uv;\n\t\t\n\t\tuniform float aspect_ratio_x;\n\t\tuniform float aspect_ratio_y;\n\t\t\n\t\tuniform vec3 camera_pos;\n\t\tuniform vec3 image_plane_center_pos;\n\t\tuniform vec3 forward_vec;\n\t\tuniform vec3 right_vec;\n\t\tuniform vec3 up_vec;\n\t\t\n\t\tuniform float focal_length;\n\t\t\n\t\tuniform vec3 light_pos;\n\t\tconst float light_brightness = 3.0;\n\t\t\n\t\tuniform int image_size;\n\t\t\n\t\t\n\t\t\n\t\tconst float clip_distance = 1000.0;\n\t\tconst int max_marches = 128; //Change to 512 to eliminate flickering in animations\n\t\tconst vec3 fog_color = vec3(0.0, 0.0, 0.0);\n\t\tconst float fog_scaling = .1;\n\t\tconst int num_iterations = 48;\n\t\t\n\t\t\n\t\t\n\t\tuniform float klein_r;\n\t\tuniform float klein_i;\n\t\t\n\t\tuniform float box_size;\n\t\t\n\t\tconst vec3 inversion_center = vec3(0.0, 0.0, 0.0);\n\t\tconst vec3 re_center = vec3(0.0, 0.0, 0.0);\n\t\tconst float inversion_radius = 1.0;\n\t\t\n\t\tuniform float rotate_factor;\n\t\t\n\t\t\n\t\t\n\t\tvec3 color;\n\t\t\n\t\t\n\t\t\n\t\tvec2 wrap(vec2 x, vec2 a, vec2 s)\n\t\t{\n\t\t\tx -= s; \n\t\t\t\n\t\t\treturn (x - a * floor(x / a)) + s;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid trans_a(inout vec3 z, inout float DF, float a, float b)\n\t\t{\n\t\t\tfloat iR = 1.0 / dot(z, z);\n\t\t\tz *= -iR;\n\t\t\tz.x = -b - z.x;\n\t\t\tz.y = a + z.y; \n\t\t\tDF *= iR;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfloat jos_kleinian(vec3 z)\n\t\t{\n\t\t\tvec3 lz = z + vec3(1.0), llz = z + vec3(-1.0);\n\t\t\t\n\t\t\tfloat DE = 1000.0;\n\t\t\tfloat DF = 1.0;\n\t\t\t\n\t\t\tfloat a = klein_r, b = klein_i;\n\t\t\t\n\t\t\tfloat f = sign(b);\n\t\t\t\n\t\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\t\tfloat color_scale = .5;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int i = 0; i < num_iterations; i++) \n\t\t\t{\n\t\t\t\tz.x = z.x + b / a * z.y;\n\t\t\t\t\n\t\t\t\tz.xz = wrap(z.xz, vec2(2.0 * box_size, 2.0 * box_size), vec2(-box_size, -box_size));\n\t\t\t\t\n\t\t\t\tz.x = z.x - b / a * z.y;\n\n\t\t\t\t//If above the separation line, rotate by 180 deg about (-b/2, a/2)\n\t\t\t\tif (z.y >= a * (0.5 + f * 0.25 * sign(z.x + b * 0.5) * (1.0 - exp(-rotate_factor * abs(z.x + b * 0.5)))))\n\t\t\t\t{\n\t\t\t\t\tz = vec3(-b, a, 0.0) - z;\n\t\t\t\t\t//z.xy = vec2(-b, a) - z.xy;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\n\t\t\t\t//Apply transformation a\n\t\t\t\ttrans_a(z, DF, a, b);\n\t\t\t\t\n\t\t\t\tif (dot(z - llz, z - llz) < .0000001)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tllz = lz;\n\t\t\t\tlz = z;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcolor = mix(color, abs(z), color_scale);\n\t\t\t\t\n\t\t\t\tcolor_scale *= .5;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tfloat y = min(z.y, a - z.y);\n\t\t\t\t\n\t\t\t\tDE = min(DE, min(y, 1.0) / max(DF, 1.0));\n\t\t\t\t\n\t\t\t\ttrans_a(z, DF, a, b);\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\tfloat y = min(z.y, a - z.y);\n\n\t\t\tDE = min(DE, min(y, 1.0) / max(DF, 1.0));\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tcolor /= max(max(color.x, color.y), color.z);\n\t\t\t\n\t\t\t\n\n\t\t\treturn DE;\n\t\t}\n\n\n\n\n\t\tfloat distance_estimator(vec3 pos)\n\t\t{\n\t\t\tvec3 p = pos.xzy;\n\t\t\t\n\t\t\treturn jos_kleinian(p);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_surface_normal(vec3 pos)\n\t\t{\n\t\t\tfloat base = distance_estimator(pos);\n\t\t\t\n\t\t\tfloat x_step = distance_estimator(pos + vec3(.0001, 0.0, 0.0));\n\t\t\tfloat y_step = distance_estimator(pos + vec3(0.0, .0001, 0.0));\n\t\t\tfloat z_step = distance_estimator(pos + vec3(0.0, 0.0, .0001));\n\t\t\t\n\t\t\treturn normalize(vec3(x_step - base, y_step - base, z_step - base));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 compute_shading(vec3 pos, int iteration)\n\t\t{\n\t\t\tvec3 surface_normal = get_surface_normal(pos);\n\t\t\t\n\t\t\tvec3 light_direction = normalize(light_pos - pos);\n\t\t\t\n\t\t\tfloat dot_product = dot(surface_normal, light_direction);\n\t\t\t\n\t\t\tfloat light_intensity = light_brightness * max(dot_product, -.25 * dot_product);\n\t\t\t\n\t\t\t//The last factor adds ambient occlusion.\n\t\t\tcolor = color * light_intensity * max(1.0 - float(iteration) / float(max_marches), 0.0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Apply fog.\n\t\t\tfloat distance_from_camera = distance(pos, camera_pos);\n\t\t\t\n\t\t\tfloat fog_amount = 1.0 - exp(-distance_from_camera * fog_scaling);\n\t\t\t\n\t\t\treturn mix(color, fog_color, fog_amount);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 raymarch(vec3 start_pos)\n\t\t{\n\t\t\t//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.\n\t\t\tvec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\n\t\t\tvec3 final_color = fog_color;\n\t\t\t\n\t\t\tfloat epsilon = 0.0;\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\t\n\t\t\tfloat last_distance = 1000.0;\n\t\t\t\n\t\t\tint slowed_down = 0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < max_marches; iteration++)\n\t\t\t{\n\t\t\t\tvec3 pos = start_pos + t * ray_direction_vec;\n\t\t\t\t\n\t\t\t\t//This prevents overstepping, and is honestly a pretty clever fix.\n\t\t\t\tfloat distance = min(distance_estimator(pos), last_distance);\n\t\t\t\tlast_distance = distance;\n\t\t\t\t\n\t\t\t\t//This lowers the detail far away, which makes everything run nice and fast.\n\t\t\t\tif (distance / float(image_size) * 1.5 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / float(image_size) * 1.5;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (distance < epsilon)\n\t\t\t\t{\n\t\t\t\t\tfinal_color = compute_shading(pos, iteration);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Uncomment to add aggressive understepping when close to the fractal boundary, which helps to prevent flickering but is a significant performance hit.\n\t\t\t\t\n\t\t\t\t\n\t\t\t\telse if (last_distance / distance > .999 && slowed_down == 0)\n\t\t\t\t{\n\t\t\t\t\tray_direction_vec = normalize(start_pos - camera_pos) * .125;\n\t\t\t\t\t\n\t\t\t\t\tslowed_down = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (last_distance / distance <= .999 && slowed_down == 1)\n\t\t\t\t{\n\t\t\t\t\tray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\t\t\n\t\t\t\t\tslowed_down = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\telse if (t > clip_distance)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt += distance;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn final_color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\t//Uncomment to use 2x antialiasing.\n\t\t\t//vec3 final_color = (raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size)))) / 4.0;\n\t\t\t\n\t\t\tvec3 final_color = raymarch(image_plane_center_pos + right_vec * uv.x * aspect_ratio_x + up_vec * uv.y / aspect_ratio_y);\n\t\t\t\t\n\t\t\tgl_FragColor = vec4(final_color.xyz, 1.0);\n\t\t}\n\t";let G=null;function O(t,e,n){let o=t.createShader(e);return t.shaderSource(o,n),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)||(console.log(`Couldn't load shader: ${t.getProgramInfoLog(shaderProgram)}`),t.deleteShader(o)),o}function V(){t.drawArrays(t.TRIANGLE_STRIP,0,4),o?(!function(){let e=.5*Math.sin(Math.PI*X/120-Math.PI/2)+.5;L=D+C*e,E=U+T*e,F=R+Y*e,t.uniform1f(G.klein_r_uniform,L),t.uniform1f(G.klein_i_uniform,E),t.uniform1f(G.box_size_uniform,F),121==++X&&(o=!1)}(),window.requestAnimationFrame(V)):n&&((u||s||l||m||_||f)&&(d<1.2*v&&(p=d/100),p<1e-6&&(p=1e-6),p>.02&&(p=.02),u||_?(P[0]+=p*q[0],P[1]+=p*q[1],P[2]+=p*q[2]):(s||f)&&(P[0]-=p*q[0],P[1]-=p*q[1],P[2]-=p*q[2]),l?(P[0]+=p*A[0]/H,P[1]+=p*A[1]/H,P[2]+=p*A[2]/H):m&&(P[0]-=p*A[0]/H,P[1]-=p*A[1]/H,P[2]-=p*A[2]/H),$()),window.requestAnimationFrame(V))}function $(){var e,n;q=[Math.cos(h)*Math.sin(g),Math.sin(h)*Math.sin(g),Math.cos(g)],A=function(t){let e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/e,t[1]/e,t[2]/e]}([q[1],-q[0],0]),n=q,k=[(e=A)[1]*n[2]-e[2]*n[1],e[2]*n[0]-e[0]*n[2],e[0]*n[1]-e[1]*n[0]],v=d,d=function(t,e,n){let o=[t,n,e],a=[o[0]+1,o[1]+1,o[2]+1],i=[o[0]-1,o[1]-1,o[2]-1],r=1e3,c=1,u=L,s=E,l=Math.sign(s);for(let t=0;t<M;t++){o[0]=o[0]+s/u*o[1],o[0]+=F,o[2]+=F,o[0]=o[0]-2*F*Math.floor(o[0]/(2*F))-F,o[2]=o[2]-2*F*Math.floor(o[2]/(2*F))-F,o[0]=o[0]-s/u*o[1],o[1]>=u*(.5+.25*l*Math.sign(o[0]+.5*s)*(1-Math.exp(-I*Math.abs(o[0]+.5*s))))&&(o[0]=-s-o[0],o[1]=u-o[1],o[2]=-o[2]);let t=1/K(o,o);if(o[0]*=-t,o[1]*=-t,o[2]*=-t,o[0]=-s-o[0],o[1]=u+o[1],c*=t,(o[0]-i[0])*(o[0]-i[0])+(o[1]-i[1])*(o[1]-i[1])+(o[2]-i[2])*(o[2]-i[2])<1e-7)break;i[0]=a[0],i[1]=a[1],i[2]=a[2],a[0]=o[0],a[1]=o[1],a[2]=o[2]}for(let t=0;t<5;t++){let t=Math.min(o[1],u-o[1]);r=Math.min(r,Math.min(t,1)/Math.max(c,1));let e=1/K(o,o);o[0]*=-e,o[1]*=-e,o[2]*=-e,o[0]=-s-o[0],o[1]=u+o[1],c*=e}let m=Math.min(o[1],u-o[1]);return r=Math.min(r,Math.min(m,1)/Math.max(c,1))}(P[0],P[1],P[2]),H=d/20,A[0]*=H/2,A[1]*=H/2,k[0]*=H/2,k[1]*=H/2,k[2]*=H/2,S=[P[0]+H*q[0],P[1]+H*q[1],P[2]+H*q[2]],t.uniform3fv(G.camera_pos_uniform,P),t.uniform3fv(G.image_plane_center_pos_uniform,S),t.uniform3fv(G.forward_vec_uniform,q),t.uniform3fv(G.right_vec_uniform,A),t.uniform3fv(G.up_vec_uniform,k),t.uniform1f(G.focal_length_uniform,H)}function K(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function J(){e=Math.min(document.querySelector("#output-canvas").offsetWidth,document.querySelector("#output-canvas").offsetHeight)}function Q(e=0){0===e?((y=parseInt(document.querySelector("#dim-input").value||300))<200&&(y=200),y>2e3&&(y=2e3),x=y,b=3*y):y=e,Page.Applets.Canvases.is_fullscreen&&(Page.Layout.aspect_ratio>=1?(z=y,w=Math.floor(y/Page.Layout.aspect_ratio)):(z=Math.floor(y*Page.Layout.aspect_ratio),w=y)),document.querySelector("#output-canvas").setAttribute("width",z),document.querySelector("#output-canvas").setAttribute("height",w),z>=w?(t.uniform1f(G.aspect_ratio_x_uniform,z/w),t.uniform1f(G.aspect_ratio_y_uniform,1)):(t.uniform1f(G.aspect_ratio_x_uniform,1),t.uniform1f(G.aspect_ratio_y_uniform,z/w)),t.uniform1i(G.image_size_uniform,y),t.viewport(0,0,z,w),window.requestAnimationFrame(V)}function Z(){y!==x&&Q(y=x),D=L,C=(parseFloat(document.querySelector("#klein-r-input").value||2)||2)-D,U=E,T=(parseFloat(document.querySelector("#klein-i-input").value||0)||0)-U,R=F,Y=(parseFloat(document.querySelector("#box-size-input").value||1)||1)-R,tt()}function tt(){o=!0,X=0,window.requestAnimationFrame(V)}}();