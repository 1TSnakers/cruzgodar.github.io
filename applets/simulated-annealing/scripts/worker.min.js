onmessage=async function(c){gridSize=c.data[0];numNodes=c.data[1];maximumSpeed=c.data[2];coolingFactor=1/(numNodes*numNodes*numNodes);await drawAnnealingGraph()};let gridSize=null,numNodes=null,maximumSpeed=null,initialTemperature=500,temperature=null,coolingFactor=null,nodes=[],currentPath=[],currentDistance=null;
async function drawAnnealingGraph(){nodes=[];currentPath=[];currentDistance=0;temperature=initialTemperature;let c=0;for(var a=0;a<numNodes;a++)nodes[a]=[Math.floor(Math.random()*gridSize),Math.floor(Math.random()*gridSize)],postMessage([0,nodes[a][1],nodes[a][0],4,"rgb(255, 0, 0)"]);for(a=0;a<numNodes;a++)currentPath[a]=a;for(a=0;a<numNodes-1;a++)postMessage([1,nodes[a][1],nodes[a][0],nodes[a+1][1],nodes[a+1][0],"rgb(255, 0, 0)"]),currentDistance+=euclideanDistance(a,a+1);postMessage([1,nodes[numNodes-
1][1],nodes[numNodes-1][0],nodes[0][1],nodes[0][0],"rgb(255, 0, 0)"]);for(currentDistance+=euclideanDistance(numNodes-1,0);.001<temperature;){a=[];a[0]=Math.floor(Math.random()*numNodes);a[1]=Math.floor(Math.random()*(numNodes-1));a[1]>=a[0]&&a[1]++;let d=0;var b=a[0]-1;let e=a[0]+1;-1===b&&(b=numNodes-1);e===numNodes&&(e=0);d-=euclideanDistance(currentPath[b],currentPath[a[0]]);d+=euclideanDistance(currentPath[b],currentPath[a[1]]);d-=euclideanDistance(currentPath[a[0]],currentPath[e]);d+=euclideanDistance(currentPath[a[1]],
currentPath[e]);b=a[1]-1;e=a[1]+1;-1===b&&(b=numNodes-1);e===numNodes&&(e=0);d-=euclideanDistance(currentPath[b],currentPath[a[1]]);d+=euclideanDistance(currentPath[b],currentPath[a[0]]);d-=euclideanDistance(currentPath[a[1]],currentPath[e]);d+=euclideanDistance(currentPath[a[0]],currentPath[e]);if(1===Math.abs(a[0]-a[1])||Math.abs(a[0]-a[1])===numNodes-1)d+=2*euclideanDistance(currentPath[a[0]],currentPath[a[1]]);b=-1/temperature*d;1E3<b?b=1E3:-1E3>b&&(b=-1E3);Math.random()<Math.min(1,Math.exp(b))&&
(b=currentPath[a[0]],currentPath[a[0]]=currentPath[a[1]],currentPath[a[1]]=b,currentDistance+=d,c++,maximumSpeed||0!==c%(numNodes*numNodes)||await drawLines());temperature*=1-coolingFactor}temperature=0;drawLines()}function euclideanDistance(c,a){return Math.sqrt((nodes[c][1]-nodes[a][1])*(nodes[c][1]-nodes[a][1])+(nodes[c][0]-nodes[a][0])*(nodes[c][0]-nodes[a][0]))}
function drawLines(){return new Promise(function(c,a){postMessage([2]);for(a=0;a<numNodes;a++)postMessage([0,nodes[a][1],nodes[a][0],4,`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);for(a=0;a<numNodes-1;a++)postMessage([1,nodes[currentPath[a]][1],nodes[currentPath[a]][0],nodes[currentPath[a+1]][1],nodes[currentPath[a+1]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-
temperature)/initialTemperature})`]);postMessage([1,nodes[currentPath[numNodes-1]][1],nodes[currentPath[numNodes-1]][0],nodes[currentPath[0]][1],nodes[currentPath[0]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);setTimeout(c,50)})};
