"use strict";onmessage=async function(e){gridSize=e.data[0],numNodes=e.data[1],maximumSpeed=e.data[2],coolingFactor=1/(numNodes*numNodes*numNodes),await drawAnnealingGraph()};let gridSize=null,numNodes=null,maximumSpeed=null,initialTemperature=500,temperature=null,coolingFactor=null,nodes=[],currentPath=[];async function drawAnnealingGraph(){nodes=[],currentPath=[],temperature=initialTemperature;let a=0;for(let e=0;e<numNodes;e++)nodes[e]=[Math.floor(Math.random()*gridSize),Math.floor(Math.random()*gridSize)],postMessage([0,nodes[e][1],nodes[e][0],4,"rgb(255, 0, 0)"]);for(let e=0;e<numNodes;e++)currentPath[e]=e;for(let e=0;e<numNodes-1;e++)postMessage([1,nodes[e][1],nodes[e][0],nodes[e+1][1],nodes[e+1][0],"rgb(255, 0, 0)"]);for(postMessage([1,nodes[numNodes-1][1],nodes[numNodes-1][0],nodes[0][1],nodes[0][0],"rgb(255, 0, 0)"]);.001<temperature;){var u=[];u[0]=Math.floor(Math.random()*numNodes),u[1]=Math.floor(Math.random()*(numNodes-1)),u[0]<=u[1]&&u[1]++;let e=0,t=u[0]-1,r=u[0]+1,n=(-1===t&&(t=numNodes-1),r===numNodes&&(r=0),e=(e=(e=(e-=euclideanDistance(currentPath[t],currentPath[u[0]]))+euclideanDistance(currentPath[t],currentPath[u[1]]))-euclideanDistance(currentPath[u[0]],currentPath[r]))+euclideanDistance(currentPath[u[1]],currentPath[r]),t=u[1]-1,r=u[1]+1,-1===t&&(t=numNodes-1),r===numNodes&&(r=0),e=(e=(e=(e-=euclideanDistance(currentPath[t],currentPath[u[1]]))+euclideanDistance(currentPath[t],currentPath[u[0]]))-euclideanDistance(currentPath[u[1]],currentPath[r]))+euclideanDistance(currentPath[u[0]],currentPath[r]),1!==Math.abs(u[0]-u[1])&&Math.abs(u[0]-u[1])!==numNodes-1||(e+=2*euclideanDistance(currentPath[u[0]],currentPath[u[1]])),-1/temperature*e);1e3<n?n=1e3:n<-1e3&&(n=-1e3);var s=Math.min(1,Math.exp(n));Math.random()<s&&(s=currentPath[u[0]],currentPath[u[0]]=currentPath[u[1]],currentPath[u[1]]=s,a++,maximumSpeed||a%(numNodes*numNodes)!=0||await drawLines()),temperature*=1-coolingFactor}temperature=0,drawLines()}function euclideanDistance(e,t){return Math.sqrt((nodes[e][1]-nodes[t][1])*(nodes[e][1]-nodes[t][1])+(nodes[e][0]-nodes[t][0])*(nodes[e][0]-nodes[t][0]))}async function drawLines(){postMessage([2]);for(let e=0;e<numNodes;e++)postMessage([0,nodes[e][1],nodes[e][0],4,`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);for(let e=0;e<numNodes-1;e++)postMessage([1,nodes[currentPath[e]][1],nodes[currentPath[e]][0],nodes[currentPath[e+1]][1],nodes[currentPath[e+1]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);postMessage([1,nodes[currentPath[numNodes-1]][1],nodes[currentPath[numNodes-1]][0],nodes[currentPath[0]][1],nodes[currentPath[0]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]),await new Promise(e=>setTimeout(e,50))}