"use strict";let gridSize=null,numNodes=null,maximumSpeed=null;const initialTemperature=500;let temperature=null,coolingFactor=null,nodes=[],currentPath=[];async function drawAnnealingGraph(){nodes=[],currentPath=[],temperature=initialTemperature;let a=0;for(let e=0;e<numNodes;e++)nodes[e]=[Math.floor(Math.random()*gridSize),Math.floor(Math.random()*gridSize)],postMessage([0,nodes[e][1],nodes[e][0],4,"rgb(255, 0, 0)"]);for(let n=0;n<numNodes;n++)currentPath[n]=n;for(let t=0;t<numNodes-1;t++)postMessage([1,nodes[t][1],nodes[t][0],nodes[t+1][1],nodes[t+1][0],"rgb(255, 0, 0)"]);for(postMessage([1,nodes[numNodes-1][1],nodes[numNodes-1][0],nodes[0][1],nodes[0][0],"rgb(255, 0, 0)"]);.001<temperature;){var o=[];o[0]=Math.floor(Math.random()*numNodes),o[1]=Math.floor(Math.random()*(numNodes-1)),o[0]<=o[1]&&o[1]++;let e=0,n=o[0]-1,t=o[0]+1,r=(-1===n&&(n=numNodes-1),t===numNodes&&(t=0),e=(e=(e=(e-=euclideanDistance(currentPath[n],currentPath[o[0]]))+euclideanDistance(currentPath[n],currentPath[o[1]]))-euclideanDistance(currentPath[o[0]],currentPath[t]))+euclideanDistance(currentPath[o[1]],currentPath[t]),n=o[1]-1,t=o[1]+1,-1===n&&(n=numNodes-1),t===numNodes&&(t=0),e=(e=(e=(e-=euclideanDistance(currentPath[n],currentPath[o[1]]))+euclideanDistance(currentPath[n],currentPath[o[0]]))-euclideanDistance(currentPath[o[1]],currentPath[t]))+euclideanDistance(currentPath[o[0]],currentPath[t]),1!==Math.abs(o[0]-o[1])&&Math.abs(o[0]-o[1])!==numNodes-1||(e+=2*euclideanDistance(currentPath[o[0]],currentPath[o[1]])),-1/temperature*e);1e3<r?r=1e3:r<-1e3&&(r=-1e3);var u=Math.min(1,Math.exp(r));Math.random()<u&&(u=currentPath[o[0]],currentPath[o[0]]=currentPath[o[1]],currentPath[o[1]]=u,a++,maximumSpeed||a%(numNodes*numNodes)!=0||await drawLines()),temperature*=1-coolingFactor}temperature=0,drawLines()}function euclideanDistance(node1Index,node2Index){return Math.sqrt((nodes[node1Index][1]-nodes[node2Index][1])*(nodes[node1Index][1]-nodes[node2Index][1])+(nodes[node1Index][0]-nodes[node2Index][0])*(nodes[node1Index][0]-nodes[node2Index][0]))}async function drawLines(){postMessage([2]);for(let e=0;e<numNodes;e++)postMessage([0,nodes[e][1],nodes[e][0],4,`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);for(let n=0;n<numNodes-1;n++)postMessage([1,nodes[currentPath[n]][1],nodes[currentPath[n]][0],nodes[currentPath[n+1]][1],nodes[currentPath[n+1]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);postMessage([1,nodes[currentPath[numNodes-1]][1],nodes[currentPath[numNodes-1]][0],nodes[currentPath[0]][1],nodes[currentPath[0]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]),await new Promise(resolve=>setTimeout(resolve,50))}onmessage=async function(e){gridSize=e.data[0],numNodes=e.data[1],maximumSpeed=e.data[2],coolingFactor=1/(numNodes*numNodes*numNodes),await drawAnnealingGraph()};