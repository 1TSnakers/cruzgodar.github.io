"use strict";let gridSize=null,numNodes=null,maximumSpeed=null;const initialTemperature=500;let temperature=null,coolingFactor=null,nodes=[],currentPath=[];async function drawAnnealingGraph(){nodes=[],currentPath=[],temperature=initialTemperature;let iteration=0;for(let i=0;i<numNodes;i++)nodes[i]=[Math.floor(Math.random()*gridSize),Math.floor(Math.random()*gridSize)],postMessage([0,nodes[i][1],nodes[i][0],4,"rgb(255, 0, 0)"]);for(let i=0;i<numNodes;i++)currentPath[i]=i;for(let i=0;i<numNodes-1;i++)postMessage([1,nodes[i][1],nodes[i][0],nodes[i+1][1],nodes[i+1][0],"rgb(255, 0, 0)"]);for(postMessage([1,nodes[numNodes-1][1],nodes[numNodes-1][0],nodes[0][1],nodes[0][0],"rgb(255, 0, 0)"]);.001<temperature;){var transposition=[];transposition[0]=Math.floor(Math.random()*numNodes),transposition[1]=Math.floor(Math.random()*(numNodes-1)),transposition[0]<=transposition[1]&&transposition[1]++;let distanceDifference=0,previousIndex=transposition[0]-1,nextIndex=transposition[0]+1,exponent=(-1===previousIndex&&(previousIndex=numNodes-1),nextIndex===numNodes&&(nextIndex=0),distanceDifference=(distanceDifference=(distanceDifference=(distanceDifference-=euclideanDistance(currentPath[previousIndex],currentPath[transposition[0]]))+euclideanDistance(currentPath[previousIndex],currentPath[transposition[1]]))-euclideanDistance(currentPath[transposition[0]],currentPath[nextIndex]))+euclideanDistance(currentPath[transposition[1]],currentPath[nextIndex]),previousIndex=transposition[1]-1,nextIndex=transposition[1]+1,-1===previousIndex&&(previousIndex=numNodes-1),nextIndex===numNodes&&(nextIndex=0),distanceDifference=(distanceDifference=(distanceDifference=(distanceDifference-=euclideanDistance(currentPath[previousIndex],currentPath[transposition[1]]))+euclideanDistance(currentPath[previousIndex],currentPath[transposition[0]]))-euclideanDistance(currentPath[transposition[1]],currentPath[nextIndex]))+euclideanDistance(currentPath[transposition[0]],currentPath[nextIndex]),1!==Math.abs(transposition[0]-transposition[1])&&Math.abs(transposition[0]-transposition[1])!==numNodes-1||(distanceDifference+=2*euclideanDistance(currentPath[transposition[0]],currentPath[transposition[1]])),-1/temperature*distanceDifference);1e3<exponent?exponent=1e3:exponent<-1e3&&(exponent=-1e3);var moveProb=Math.min(1,Math.exp(exponent));Math.random()<moveProb&&(moveProb=currentPath[transposition[0]],currentPath[transposition[0]]=currentPath[transposition[1]],currentPath[transposition[1]]=moveProb,iteration++,maximumSpeed||iteration%(numNodes*numNodes)!=0||await drawLines()),temperature*=1-coolingFactor}temperature=0,drawLines()}function euclideanDistance(node1Index,node2Index){return Math.sqrt((nodes[node1Index][1]-nodes[node2Index][1])*(nodes[node1Index][1]-nodes[node2Index][1])+(nodes[node1Index][0]-nodes[node2Index][0])*(nodes[node1Index][0]-nodes[node2Index][0]))}async function drawLines(){postMessage([2]);for(let i=0;i<numNodes;i++)postMessage([0,nodes[i][1],nodes[i][0],4,`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);for(let i=0;i<numNodes-1;i++)postMessage([1,nodes[currentPath[i]][1],nodes[currentPath[i]][0],nodes[currentPath[i+1]][1],nodes[currentPath[i+1]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]);postMessage([1,nodes[currentPath[numNodes-1]][1],nodes[currentPath[numNodes-1]][0],nodes[currentPath[0]][1],nodes[currentPath[0]][0],`rgb(255, ${255*(initialTemperature-temperature)/initialTemperature}, ${255*(initialTemperature-temperature)/initialTemperature})`]),await new Promise(resolve=>setTimeout(resolve,50))}onmessage=async function(e){gridSize=e.data[0],numNodes=e.data[1],maximumSpeed=e.data[2],coolingFactor=1/(numNodes*numNodes*numNodes),await drawAnnealingGraph()};