import anime from"/scripts/anime.min.js";import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class Mandelbulb extends RaymarchApplet{rotationAngleX=0;rotationAngleY=0;rotationAngleZ=0;constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:`
			vec3 z = pos;
			
			float r = length(z);
			float dr = 1.0;
			
			for (int iteration = 0; iteration < 16; iteration++)
			{
				if (r > 16.0)
				{
					break;
				}
				
				float theta = acos(z.z / r);
				
				float phi = atan(z.y, z.x);
				
				dr = pow(r, power - 1.0) * power * dr + 1.0;
				
				theta *= power;
				
				phi *= power;
				
				z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
				
				z += mix(pos, c, juliaProportion);
				
				z = rotationMatrix * z;
				
				r = length(z);
			}
			
			return .5 * log(r) * r / dr;
		`,getColorGlsl:`
			vec3 z = pos;
			
			float r = length(z);
			float dr = 1.0;
			
			vec3 color = vec3(1.0, 1.0, 1.0);
			float colorScale = .5;
			
			for (int iteration = 0; iteration < 100; iteration++)
			{
				if (r > 16.0)
				{
					break;
				}
				
				float theta = acos(z.z / r);
				
				float phi = atan(z.y, z.x);
				
				dr = pow(r, power - 1.0) * power * dr + 1.0;
				
				theta *= power;
				
				phi *= power;
				
				z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
				
				z += mix(pos, c, juliaProportion);
				
				z = rotationMatrix * z;
				
				r = length(z);
				
				color = mix(color, abs(z / r), colorScale);
				
				colorScale *= .5;
			}
			
			color /= max(max(color.x, color.y), color.z);
			
			return color;
		`,uniforms:{power:["float",8],c:["vec3",[0,0,0]],juliaProportion:["float",0],rotationMatrix:["mat3",[1,0,0,0,1,0,0,0,1]]},theta:4.6601,phi:2.272,cameraPos:[.0718,1.6264,1.4416],lightPos:[0,0,5]})}updateRotationMatrix(){var t=[[Math.cos(this.rotationAngleZ),-Math.sin(this.rotationAngleZ),0],[Math.sin(this.rotationAngleZ),Math.cos(this.rotationAngleZ),0],[0,0,1]],o=[[Math.cos(this.rotationAngleY),0,-Math.sin(this.rotationAngleY)],[0,1,0],[Math.sin(this.rotationAngleY),0,Math.cos(this.rotationAngleY)]],a=[[1,0,0],[0,Math.cos(this.rotationAngleX),-Math.sin(this.rotationAngleX)],[0,Math.sin(this.rotationAngleX),Math.cos(this.rotationAngleX)]],t=RaymarchApplet.matMul(RaymarchApplet.matMul(t,o),a);this.setUniform("rotationMatrix",[t[0][0],t[1][0],t[2][0],t[0][1],t[1][1],t[2][1],t[0][2],t[1][2],t[2][2]]),this.needNewFrame=!0}distanceEstimator(x,y,z){var t=[x,y,z];let o=0,a=1;var i=this.uniforms.c[1],r=this.uniforms.juliaProportion[1],n=this.uniforms.power[1];for(let M=0;M<16&&!(16<(o=Math.sqrt(RaymarchApplet.dotProduct(t,t))));M++){var e=Math.acos(t[2]/o),s=Math.atan2(t[1],t[0]),h=(a=Math.pow(o,n-1)*n*a+1,e*=n,s*=n,Math.pow(o,n)),s=(t[0]=h*Math.sin(e)*Math.cos(s)+((1-r)*x+r*i[0]),t[1]=h*Math.sin(e)*Math.sin(s)+((1-r)*y+r*i[1]),t[2]=h*Math.cos(e)+((1-r)*z+r*i[2]),t[0]),h=t[1],e=t[2],l=[[Math.cos(this.rotationAngleZ),-Math.sin(this.rotationAngleZ),0],[Math.sin(this.rotationAngleZ),Math.cos(this.rotationAngleZ),0],[0,0,1]],c=[[Math.cos(this.rotationAngleY),0,-Math.sin(this.rotationAngleY)],[0,1,0],[Math.sin(this.rotationAngleY),0,Math.cos(this.rotationAngleY)]],p=[[1,0,0],[0,Math.cos(this.rotationAngleX),-Math.sin(this.rotationAngleX)],[0,Math.sin(this.rotationAngleX),Math.cos(this.rotationAngleX)]],l=RaymarchApplet.matMul(RaymarchApplet.matMul(l,c),p);t[0]=l[0][0]*s+l[0][1]*h+l[0][2]*e,t[1]=l[1][0]*s+l[1][1]*h+l[1][2]*e,t[2]=l[2][0]*s+l[2][1]*h+l[2][2]*e}return.5*Math.log(o)*o/a}switchBulb(){const t={t:0},o=this.uniforms.juliaProportion[1],a=0===this.uniforms.juliaProportion[1]?1:0;anime({targets:t,t:1,duration:1e3,easing:"easeOutSine",update:()=>{this.setUniform("juliaProportion",(1-t.t)*o+t.t*a),this.needNewFrame=!0}})}}export{Mandelbulb};