!function(){"use strict";let e=`
  precision highp float;
  
  varying vec2 uv;
  
  uniform float aspectRatioX;
  uniform float aspectRatioY;
  
  uniform vec3 cameraPos;
  uniform vec3 imagePlaneCenterPos;
  uniform vec3 forwardVec;
  uniform vec3 rightVec;
  uniform vec3 upVec;
  
  uniform float focalLength;
  
  uniform vec3 lightPos;
  const float lightBrightness = 1.5;
  
  uniform int imageSize;
  
  uniform int drawSphere;
  
  uniform int maxIterations;
  
  
  
  const float clipDistance = 1000.0;
  uniform int maxMarches;
  uniform float stepFactor;
  const vec3 fogColor = vec3(0.0, 0.0, 0.0);
  const float fogScaling = .1;
  
  
  
  uniform mat3 rotationMatrix;
  
  uniform float power;
  uniform vec3 c;
  uniform float juliaProportion;
  
  
  
  float distanceEstimator(vec3 pos)
  {
   vec3 z = pos;
   
   float r = length(z);
   float dr = 1.0;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    float theta = acos(z.z / r);
    
    float phi = atan(z.y, z.x);
    
    dr = pow(r, power - 1.0) * power * dr + 1.0;
    
    theta *= power;
    
    phi *= power;
    
    z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
    
    z += mix(pos, c, juliaProportion);
    
    z = rotationMatrix * z;
    
    r = length(z);
   }
   
   
   
   float distance1 = .5 * log(r) * r / dr;
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    return distance2;
   }
   
   
   
   return distance1;
  }
  
  
  
  vec3 getColor(vec3 pos)
  {
   vec3 z = pos;
   
   float r = length(z);
   float dr = 1.0;
   
   vec3 color = vec3(1.0, 1.0, 1.0);
   float colorScale = .5;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    float theta = acos(z.z / r);
    
    float phi = atan(z.y, z.x);
    
    dr = pow(r, power - 1.0) * power * dr + 1.0;
    
    theta *= power;
    
    phi *= power;
    
    z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
    
    z += mix(pos, c, juliaProportion);
    
    z = rotationMatrix * z;
    
    r = length(z);
    
    color = mix(color, abs(z / r), colorScale);
    
    colorScale *= .5;
   }
   
   color /= max(max(color.x, color.y), color.z);
   
   
   
   float distance1 = .5 * log(r) * r / dr;
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    color = vec3(1.0, 1.0, 1.0);
   }
   
   
   
   return color;
  }
  
  
  
  vec3 getSurfaceNormal(vec3 pos)
  {
   float xStep1 = distanceEstimator(pos + vec3(.000001, 0.0, 0.0));
   float yStep1 = distanceEstimator(pos + vec3(0.0, .000001, 0.0));
   float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, .000001));
   
   float xStep2 = distanceEstimator(pos - vec3(.000001, 0.0, 0.0));
   float yStep2 = distanceEstimator(pos - vec3(0.0, .000001, 0.0));
   float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, .000001));
   
   return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
  }
  
  
  
  vec3 computeShading(vec3 pos, int iteration)
  {
   vec3 surfaceNormal = getSurfaceNormal(pos);
   
   vec3 lightDirection = normalize(lightPos - pos);
   
   float dotProduct = dot(surfaceNormal, lightDirection);
   
   float lightIntensity = lightBrightness * max(dotProduct, -.25 * dotProduct);
   
   //The last factor adds ambient occlusion.
   vec3 color = getColor(pos) * lightIntensity * max((1.0 - float(iteration) / float(maxMarches)), 0.0);
   
   
   
   //Apply fog.
   return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
  }
  
  
  
  vec3 raymarch(vec3 startPos)
  {
   //That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.
   vec3 rayDirectionVec = normalize(startPos - cameraPos) * .9 / stepFactor;
   
   vec3 finalColor = fogColor;
   
   float epsilon = 0.0;
   
   float t = 0.0;
   
   float lastDistance = 1000.0;
   
   //int slowedDown = 0;
   
   
   
   for (int iteration = 0; iteration < 1024; iteration++)
   {
    if (iteration == maxMarches)
    {
     break;
    }
    
    
    
    vec3 pos = startPos + t * rayDirectionVec;
    
    //This prevents overstepping, and is honestly a pretty clever fix.
    float distance = min(distanceEstimator(pos), lastDistance);
    lastDistance = distance;
    
    //This lowers the detail far away, which makes everything run nice and fast.
    epsilon = max(.0000006, .5 * t / float(imageSize));
    
    
    
    if (distance < epsilon)
    {
     finalColor = computeShading(pos, iteration);
     break;
    }
    
    //Uncomment to add aggressive understepping when close to the fractal boundary, which helps to prevent flickering but is a significant performance hit.
    /*
    else if (lastDistance / distance > .9999 && slowedDown == 0)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .125;
     
     slowedDown = 1;
    }
    
    else if (lastDistance / distance <= .9999 && slowedDown == 1)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .9;
     
     slowedDown = 0;
    }
    */
    
    else if (t > clipDistance)
    {
     break;
    }
    
    
    
    t += distance;
   }
   
   
   
   return finalColor;
  }
  
  
  
  void main(void)
  {
   //Uncomment to use 2x antialiasing.
   //vec3 finalColor = (raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize)))) / 4.0;
   
   gl_FragColor = vec4(raymarch(imagePlaneCenterPos + rightVec * uv.x * aspectRatioX + upVec * uv.y / aspectRatioY), 1.0);
  }
 `,t=new Wilson(Page.element.querySelector("#output-canvas"),{renderer:"gpu",shader:e,canvasWidth:500,canvasHeight:500,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:eP,mousedownCallback:eg,touchstartCallback:eg,mousedragCallback:eh,touchmoveCallback:eh,mouseupCallback:ev,touchendCallback:ev});t.render.initUniforms(["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","focalLength","lightPos","drawSphere","power","c","juliaProportion","rotationMatrix","maxMarches","stepFactor","maxIterations"]);let o=!1,$=!1,i=!1,n=!1,a=!1,r=!1,s=!1,c=!1,l=0,u=[0,0,0],_=[0,0,0],m=1,f=-1,p=4.6601,d=2.272,g=0,h=0,v=0,y=0,w=500,P=500,S=500,x=4,z=100,C=[],k=[],b=[],q=[],I=[.0828,2.17,1.8925],F=2,A=8,V=[0,0,0],E=[0,0,0],L=[0,0,0],R=0,D=0,M=0,T=0,B=1,N=8,j=0,X=0,Y=0,O=0,U=0,H=0,J=0,W=0,G=0,K=0,Q=Page.element.querySelector("#resolution-input");Q.addEventListener("input",eP);let Z=Page.element.querySelector("#iterations-input");Z.addEventListener("input",()=>{x=parseInt(Z.value||4),t.gl.uniform1i(t.uniforms.maxIterations,x),window.requestAnimationFrame(ef)});let ee=Page.element.querySelector("#view-distance-input");ee.addEventListener("input",()=>{z=Math.max(parseInt(ee.value||100),32),t.gl.uniform1i(t.uniforms.maxMarches,z),window.requestAnimationFrame(ef)});Page.element.querySelector("#download-button").addEventListener("click",()=>{t.gl.uniform1i(t.uniforms.maxMarches,1024),t.gl.uniform1f(t.uniforms.stepFactor,12),0===T?t.downloadFrame("the-mandelbulb.png"):t.downloadFrame("a-juliabulb.png"),t.gl.uniform1i(t.uniforms.maxMarches,z),t.gl.uniform1f(t.uniforms.stepFactor,1)});let et=Page.element.querySelector("#rotation-angle-x-input"),eo=Page.element.querySelector("#rotation-angle-y-input"),e$=Page.element.querySelector("#rotation-angle-z-input"),ei=Page.element.querySelector("#c-x-input"),en=Page.element.querySelector("#c-y-input"),ea=Page.element.querySelector("#c-z-input"),er=Page.element.querySelector("#power-input"),es=[et,eo,e$,ei,en,ea,er];for(let ec=0;ec<7;ec++)es[ec].addEventListener("input",e1);let el=Page.element.querySelector("#randomize-rotation-button");el.style.opacity=1,el.addEventListener("click",function e(t=!0){!o&&(O=R,U=D,H=M,J=2*Math.random()-1-O,W=2*Math.random()-1-U,G=2*Math.random()-1-H,et.value=Math.round((O+J)*1e6)/1e6,eo.value=Math.round((U+W)*1e6)/1e6,e$.value=Math.round((H+G)*1e6)/1e6,E[0]=V[0],E[1]=V[1],E[2]=V[2],L[0]=0,L[1]=0,L[2]=0,X=T,Y=0,N=A,j=0,t?eS():(R=O+J,D=U+W,M=H+G))});let eu=Page.element.querySelector("#randomize-c-button");eu.style.opacity=1,eu.addEventListener("click",function e(t=!0){!o&&(O=R,U=D,H=M,J=0,W=0,G=0,E[0]=V[0],E[1]=V[1],E[2]=V[2],L[0]=1.5*Math.random()-.75-E[0],L[1]=1.5*Math.random()-.75-E[1],L[2]=1.5*Math.random()-.75-E[2],ei.value=Math.round((E[0]+L[0])*1e6)/1e6,en.value=Math.round((E[1]+L[1])*1e6)/1e6,ea.value=Math.round((E[2]+L[2])*1e6)/1e6,X=T,Y=0,N=A,j=0,t?eS():(V[0]=E[0]+L[0],V[1]=E[1]+L[1],V[2]=E[2]+L[2]))});let e_=Page.element.querySelector("#switch-bulb-button");e_.style.opacity=1,e_.addEventListener("click",function e(){!o&&(Page.Animate.changeOpacity(e_,0,Site.opacityAnimationTime),setTimeout(()=>{0===X?e_.textContent="Switch to Mandelbulb":e_.textContent="Switch to Juliabulb",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(e_,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),0===T?(t.gl.uniform3fv(t.uniforms.c,V),B||t.gl.uniform1i(t.uniforms.drawSphere,1),setTimeout(()=>{Page.Animate.changeOpacity(em,1,Site.opacityAnimationTime)},Site.opacityAnimationTime)):(B=!0,t.gl.uniform1i(t.uniforms.drawSphere,0),Page.Animate.changeOpacity(em,0,Site.opacityAnimationTime)),Y=1-2*(X=T),N=A,j=0,O=R,U=D,H=M,J=0,W=0,G=0,E[0]=V[0],E[1]=V[1],E[2]=V[2],L[0]=0,L[1]=0,L[2]=0,eS())});let em=Page.element.querySelector("#switch-movement-button");function ef(e){let c=e-f;if(f=e,0===c)return;t.render.drawFrame();let w=!1,P,S,x,z,C;o&&(R=O+J*(P=.5*Math.sin(Math.PI*K/120-Math.PI/2)+.5),D=U+W*P,S=[[Math.cos(M=H+G*P),-Math.sin(M),0],[Math.sin(M),Math.cos(M),0],[0,0,1]],x=[[Math.cos(D),0,-Math.sin(D)],[0,1,0],[Math.sin(D),0,Math.cos(D)]],z=[[1,0,0],[0,Math.cos(R),-Math.sin(R)],[0,Math.sin(R),Math.cos(R)]],C=ed(ed(S,x),z),t.gl.uniformMatrix3fv(t.uniforms.rotationMatrix,!1,[C[0][0],C[1][0],C[2][0],C[0][1],C[1][1],C[2][1],C[0][2],C[1][2],C[2][2]]),V[0]=E[0]+L[0]*P,V[1]=E[1]+L[1]*P,V[2]=E[2]+L[2]*P,t.gl.uniform3fv(t.uniforms.c,V),A=N+j*P,t.gl.uniform1f(t.uniforms.power,A),T=X+Y*P,t.gl.uniform1f(t.uniforms.juliaProportion,T),121==++K&&(o=!1),w=!0),$||i||n||a||r||s?(function e(){if(l=Math.min(Math.max(1e-6,m/20),.02),B){let o=[...I];$||r?(I[0]+=l*k[0],I[1]+=l*k[1],I[2]+=l*k[2]):(i||s)&&(I[0]-=l*k[0],I[1]-=l*k[1],I[2]-=l*k[2]),n?(I[0]+=l*b[0]/F,I[1]+=l*b[1]/F,I[2]+=l*b[2]/F):a&&(I[0]-=l*b[0]/F,I[1]-=l*b[1]/F,I[2]-=l*b[2]/F),u[0]=I[0]-o[0],u[1]=I[1]-o[1],u[2]=I[2]-o[2]}else{let c=[...V];$||r?(V[0]+=.5*l*k[0],V[1]+=.5*l*k[1],V[2]+=.5*l*k[2]):(i||s)&&(V[0]-=.5*l*k[0],V[1]-=.5*l*k[1],V[2]-=.5*l*k[2]),n?(V[0]+=.5*l*b[0]/F,V[1]+=.5*l*b[1]/F,V[2]+=.5*l*b[2]/F):a&&(V[0]-=.5*l*b[0]/F,V[1]-=.5*l*b[1]/F,V[2]-=.5*l*b[2]/F),ei.value=Math.round(1e6*V[0])/1e6,en.value=Math.round(1e6*V[1])/1e6,ea.value=Math.round(1e6*V[2])/1e6,t.gl.uniform3fv(t.uniforms.c,V),u[0]=V[0]-c[0],u[1]=V[1]-c[1],u[2]=V[2]-c[2]}ep()}(),w=!0):c>=50&&(g=0,h=0,v=0,y=0,r=!1,s=!1,_[0]=0,_[1]=0,_[2]=0,u[0]=0,u[1]=0,u[2]=0),(0!==v||0!==y)&&(p+=v,d+=y,p>=2*Math.PI?p-=2*Math.PI:p<0&&(p+=2*Math.PI),d>Math.PI-.01?d=Math.PI-.01:d<.01&&(d=.01),5e-4>Math.sqrt((v*=.94)*v+(y*=.94)*y)&&(v=0,y=0),ep(),w=!0),(0!==_[0]||0!==_[1]||0!==_[2])&&(B?(I[0]+=_[0],I[1]+=_[1],I[2]+=_[2]):(V[0]+=_[0],V[1]+=_[1],V[2]+=_[2],ei.value=Math.round(1e6*V[0])/1e6,en.value=Math.round(1e6*V[1])/1e6,ea.value=Math.round(1e6*V[2])/1e6,t.gl.uniform3fv(t.uniforms.c,V)),_[0]*=.94,_[1]*=.94,_[2]*=.94,Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2])<5e-4*l&&(_[0]=0,_[1]=0,_[2]=0),ep(),w=!0),w&&window.requestAnimationFrame(ef)}function ep(){var e,o,$;let i;q=(o=b=(e=[(k=[Math.cos(p)*Math.sin(d),Math.sin(p)*Math.sin(d),Math.cos(d)])[1],-k[0],0],i=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),[e[0]/i,e[1]/i,e[2]/i]),$=k,[o[1]*$[2]-o[2]*$[1],o[2]*$[0]-o[0]*$[2],o[0]*$[1]-o[1]*$[0]]),F=(m=function e(t,o,$){let i=[t,o,$],n=0,a=1;for(let r=0;r<4*x&&!((n=Math.sqrt(e0(i,i)))>16);r++){let s=Math.acos(i[2]/n),c=Math.atan2(i[1],i[0]);a=Math.pow(n,A-1)*A*a+1,s*=A,c*=A;let l=Math.pow(n,A);i[0]=l*Math.sin(s)*Math.cos(c)+((1-T)*t+T*V[0]),i[1]=l*Math.sin(s)*Math.sin(c)+((1-T)*o+T*V[1]),i[2]=l*Math.cos(s)+((1-T)*$+T*V[2]);let u=i[0],_=i[1],m=i[2],f=[[Math.cos(M),-Math.sin(M),0],[Math.sin(M),Math.cos(M),0],[0,0,1]],p=[[Math.cos(D),0,-Math.sin(D)],[0,1,0],[Math.sin(D),0,Math.cos(D)]],d=[[1,0,0],[0,Math.cos(R),-Math.sin(R)],[0,Math.sin(R),Math.cos(R)]],g=ed(ed(f,p),d);i[0]=g[0][0]*u+g[0][1]*_+g[0][2]*m,i[1]=g[1][0]*u+g[1][1]*_+g[1][2]*m,i[2]=g[2][0]*u+g[2][1]*_+g[2][2]*m}return .5*Math.log(n)*n/a}(I[0],I[1],I[2]))/2,b[0]*=F/2,b[1]*=F/2,q[0]*=F/2,q[1]*=F/2,q[2]*=F/2,C=[I[0]+F*k[0],I[1]+F*k[1],I[2]+F*k[2]],t.gl.uniform3fv(t.uniforms.cameraPos,I),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,C),t.gl.uniform3fv(t.uniforms.forwardVec,k),t.gl.uniform3fv(t.uniforms.rightVec,b),t.gl.uniform3fv(t.uniforms.upVec,q),t.gl.uniform1f(t.uniforms.focalLength,F)}function e0(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function ed(e,t){return[[e[0][0]*t[0][0]+e[0][1]*t[1][0]+e[0][2]*t[2][0],e[0][0]*t[0][1]+e[0][1]*t[1][1]+e[0][2]*t[2][1],e[0][0]*t[0][2]+e[0][1]*t[1][2]+e[0][2]*t[2][2]],[e[1][0]*t[0][0]+e[1][1]*t[1][0]+e[1][2]*t[2][0],e[1][0]*t[0][1]+e[1][1]*t[1][1]+e[1][2]*t[2][1],e[1][0]*t[0][2]+e[1][1]*t[1][2]+e[1][2]*t[2][2]],[e[2][0]*t[0][0]+e[2][1]*t[1][0]+e[2][2]*t[2][0],e[2][0]*t[0][1]+e[2][1]*t[1][1]+e[2][2]*t[2][1],e[2][0]*t[0][2]+e[2][1]*t[1][2]+e[2][2]*t[2][2]]]}function eg(e,t,o){g=0,h=0,v=0,y=0,"touchstart"===o.type&&(2===o.touches.length?(r=!0,s=!1,_[0]=0,_[1]=0,_[2]=0,u[0]=0,u[1]=0,u[2]=0,window.requestAnimationFrame(ef)):3===o.touches.length?(r=!1,s=!0,_[0]=0,_[1]=0,_[2]=0,u[0]=0,u[1]=0,u[2]=0,window.requestAnimationFrame(ef)):(r=!1,s=!1),c=!1)}function eh(e,t,o,$,i){if("touchmove"===i.type&&c){c=!1;return}p+=o*Math.PI/2,g=o*Math.PI/2,p>=2*Math.PI?p-=2*Math.PI:p<0&&(p+=2*Math.PI),d+=$*Math.PI/2,h=$*Math.PI/2,d>Math.PI-.01?d=Math.PI-.01:d<.01&&(d=.01),ep(),window.requestAnimationFrame(ef)}function ev(e,t,o){"touchend"===o.type&&(r=!1,s=!1,c=!0,0===_[0]&&0===_[1]&&0===_[2]&&(_[0]=u[0],_[1]=u[1],_[2]=u[2],u[0]=0,u[1]=0,u[2]=0)),"touchend"===o.type&&o.touches,(0===length||"mouseup"===o.type)&&Math.sqrt(g*g+h*h)>=.005&&(v=g,y=h)}function ey(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode)&&(u=[0,0,0],_=[0,0,0],87===e.keyCode?$=!0:83===e.keyCode&&(i=!0),68===e.keyCode?n=!0:65===e.keyCode&&(a=!0),window.requestAnimationFrame(ef))}function ew(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode)&&(0===_[0]&&0===_[1]&&0===_[2]&&(_[0]=u[0],_[1]=u[1],_[2]=u[2],u[0]=0,u[1]=0,u[2]=0),87===e.keyCode?$=!1:83===e.keyCode&&(i=!1),68===e.keyCode?n=!1:65===e.keyCode&&(a=!1))}function eP(){w=Math.max(100,parseInt(Q.value||500)),t.fullscreen.currentlyFullscreen?Page.Layout.aspectRatio>=1?(P=w,S=Math.floor(w/Page.Layout.aspectRatio)):(P=Math.floor(w*Page.Layout.aspectRatio),S=w):(P=w,S=w),t.changeCanvasSize(P,S),P>=S?(t.gl.uniform1f(t.uniforms.aspectRatioX,P/S),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,P/S)),t.gl.uniform1i(t.uniforms.imageSize,w),window.requestAnimationFrame(ef)}function e1(){O=R,U=D,H=M,J=(parseFloat(et.value||0)||0)-O,W=(parseFloat(eo.value||0)||0)-U,G=(parseFloat(e$.value||0)||0)-H,E[0]=V[0],E[1]=V[1],E[2]=V[2],L[0]=(parseFloat(ei.value||0)||0)-E[0],L[1]=(parseFloat(en.value||0)||0)-E[1],L[2]=(parseFloat(ea.value||0)||0)-E[2],N=A,j=(parseFloat(er.value||0)||0)-N,X=T,Y=0,eS()}function eS(){o||(o=!0,K=0,window.requestAnimationFrame(ef))}em.style.opacity=0,em.addEventListener("click",function e(){B=!B,Page.Animate.changeOpacity(em,0,Site.opacityAnimationTime),setTimeout(()=>{B?em.textContent="Change Juliabulb":em.textContent="Move Camera",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(em,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),B?t.gl.uniform1i(t.uniforms.drawSphere,0):t.gl.uniform1i(t.uniforms.drawSphere,1)}),Page.Load.TextButtons.equalize(),ep(),P>=S?(t.gl.uniform1f(t.uniforms.aspectRatioX,P/S),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,P/S)),t.gl.uniform1i(t.uniforms.imageSize,w),t.gl.uniform3fv(t.uniforms.cameraPos,I),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,C),t.gl.uniform3fv(t.uniforms.lightPos,[0,0,5]),t.gl.uniform3fv(t.uniforms.forwardVec,k),t.gl.uniform3fv(t.uniforms.rightVec,b),t.gl.uniform3fv(t.uniforms.upVec,q),t.gl.uniform1f(t.uniforms.focalLength,F),t.gl.uniform1i(t.uniforms.drawSphere,0),t.gl.uniform1f(t.uniforms.power,8),t.gl.uniform3fv(t.uniforms.c,V),t.gl.uniform1f(t.uniforms.juliaProportion,0),t.gl.uniformMatrix3fv(t.uniforms.rotationMatrix,!1,[1,0,0,0,1,0,0,0,1]),t.gl.uniform1i(t.uniforms.maxMarches,z),t.gl.uniform1f(t.uniforms.stepFactor,1),t.gl.uniform1i(t.uniforms.maxIterations,x),window.requestAnimationFrame(ef),Page.show(),document.documentElement.addEventListener("keydown",ey),Page.temporaryHandlers.keydown.push(ey),document.documentElement.addEventListener("keyup",ew),Page.temporaryHandlers.keydown.push(ew)}();