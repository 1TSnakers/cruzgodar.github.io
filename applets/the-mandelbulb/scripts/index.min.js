!function(){"use strict";let e=`
  precision highp float;
  
  varying vec2 uv;
  
  uniform float aspectRatioX;
  uniform float aspectRatioY;
  
  uniform vec3 cameraPos;
  uniform vec3 imagePlaneCenterPos;
  uniform vec3 forwardVec;
  uniform vec3 rightVec;
  uniform vec3 upVec;
  
  uniform float focalLength;
  
  uniform vec3 lightPos;
  const float lightBrightness = 1.5;
  
  uniform int imageSize;
  
  uniform int drawSphere;
  
  uniform int maxIterations;
  
  
  
  const float clipDistance = 1000.0;
  uniform int maxMarches;
  uniform float stepFactor;
  const vec3 fogColor = vec3(0.0, 0.0, 0.0);
  const float fogScaling = .1;
  
  
  
  uniform mat3 rotationMatrix;
  
  uniform float power;
  uniform vec3 c;
  uniform float juliaProportion;
  
  
  
  float distanceEstimator(vec3 pos)
  {
   vec3 z = pos;
   
   float r = length(z);
   float dr = 1.0;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    float theta = acos(z.z / r);
    
    float phi = atan(z.y, z.x);
    
    dr = pow(r, power - 1.0) * power * dr + 1.0;
    
    theta *= power;
    
    phi *= power;
    
    z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
    
    z += mix(pos, c, juliaProportion);
    
    z = rotationMatrix * z;
    
    r = length(z);
   }
   
   
   
   float distance1 = .5 * log(r) * r / dr;
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    return distance2;
   }
   
   
   
   return distance1;
  }
  
  
  
  vec3 getColor(vec3 pos)
  {
   vec3 z = pos;
   
   float r = length(z);
   float dr = 1.0;
   
   vec3 color = vec3(1.0, 1.0, 1.0);
   float colorScale = .5;
   
   for (int iteration = 0; iteration < 100; iteration++)
   {
    if (r > 16.0 || iteration >= maxIterations)
    {
     break;
    }
    
    float theta = acos(z.z / r);
    
    float phi = atan(z.y, z.x);
    
    dr = pow(r, power - 1.0) * power * dr + 1.0;
    
    theta *= power;
    
    phi *= power;
    
    z = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));
    
    z += mix(pos, c, juliaProportion);
    
    z = rotationMatrix * z;
    
    r = length(z);
    
    color = mix(color, abs(z / r), colorScale);
    
    colorScale *= .5;
   }
   
   color /= max(max(color.x, color.y), color.z);
   
   
   
   float distance1 = .5 * log(r) * r / dr;
   float distance2 = length(pos - c) - .05;
   
   
   
   if (distance2 < distance1 && drawSphere == 1)
   {
    color = vec3(1.0, 1.0, 1.0);
   }
   
   
   
   return color;
  }
  
  
  
  vec3 getSurfaceNormal(vec3 pos)
  {
   float xStep1 = distanceEstimator(pos + vec3(.000001, 0.0, 0.0));
   float yStep1 = distanceEstimator(pos + vec3(0.0, .000001, 0.0));
   float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, .000001));
   
   float xStep2 = distanceEstimator(pos - vec3(.000001, 0.0, 0.0));
   float yStep2 = distanceEstimator(pos - vec3(0.0, .000001, 0.0));
   float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, .000001));
   
   return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
  }
  
  
  
  vec3 computeShading(vec3 pos, int iteration)
  {
   vec3 surfaceNormal = getSurfaceNormal(pos);
   
   vec3 lightDirection = normalize(lightPos - pos);
   
   float dotProduct = dot(surfaceNormal, lightDirection);
   
   float lightIntensity = lightBrightness * max(dotProduct, -.25 * dotProduct);
   
   //The last factor adds ambient occlusion.
   vec3 color = getColor(pos) * lightIntensity * max((1.0 - float(iteration) / float(maxMarches)), 0.0);
   
   
   
   //Apply fog.
   return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
  }
  
  
  
  vec3 raymarch(vec3 startPos)
  {
   //That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.
   vec3 rayDirectionVec = normalize(startPos - cameraPos) * .9 / stepFactor;
   
   vec3 finalColor = fogColor;
   
   float epsilon = 0.0;
   
   float t = 0.0;
   
   float lastDistance = 1000.0;
   
   //int slowedDown = 0;
   
   
   
   for (int iteration = 0; iteration < 1024; iteration++)
   {
    if (iteration == maxMarches)
    {
     break;
    }
    
    
    
    vec3 pos = startPos + t * rayDirectionVec;
    
    //This prevents overstepping, and is honestly a pretty clever fix.
    float distance = min(distanceEstimator(pos), lastDistance);
    lastDistance = distance;
    
    //This lowers the detail far away, which makes everything run nice and fast.
    epsilon = max(.0000006, .5 * t / float(imageSize));
    
    
    
    if (distance < epsilon)
    {
     finalColor = computeShading(pos, iteration);
     break;
    }
    
    //Uncomment to add aggressive understepping when close to the fractal boundary, which helps to prevent flickering but is a significant performance hit.
    /*
    else if (lastDistance / distance > .9999 && slowedDown == 0)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .125;
     
     slowedDown = 1;
    }
    
    else if (lastDistance / distance <= .9999 && slowedDown == 1)
    {
     rayDirectionVec = normalize(startPos - cameraPos) * .9;
     
     slowedDown = 0;
    }
    */
    
    else if (t > clipDistance)
    {
     break;
    }
    
    
    
    t += distance;
   }
   
   
   
   return finalColor;
  }
  
  
  
  void main(void)
  {
   //Uncomment to use 2x antialiasing.
   //vec3 finalColor = (raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio + .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y + .5 / float(imageSize))) + raymarch(imagePlaneCenterPos + rightVec * (uv.x * aspectRatio - .5 / float(imageSize)) + upVec * (uv.y - .5 / float(imageSize)))) / 4.0;
   
   gl_FragColor = vec4(raymarch(imagePlaneCenterPos + rightVec * uv.x * aspectRatioX + upVec * uv.y / aspectRatioY), 1.0);
  }
 `,t=new Wilson($("#output-canvas"),{renderer:"gpu",shader:e,canvasWidth:500,canvasHeight:500,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:e1,mousedownCallback:eh,touchstartCallback:eh,mousedragCallback:ev,touchmoveCallback:ev,mouseupCallback:ey,touchendCallback:ey});t.render.initUniforms(["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","focalLength","lightPos","drawSphere","power","c","juliaProportion","rotationMatrix","maxMarches","stepFactor","maxIterations"]);let o=!1,i=!1,a=!1,n=!1,r=!1,s=!1,c=!1,l=!1,_=0,u=[0,0,0],m=[0,0,0],f=1,p=-1,d=4.6601,g=2.272,h=0,v=0,y=0,w=0,P=500,x=500,z=500,C=4,S=100,k=[],b=[],I=[],F=[],A=[.0828,2.17,1.8925],V=2,E=8,L=[0,0,0],R=[0,0,0],q=[0,0,0],D=0,M=0,T=0,B=0,N=1,j=8,X=0,Y=0,O=0,U=0,H=0,J=0,W=0,G=0,K=0,Q=0,Z=$("#resolution-input");Z.addEventListener("input",e1);let ee=$("#iterations-input");ee.addEventListener("input",()=>{C=parseInt(ee.value||4),t.gl.uniform1i(t.uniforms.maxIterations,C),window.requestAnimationFrame(ep)});let et=$("#view-distance-input");et.addEventListener("input",()=>{S=Math.max(parseInt(et.value||100),32),t.gl.uniform1i(t.uniforms.maxMarches,S),window.requestAnimationFrame(ep)});$("#download-button").addEventListener("click",()=>{t.gl.uniform1i(t.uniforms.maxMarches,1024),t.gl.uniform1f(t.uniforms.stepFactor,12),0===B?t.downloadFrame("the-mandelbulb.png"):t.downloadFrame("a-juliabulb.png"),t.gl.uniform1i(t.uniforms.maxMarches,S),t.gl.uniform1f(t.uniforms.stepFactor,1)});let eo=$("#rotation-angle-x-input"),e$=$("#rotation-angle-y-input"),ei=$("#rotation-angle-z-input"),ea=$("#c-x-input"),en=$("#c-y-input"),er=$("#c-z-input"),es=$("#power-input"),ec=[eo,e$,ei,ea,en,er,es];for(let el=0;el<7;el++)ec[el].addEventListener("input",ex);let e_=$("#randomize-rotation-button");e_.style.opacity=1,e_.addEventListener("click",function e(t=!0){!o&&(U=D,H=M,J=T,W=2*Math.random()-1-U,G=2*Math.random()-1-H,K=2*Math.random()-1-J,eo.value=Math.round((U+W)*1e6)/1e6,e$.value=Math.round((H+G)*1e6)/1e6,ei.value=Math.round((J+K)*1e6)/1e6,R[0]=L[0],R[1]=L[1],R[2]=L[2],q[0]=0,q[1]=0,q[2]=0,Y=B,O=0,j=E,X=0,t?e3():(D=U+W,M=H+G,T=J+K))});let eu=$("#randomize-c-button");eu.style.opacity=1,eu.addEventListener("click",function e(t=!0){!o&&(U=D,H=M,J=T,W=0,G=0,K=0,R[0]=L[0],R[1]=L[1],R[2]=L[2],q[0]=1.5*Math.random()-.75-R[0],q[1]=1.5*Math.random()-.75-R[1],q[2]=1.5*Math.random()-.75-R[2],ea.value=Math.round((R[0]+q[0])*1e6)/1e6,en.value=Math.round((R[1]+q[1])*1e6)/1e6,er.value=Math.round((R[2]+q[2])*1e6)/1e6,Y=B,O=0,j=E,X=0,t?e3():(L[0]=R[0]+q[0],L[1]=R[1]+q[1],L[2]=R[2]+q[2]))});let em=$("#switch-bulb-button");em.style.opacity=1,em.addEventListener("click",function e(){!o&&(Page.Animate.changeOpacity(em,0,Site.opacityAnimationTime),setTimeout(()=>{0===Y?em.textContent="Switch to Mandelbulb":em.textContent="Switch to Juliabulb",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(em,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),0===B?(t.gl.uniform3fv(t.uniforms.c,L),N||t.gl.uniform1i(t.uniforms.drawSphere,1),setTimeout(()=>{Page.Animate.changeOpacity(ef,1,Site.opacityAnimationTime)},Site.opacityAnimationTime)):(N=!0,t.gl.uniform1i(t.uniforms.drawSphere,0),Page.Animate.changeOpacity(ef,0,Site.opacityAnimationTime)),O=1-2*(Y=B),j=E,X=0,U=D,H=M,J=T,W=0,G=0,K=0,R[0]=L[0],R[1]=L[1],R[2]=L[2],q[0]=0,q[1]=0,q[2]=0,e3())});let ef=$("#switch-movement-button");function ep(e){let l=e-p;if(p=e,0===l)return;t.render.drawFrame();let P=!1,x,z,C,S,k;o&&(D=U+W*(x=.5*Math.sin(Math.PI*Q/120-Math.PI/2)+.5),M=H+G*x,z=[[Math.cos(T=J+K*x),-Math.sin(T),0],[Math.sin(T),Math.cos(T),0],[0,0,1]],C=[[Math.cos(M),0,-Math.sin(M)],[0,1,0],[Math.sin(M),0,Math.cos(M)]],S=[[1,0,0],[0,Math.cos(D),-Math.sin(D)],[0,Math.sin(D),Math.cos(D)]],k=eg(eg(z,C),S),t.gl.uniformMatrix3fv(t.uniforms.rotationMatrix,!1,[k[0][0],k[1][0],k[2][0],k[0][1],k[1][1],k[2][1],k[0][2],k[1][2],k[2][2]]),L[0]=R[0]+q[0]*x,L[1]=R[1]+q[1]*x,L[2]=R[2]+q[2]*x,t.gl.uniform3fv(t.uniforms.c,L),E=j+X*x,t.gl.uniform1f(t.uniforms.power,E),B=Y+O*x,t.gl.uniform1f(t.uniforms.juliaProportion,B),121==++Q&&(o=!1),P=!0),i||a||n||r||s||c?(function e(){if(_=Math.min(Math.max(1e-6,f/20),.02),N){let o=[...A];i||s?(A[0]+=_*b[0],A[1]+=_*b[1],A[2]+=_*b[2]):(a||c)&&(A[0]-=_*b[0],A[1]-=_*b[1],A[2]-=_*b[2]),n?(A[0]+=_*I[0]/V,A[1]+=_*I[1]/V,A[2]+=_*I[2]/V):r&&(A[0]-=_*I[0]/V,A[1]-=_*I[1]/V,A[2]-=_*I[2]/V),u[0]=A[0]-o[0],u[1]=A[1]-o[1],u[2]=A[2]-o[2]}else{let l=[...L];i||s?(L[0]+=.5*_*b[0],L[1]+=.5*_*b[1],L[2]+=.5*_*b[2]):(a||c)&&(L[0]-=.5*_*b[0],L[1]-=.5*_*b[1],L[2]-=.5*_*b[2]),n?(L[0]+=.5*_*I[0]/V,L[1]+=.5*_*I[1]/V,L[2]+=.5*_*I[2]/V):r&&(L[0]-=.5*_*I[0]/V,L[1]-=.5*_*I[1]/V,L[2]-=.5*_*I[2]/V),ea.value=Math.round(1e6*L[0])/1e6,en.value=Math.round(1e6*L[1])/1e6,er.value=Math.round(1e6*L[2])/1e6,t.gl.uniform3fv(t.uniforms.c,L),u[0]=L[0]-l[0],u[1]=L[1]-l[1],u[2]=L[2]-l[2]}e0()}(),P=!0):l>=50&&(h=0,v=0,y=0,w=0,s=!1,c=!1,m[0]=0,m[1]=0,m[2]=0,u[0]=0,u[1]=0,u[2]=0),(0!==y||0!==w)&&(d+=y,g+=w,d>=2*Math.PI?d-=2*Math.PI:d<0&&(d+=2*Math.PI),g>Math.PI-.01?g=Math.PI-.01:g<.01&&(g=.01),5e-4>Math.sqrt((y*=.94)*y+(w*=.94)*w)&&(y=0,w=0),e0(),P=!0),(0!==m[0]||0!==m[1]||0!==m[2])&&(N?(A[0]+=m[0],A[1]+=m[1],A[2]+=m[2]):(L[0]+=m[0],L[1]+=m[1],L[2]+=m[2],ea.value=Math.round(1e6*L[0])/1e6,en.value=Math.round(1e6*L[1])/1e6,er.value=Math.round(1e6*L[2])/1e6,t.gl.uniform3fv(t.uniforms.c,L)),m[0]*=.94,m[1]*=.94,m[2]*=.94,Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2])<5e-4*_&&(m[0]=0,m[1]=0,m[2]=0),e0(),P=!0),P&&window.requestAnimationFrame(ep)}function e0(){var e,o,i;let a;F=(o=I=(e=[(b=[Math.cos(d)*Math.sin(g),Math.sin(d)*Math.sin(g),Math.cos(g)])[1],-b[0],0],a=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),[e[0]/a,e[1]/a,e[2]/a]),i=b,[o[1]*i[2]-o[2]*i[1],o[2]*i[0]-o[0]*i[2],o[0]*i[1]-o[1]*i[0]]),V=(f=function e(t,o,i){let a=[t,o,i],n=0,r=1;for(let s=0;s<4*C&&!((n=Math.sqrt(ed(a,a)))>16);s++){let c=Math.acos(a[2]/n),l=Math.atan2(a[1],a[0]);r=Math.pow(n,E-1)*E*r+1,c*=E,l*=E;let _=Math.pow(n,E);a[0]=_*Math.sin(c)*Math.cos(l)+((1-B)*t+B*L[0]),a[1]=_*Math.sin(c)*Math.sin(l)+((1-B)*o+B*L[1]),a[2]=_*Math.cos(c)+((1-B)*i+B*L[2]);let u=a[0],m=a[1],f=a[2],p=[[Math.cos(T),-Math.sin(T),0],[Math.sin(T),Math.cos(T),0],[0,0,1]],d=[[Math.cos(M),0,-Math.sin(M)],[0,1,0],[Math.sin(M),0,Math.cos(M)]],g=[[1,0,0],[0,Math.cos(D),-Math.sin(D)],[0,Math.sin(D),Math.cos(D)]],h=eg(eg(p,d),g);a[0]=h[0][0]*u+h[0][1]*m+h[0][2]*f,a[1]=h[1][0]*u+h[1][1]*m+h[1][2]*f,a[2]=h[2][0]*u+h[2][1]*m+h[2][2]*f}return .5*Math.log(n)*n/r}(A[0],A[1],A[2]))/2,I[0]*=V/2,I[1]*=V/2,F[0]*=V/2,F[1]*=V/2,F[2]*=V/2,k=[A[0]+V*b[0],A[1]+V*b[1],A[2]+V*b[2]],t.gl.uniform3fv(t.uniforms.cameraPos,A),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,k),t.gl.uniform3fv(t.uniforms.forwardVec,b),t.gl.uniform3fv(t.uniforms.rightVec,I),t.gl.uniform3fv(t.uniforms.upVec,F),t.gl.uniform1f(t.uniforms.focalLength,V)}function ed(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function eg(e,t){return[[e[0][0]*t[0][0]+e[0][1]*t[1][0]+e[0][2]*t[2][0],e[0][0]*t[0][1]+e[0][1]*t[1][1]+e[0][2]*t[2][1],e[0][0]*t[0][2]+e[0][1]*t[1][2]+e[0][2]*t[2][2]],[e[1][0]*t[0][0]+e[1][1]*t[1][0]+e[1][2]*t[2][0],e[1][0]*t[0][1]+e[1][1]*t[1][1]+e[1][2]*t[2][1],e[1][0]*t[0][2]+e[1][1]*t[1][2]+e[1][2]*t[2][2]],[e[2][0]*t[0][0]+e[2][1]*t[1][0]+e[2][2]*t[2][0],e[2][0]*t[0][1]+e[2][1]*t[1][1]+e[2][2]*t[2][1],e[2][0]*t[0][2]+e[2][1]*t[1][2]+e[2][2]*t[2][2]]]}function eh(e,t,o){h=0,v=0,y=0,w=0,"touchstart"===o.type&&(2===o.touches.length?(s=!0,c=!1,m[0]=0,m[1]=0,m[2]=0,u[0]=0,u[1]=0,u[2]=0,window.requestAnimationFrame(ep)):3===o.touches.length?(s=!1,c=!0,m[0]=0,m[1]=0,m[2]=0,u[0]=0,u[1]=0,u[2]=0,window.requestAnimationFrame(ep)):(s=!1,c=!1),l=!1)}function ev(e,t,o,i,a){if("touchmove"===a.type&&l){l=!1;return}d+=o*Math.PI/2,h=o*Math.PI/2,d>=2*Math.PI?d-=2*Math.PI:d<0&&(d+=2*Math.PI),g+=i*Math.PI/2,v=i*Math.PI/2,g>Math.PI-.01?g=Math.PI-.01:g<.01&&(g=.01),e0(),window.requestAnimationFrame(ep)}function ey(e,t,o){"touchend"===o.type&&(s=!1,c=!1,l=!0,0===m[0]&&0===m[1]&&0===m[2]&&(m[0]=u[0],m[1]=u[1],m[2]=u[2],u[0]=0,u[1]=0,u[2]=0)),"touchend"===o.type&&o.touches,(0===length||"mouseup"===o.type)&&Math.sqrt(h*h+v*v)>=.005&&(y=h,w=v)}function ew(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode)&&(u=[0,0,0],m=[0,0,0],87===e.keyCode?i=!0:83===e.keyCode&&(a=!0),68===e.keyCode?n=!0:65===e.keyCode&&(r=!0),window.requestAnimationFrame(ep))}function eP(e){"INPUT"!==document.activeElement.tagName&&(87===e.keyCode||83===e.keyCode||68===e.keyCode||65===e.keyCode)&&(0===m[0]&&0===m[1]&&0===m[2]&&(m[0]=u[0],m[1]=u[1],m[2]=u[2],u[0]=0,u[1]=0,u[2]=0),87===e.keyCode?i=!1:83===e.keyCode&&(a=!1),68===e.keyCode?n=!1:65===e.keyCode&&(r=!1))}function e1(){P=Math.max(100,parseInt(Z.value||500)),t.fullscreen.currentlyFullscreen?Page.Layout.aspectRatio>=1?(x=P,z=Math.floor(P/Page.Layout.aspectRatio)):(x=Math.floor(P*Page.Layout.aspectRatio),z=P):(x=P,z=P),t.changeCanvasSize(x,z),x>=z?(t.gl.uniform1f(t.uniforms.aspectRatioX,x/z),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,x/z)),t.gl.uniform1i(t.uniforms.imageSize,P),window.requestAnimationFrame(ep)}function ex(){U=D,H=M,J=T,W=(parseFloat(eo.value||0)||0)-U,G=(parseFloat(e$.value||0)||0)-H,K=(parseFloat(ei.value||0)||0)-J,R[0]=L[0],R[1]=L[1],R[2]=L[2],q[0]=(parseFloat(ea.value||0)||0)-R[0],q[1]=(parseFloat(en.value||0)||0)-R[1],q[2]=(parseFloat(er.value||0)||0)-R[2],j=E,X=(parseFloat(es.value||0)||0)-j,Y=B,O=0,e3()}function e3(){o||(o=!0,Q=0,window.requestAnimationFrame(ep))}ef.style.opacity=0,ef.addEventListener("click",function e(){N=!N,Page.Animate.changeOpacity(ef,0,Site.opacityAnimationTime),setTimeout(()=>{N?ef.textContent="Change Juliabulb":ef.textContent="Move Camera",Page.Load.TextButtons.equalize(),Page.Animate.changeOpacity(ef,1,Site.opacityAnimationTime)},Site.opacityAnimationTime),N?t.gl.uniform1i(t.uniforms.drawSphere,0):t.gl.uniform1i(t.uniforms.drawSphere,1)}),Page.Load.TextButtons.equalize(),e0(),x>=z?(t.gl.uniform1f(t.uniforms.aspectRatioX,x/z),t.gl.uniform1f(t.uniforms.aspectRatioY,1)):(t.gl.uniform1f(t.uniforms.aspectRatioX,1),t.gl.uniform1f(t.uniforms.aspectRatioY,x/z)),t.gl.uniform1i(t.uniforms.imageSize,P),t.gl.uniform3fv(t.uniforms.cameraPos,A),t.gl.uniform3fv(t.uniforms.imagePlaneCenterPos,k),t.gl.uniform3fv(t.uniforms.lightPos,[0,0,5]),t.gl.uniform3fv(t.uniforms.forwardVec,b),t.gl.uniform3fv(t.uniforms.rightVec,I),t.gl.uniform3fv(t.uniforms.upVec,F),t.gl.uniform1f(t.uniforms.focalLength,V),t.gl.uniform1i(t.uniforms.drawSphere,0),t.gl.uniform1f(t.uniforms.power,8),t.gl.uniform3fv(t.uniforms.c,L),t.gl.uniform1f(t.uniforms.juliaProportion,0),t.gl.uniformMatrix3fv(t.uniforms.rotationMatrix,!1,[1,0,0,0,1,0,0,0,1]),t.gl.uniform1i(t.uniforms.maxMarches,S),t.gl.uniform1f(t.uniforms.stepFactor,1),t.gl.uniform1i(t.uniforms.maxIterations,C),window.requestAnimationFrame(ep),Page.show(),document.documentElement.addEventListener("keydown",ew),Page.temporaryHandlers.keydown.push(ew),document.documentElement.addEventListener("keyup",eP),Page.temporaryHandlers.keydown.push(eP)}();