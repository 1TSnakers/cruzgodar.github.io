!function(){"use strict";let t=document.querySelector("#output-canvas").getContext("webgl"),e=document.querySelector("#output-canvas").offsetWidth,n=!1,o=!1,i=!1,a=0,r=0,c=!1,u=!1,s=!1,l=!1,m=!1,f=!1,_=0,d=1,p=3.3233,h=2.1272,g=500,v=32,w=[],y=[],b=[],S=[],M=[3.0191,.5918,1.9128],q=8,A=[0,0,0],L=0,z=0,P=0,E=0,I=0,x=2,k=[0,0,5],T=0;Y(),document.querySelector("#output-canvas").setAttribute("width",g),document.querySelector("#output-canvas").setAttribute("height",g),document.querySelector("#dim-input").addEventListener("input",function(){(g=parseInt(document.querySelector("#dim-input").value||500))<200&&(g=200);g>2e3&&(g=2e3);t.uniform1i(C.small_image_size_uniform,g),document.querySelector("#output-canvas").setAttribute("width",g),document.querySelector("#output-canvas").setAttribute("height",g),t.viewport(0,0,g,g),window.requestAnimationFrame(D)}),document.querySelector("#generate-high-res-image-button").addEventListener("click",function(){let e=g;g=parseInt(document.querySelector("#high-res-dim-input").value||2e3),document.querySelector("#output-canvas").setAttribute("width",g),document.querySelector("#output-canvas").setAttribute("height",g),t.viewport(0,0,g,g),D();let n=document.createElement("a");n.download=0===L?"the-mandelbulb.png":"a-juliabulb.png";n.href=document.querySelector("#output-canvas").toDataURL(),n.click(),n.remove(),g=e,document.querySelector("#output-canvas").setAttribute("width",g),document.querySelector("#output-canvas").setAttribute("height",g),t.viewport(0,0,g,g),D()}),document.querySelector("#power-input").addEventListener("input",function(){if(o)return;z=q,P=(parseFloat(document.querySelector("#power-input").value)||8)-z,z+P<1&&(P=0);E=L,I=0,B()}),document.querySelector("#switch-bulb-button").addEventListener("click",function(){if(o)return;document.querySelector("#switch-bulb-button").style.opacity=0,setTimeout(function(){document.querySelector("#switch-bulb-button").textContent=0===E?"Switch to Mandelbulb":"Switch to Juliabulb",document.querySelector("#switch-bulb-button").style.opacity=1},300),0===L&&(A=[...M]);I=1-2*(E=L),z=q,P=0,B()}),window.addEventListener("resize",X),setTimeout(X,500),document.querySelector("#output-canvas").addEventListener("mousedown",function(t){i=!0,a=t.clientX,r=t.clientY,n||o||(n=!0,window.requestAnimationFrame(D))}),document.querySelector("#output-canvas").addEventListener("mousemove",function(t){if(i){t.preventDefault();let n=t.clientX,o=t.clientY,i=n-a,c=o-r;(p+=i/e*Math.PI)>=2*Math.PI?p-=2*Math.PI:p<0&&(p+=2*Math.PI),(h-=c/e*Math.PI)>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),a=n,r=o,Y()}}),document.documentElement.addEventListener("mouseup",function(t){n=(i=!1)||c||u||s||l||m||f}),document.querySelector("#output-canvas").addEventListener("touchstart",function(t){i=!0,a=t.touches[0].clientX,r=t.touches[0].clientY,2===t.touches.length?(m=!0,f=!1):3===t.touches.length&&(f=!0,m=!1),n||o||(n=!0,window.requestAnimationFrame(D))}),document.querySelector("#output-canvas").addEventListener("touchmove",function(t){t.preventDefault();let n=t.touches[0].clientX,o=t.touches[0].clientY,i=n-a,c=o-r;Math.abs(i)>20||Math.abs(c)>20||((p+=i/e*Math.PI)>=2*Math.PI?p-=2*Math.PI:p<0&&(p+=2*Math.PI),(h-=c/e*Math.PI)>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),a=n,r=o,Y())}),document.querySelector("#output-canvas").addEventListener("touchend",function(t){2===t.touches.length?(m=!0,f=!1):3===t.touches.length?(f=!0,m=!1):(m=!1,f=!1,0===t.touches.length&&(i=!1)),n=i||c||u||s||l||m||f}),document.documentElement.addEventListener("keydown",function(t){87===t.keyCode?c=!0:83===t.keyCode&&(u=!0),68===t.keyCode?s=!0:65===t.keyCode&&(l=!0),n||o||(n=!0,window.requestAnimationFrame(D))}),document.documentElement.addEventListener("keyup",function(t){87===t.keyCode?c=!1:83===t.keyCode&&(u=!1),68===t.keyCode?s=!1:65===t.keyCode&&(l=!1),n=i||c||u||s||l||m||f});const F="\n\t\tattribute vec3 position;\n\t\tvarying vec2 uv;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tgl_Position = vec4(position, 1.0);\n\n\t\t\t//Interpolate quad coordinates in the fragment shader.\n\t\t\tuv = position.xy;\n\t\t}\n\t",U="\n\t\tprecision highp float;\n\t\t\n\t\tvarying vec2 uv;\n\t\t\n\t\tuniform vec3 camera_pos;\n\t\tuniform vec3 image_plane_center_pos;\n\t\tuniform vec3 forward_vec;\n\t\tuniform vec3 right_vec;\n\t\tuniform vec3 up_vec;\n\t\t\n\t\tuniform float focal_length;\n\t\t\n\t\tuniform vec3 light_pos;\n\t\tconst float light_brightness = 2.0;\n\t\t\n\t\tuniform int image_size;\n\t\tuniform int small_image_size;\n\t\t\n\t\t\n\t\t\n\t\tconst float clip_distance = 1000.0;\n\t\tconst int max_marches = 64;\n\t\tconst vec3 fog_color = vec3(0.0, 0.0, 0.0);\n\t\tconst float fog_scaling = .2;\n\t\tconst int num_iterations = 32;\n\t\t\n\t\tuniform float power;\n\t\tuniform vec3 c;\n\t\tuniform float julia_proportion;\n\t\t\n\t\tvec3 color;\n\t\t\n\t\t\n\t\t\n\t\tfloat distance_estimator(vec3 pos)\n\t\t{\n\t\t\tvec3 z = pos;\n\t\t\t\n\t\t\tfloat r = 0.0;\n\t\t\tfloat dr = 1.0;\n\t\t\t\n\t\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\t\tfloat color_scale = .5;\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < num_iterations; iteration++)\n\t\t\t{\n\t\t\t\tr = length(z);\n\t\t\t\t\n\t\t\t\tif (r > 16.0)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat theta = acos(z.z / r);\n\t\t\t\t\n\t\t\t\tfloat phi = atan(z.y, z.x);\n\t\t\t\t\n\t\t\t\tdr = pow(r, power - 1.0) * power * dr + 1.0;\n\t\t\t\t\n\t\t\t\ttheta = theta * power;\n\t\t\t\t\n\t\t\t\tphi = phi * power;\n\t\t\t\t\n\t\t\t\tz = pow(r, power) * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\t\t\t\n\t\t\t\tz += (1.0 - julia_proportion) * pos + julia_proportion * c;\n\t\t\t\t\n\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * abs(normalize(z));\n\t\t\t\t\n\t\t\t\tcolor_scale *= .5;\n\t\t\t}\n\t\t\t\n\t\t\tfloat max_color_component = max(max(color.x, color.y), color.z);\n\t\t\tcolor /= max_color_component;\n\t\t\t\n\t\t\treturn .5 * log(r) * r / dr;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_surface_normal(vec3 pos)\n\t\t{\n\t\t\tfloat e = .00001;\n\t\t\t\n\t\t\tfloat base = distance_estimator(pos);\n\t\t\t\n\t\t\tfloat x_step = distance_estimator(pos + vec3(e, 0.0, 0.0));\n\t\t\tfloat y_step = distance_estimator(pos + vec3(0.0, e, 0.0));\n\t\t\tfloat z_step = distance_estimator(pos + vec3(0.0, 0.0, e));\n\t\t\t\n\t\t\treturn normalize(vec3(x_step - base, y_step - base, z_step - base));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 compute_shading(vec3 pos, int iteration)\n\t\t{\n\t\t\tvec3 surface_normal = get_surface_normal(pos);\n\t\t\t\n\t\t\tvec3 light_direction = normalize(light_pos - pos);\n\t\t\t\n\t\t\tfloat light_intensity = light_brightness * max(dot(surface_normal, light_direction), .25 * dot(surface_normal, -light_direction));\n\t\t\t\n\t\t\t//The last factor adds ambient occlusion.\n\t\t\tcolor = color * light_intensity * max((1.0 - float(iteration) / float(max_marches)), 0.0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Apply fog.\n\t\t\tfloat distance_from_camera = length(pos - camera_pos);\n\t\t\t\n\t\t\tfloat fog_amount = 1.0 - exp(-distance_from_camera * fog_scaling);\n\t\t\t\n\t\t\treturn (1.0 - fog_amount) * color + fog_amount * fog_color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\tvec3 start_pos = image_plane_center_pos + right_vec * uv.x + up_vec * uv.y;\n\t\t\t\n\t\t\t//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.\n\t\t\tvec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\n\t\t\tvec3 final_color = fog_color;\n\t\t\t\n\t\t\tfloat epsilon = .00001;\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\t\n\t\t\tfloat last_distance = 1000.0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < max_marches; iteration++)\n\t\t\t{\n\t\t\t\tvec3 pos = start_pos + t * ray_direction_vec;\n\t\t\t\t\n\t\t\t\t//This prevents overstepping, and is honestly a pretty clever fix.\n\t\t\t\tfloat distance = min(distance_estimator(pos), last_distance);\n\t\t\t\tlast_distance = distance;\n\t\t\t\t\n\t\t\t\t//This lowers the detail far away, which makes everything run nice and fast.\n\t\t\t\tif (image_size == small_image_size && distance / 300.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 300.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (image_size != small_image_size && distance / 1000.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 1000.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (distance < epsilon)\n\t\t\t\t{\n\t\t\t\t\tfinal_color = compute_shading(pos, iteration);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (t > clip_distance)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt += distance;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tgl_FragColor = vec4(final_color.xyz, 1.0);\n\t\t}\n\t";let C=null;function R(){let e=j(t,t.VERTEX_SHADER,F),n=j(t,t.FRAGMENT_SHADER,U);C=t.createProgram(),t.attachShader(C,e),t.attachShader(C,n),t.linkProgram(C),t.getProgramParameter(C,t.LINK_STATUS)||(console.log(`Couldn't link shader program: ${t.getShaderInfoLog(shader)}`),t.deleteProgram(C)),t.useProgram(C);let o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,-1,1,0,1,-1,0,1,1,0]),t.STATIC_DRAW),C.position_attribute=t.getAttribLocation(C,"position"),t.enableVertexAttribArray(C.position_attribute),t.vertexAttribPointer(C.position_attribute,3,t.FLOAT,!1,0,0),C.image_size_uniform=t.getUniformLocation(C,"image_size"),C.small_image_size_uniform=t.getUniformLocation(C,"small_image_size"),C.camera_pos_uniform=t.getUniformLocation(C,"camera_pos"),C.image_plane_center_pos_uniform=t.getUniformLocation(C,"image_plane_center_pos"),C.forward_vec_uniform=t.getUniformLocation(C,"forward_vec"),C.right_vec_uniform=t.getUniformLocation(C,"right_vec"),C.up_vec_uniform=t.getUniformLocation(C,"up_vec"),C.focal_length_uniform=t.getUniformLocation(C,"focal_length"),C.light_pos_uniform=t.getUniformLocation(C,"light_pos"),C.power_uniform=t.getUniformLocation(C,"power"),C.c_uniform=t.getUniformLocation(C,"c"),C.julia_proportion_uniform=t.getUniformLocation(C,"julia_proportion"),t.viewport(0,0,g,g),t.uniform1i(C.small_image_size_uniform,g),window.requestAnimationFrame(D)}function j(t,e,n){let o=t.createShader(e);return t.shaderSource(o,n),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)||(console.log(`Couldn't load shader: ${t.getProgramInfoLog(shaderProgram)}`),t.deleteShader(o)),o}function D(){t.uniform1i(C.image_size_uniform,g),t.uniform3fv(C.camera_pos_uniform,M),t.uniform3fv(C.image_plane_center_pos_uniform,w),t.uniform3fv(C.forward_vec_uniform,y),t.uniform3fv(C.right_vec_uniform,b),t.uniform3fv(C.up_vec_uniform,S),t.uniform1f(C.focal_length_uniform,x),t.uniform3fv(C.light_pos_uniform,k),t.uniform1f(C.power_uniform,q),t.uniform3fv(C.c_uniform,A),t.uniform1f(C.julia_proportion_uniform,L),t.drawArrays(t.TRIANGLE_STRIP,0,4),o?(!function(){let t=.5*Math.sin(Math.PI*T/120-Math.PI/2)+.5;q=z+P*t,L=E+I*t,121==++T&&(o=!1)}(),window.requestAnimationFrame(D)):n&&((c||u||s||l||m||f)&&((_=d/20)<25e-6&&(_=25e-6),_>.02&&(_=.02),c||m?(M[0]+=_*y[0],M[1]+=_*y[1],M[2]+=_*y[2]):(u||f)&&(M[0]-=_*y[0],M[1]-=_*y[1],M[2]-=_*y[2]),s?(M[0]+=_*b[0]/x,M[1]+=_*b[1]/x,M[2]+=_*b[2]/x):l&&(M[0]-=_*b[0]/x,M[1]-=_*b[1]/x,M[2]-=_*b[2]/x),Y()),window.requestAnimationFrame(D))}function Y(){var t,e;y=[Math.cos(p)*Math.sin(h),Math.sin(p)*Math.sin(h),Math.cos(h)],b=function(t){let e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/e,t[1]/e,t[2]/e]}([y[1],-y[0],0]),e=y,S=[(t=b)[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]],d=function(t,e,n){let o=[t,e,n],i=0,a=1;for(let u=0;u<v&&!((i=Math.sqrt((c=o,(r=o)[0]*c[0]+r[1]*c[1]+r[2]*c[2])))>10);u++){let r=Math.acos(o[2]/i),c=Math.atan2(o[1],o[0]);a=Math.pow(i,q-1)*q*a+1,r*=q,c*=q;let u=Math.pow(i,q);o[0]=u*Math.sin(r)*Math.cos(c)+((1-L)*t+L*A[0]),o[1]=u*Math.sin(r)*Math.sin(c)+((1-L)*e+L*A[1]),o[2]=u*Math.cos(r)+((1-L)*n+L*A[2])}var r,c;return.5*Math.log(i)*i/a}(M[0],M[1],M[2]),x=d/2,b[0]*=x/2,b[1]*=x/2,S[0]*=x/2,S[1]*=x/2,S[2]*=x/2,w=[M[0]+x*y[0],M[1]+x*y[1],M[2]+x*y[2]]}function X(){e=document.querySelector("#output-canvas").offsetWidth}function B(){o=!0,T=0,window.requestAnimationFrame(D)}load_script("/scripts/gl-matrix.min.js").then(function(){setTimeout(R,500)})}();