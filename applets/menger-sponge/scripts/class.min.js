import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";const changeColorGlsl=`
	vec3 colorAdd = abs(mutablePos / effectiveScale);
	color = normalize(color + colorAdd * colorScale);
	colorScale *= 0.5;
`;function getDistanceEstimatorGlsl(useForGetColor=!1){return`
		vec3 mutablePos = abs(pos);
		float maxAbsPos = max(max(mutablePos.x, mutablePos.y), mutablePos.z);
		float minAbsPos = min(min(mutablePos.x, mutablePos.y), mutablePos.z);
		float sumAbsPos = mutablePos.x + mutablePos.y + mutablePos.z;
		mutablePos = vec3(minAbsPos, sumAbsPos - minAbsPos - maxAbsPos, maxAbsPos);

		${useForGetColor?"vec3 color = vec3(0.25); float colorScale = 0.5;":""}

		float totalDistance;
		vec3 totalScale = vec3(1.0, 1.0, 1.0);
		float effectiveScale;

		float invScale = 1.0 / scale;
		float cornerFactor = 2.0 * scale / (scale - 1.0);
		float edgeFactor = 2.0 * scale / (scale - 1.0);

		vec3 cornerScaleCenter = (cornerFactor - 1.0) * vec3(1.0);
		vec3 edgeScaleCenter = vec3(0.0, edgeFactor - 1.0, edgeFactor - 1.0);

		float cornerRadius = 0.5 * (1.0 - invScale);
		float cornerCenter = 0.5 * (1.0 + invScale);

		float edgeLongRadius = invScale;
		float edgeShortRadius = 0.5 * (1.0 - invScale);
		float edgeCenter = 0.5 * (1.0 + invScale);

		for (int iteration = 0; iteration < maxIterations; iteration++)
		{
			if (iteration == iterations)
			{
				break;
			}

			float distanceToCornerX = abs(mutablePos.x - cornerCenter) - cornerRadius;
			float distanceToCornerY = abs(mutablePos.y - cornerCenter) - cornerRadius;
			float distanceToCornerZ = abs(mutablePos.z - cornerCenter) - cornerRadius;
			float distanceToCorner = max(distanceToCornerX, max(distanceToCornerY, distanceToCornerZ));
			
			float distanceToEdgeX = abs(mutablePos.x) - edgeLongRadius;
			float distanceToEdgeY = abs(mutablePos.y - edgeCenter) - edgeShortRadius;
			float distanceToEdgeZ = abs(mutablePos.z - edgeCenter) - edgeShortRadius;
			float distanceToEdge = max(distanceToEdgeX, max(distanceToEdgeY, distanceToEdgeZ));

			if (distanceToCorner < distanceToEdge)
			{
				totalDistance = distanceToCorner;

				if (distanceToCornerX > max(distanceToCornerY, distanceToCornerZ))
				{
					effectiveScale = totalScale.x;
				}

				else if (distanceToCornerY > max(distanceToCornerX, distanceToCornerZ))
				{
					effectiveScale = totalScale.y;
				}

				else
				{
					effectiveScale = totalScale.z;
				}

				// Scale all directions by 2s/(s-1) from (1, 1, 1) * separation.
				mutablePos = cornerFactor * mutablePos - cornerScaleCenter;

				totalScale *= cornerFactor;
			}

			else
			{
				totalDistance = distanceToEdge;
				
				if (distanceToEdgeX > max(distanceToEdgeY, distanceToEdgeZ))
				{
					effectiveScale = totalScale.x;
				}

				else if (distanceToEdgeY > max(distanceToEdgeX, distanceToEdgeZ))
				{
					effectiveScale = totalScale.y;
				}

				else
				{
					effectiveScale = totalScale.z;
				}

				// Scale x by s and y and z by 2s/(s-1) from (0, 1, 1). The second term is equal to
				mutablePos = vec3(1.0 / edgeLongRadius, edgeFactor, edgeFactor) * mutablePos - edgeScaleCenter;

				totalScale *= vec3(1.0 / edgeLongRadius, edgeFactor, edgeFactor);
			}

			${useForGetColor?changeColorGlsl:""}

			mutablePos = abs(mutablePos);
			maxAbsPos = max(max(mutablePos.x, mutablePos.y), mutablePos.z);
			minAbsPos = min(min(mutablePos.x, mutablePos.y), mutablePos.z);
			sumAbsPos = mutablePos.x + mutablePos.y + mutablePos.z;
			mutablePos = vec3(minAbsPos, sumAbsPos - minAbsPos - maxAbsPos, maxAbsPos);
		}
		
		${useForGetColor?"return abs(color);":"return totalDistance / effectiveScale;"}
	`}class MengerSponge extends RaymarchApplet{constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:getDistanceEstimatorGlsl(),getColorGlsl:getDistanceEstimatorGlsl(!0),addGlsl:`
			const int maxIterations = 16;
		`,uniforms:{scale:["float",3],iterations:["int",16]},cameraPos:[2.1978,1.4366,1.5174],theta:3.7518,phi:2.1482,stepFactor:.5,epsilonScaling:1.75,lightBrightness:1.75})}distanceEstimator(x,y,z){var e=this.uniforms.scale[1],a=this.uniforms.iterations[1];let t=[Math.abs(x),Math.abs(y),Math.abs(z)];var o=Math.max(Math.max(t[0],t[1]),t[2]),s=Math.min(Math.min(t[0],t[1]),t[2]),l=t[0]+t[1]+t[2];t=[s,l-s-o,o];let r;var c=[1,1,1];let n;var i=1/e,m=2*e/(e-1),d=2*e/(e-1),b=[m-1,m-1,m-1],u=[0,d-1,d-1],f=.5*(1-i),g=.5*(1+i),P=.5*(1-i),h=.5*(1+i);for(let F=0;F<a;F++){var S=Math.abs(t[0]-g)-f,v=Math.abs(t[1]-g)-f,C=Math.abs(t[2]-g)-f,T=Math.max(S,Math.max(v,C)),M=t[0]-i,A=Math.abs(t[1]-h)-P,E=Math.abs(t[2]-h)-P,p=Math.max(M,Math.max(A,E));T<p?(r=T,n=S>Math.max(v,C)?c[0]:v>Math.max(S,C)?c[1]:c[2],t=[m*t[0]-b[0],m*t[1]-b[1],m*t[2]-b[2]],c[0]*=m,c[1]*=m,c[2]*=m):(r=p,n=M>Math.max(A,E)?c[0]:A>Math.max(M,E)?c[1]:c[2],t=[e*t[0]-u[0],d*t[1]-u[1],d*t[2]-u[2]],c[0]*=e,c[1]*=d,c[2]*=d),t=[Math.abs(t[0]),Math.abs(t[1]),Math.abs(t[2])],o=Math.max(Math.max(t[0],t[1]),t[2]),s=Math.min(Math.min(t[0],t[1]),t[2]),l=t[0]+t[1]+t[2],t=[s,l-s-o,o]}return Math.abs(r)/n}}export{MengerSponge};