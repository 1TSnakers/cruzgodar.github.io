import{extrudedCubeDE,mengerSpongeDE}from"./distanceEstimators.min.js";import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";class CubeAndSponge extends RaymarchApplet{sphereWeight=0;extrudedCubeWeight=1;extrudedCubeSeparation=1.5;mengerSpongeWeight=0;mengerSpongeScale=3;constructor({canvas}){super({canvas:canvas,distanceEstimatorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			return min(distanceGround, distanceObject);
		`,getColorGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				vec2 co = floor(pos.xy * 50.0);
				return vec3(0.5, 0.5, 0.5)
					* (1.0 + .2 * (rand(co) - .5));
			}

			if (minDistance == distanceObject)
			{
				return getColorObject(pos);
			}
		`,getReflectivityGlsl:`
			float distanceGround = distanceEstimatorGround(pos);
			float distanceObject = distanceEstimatorObject(pos);

			float minDistance = min(distanceGround, distanceObject);

			if (minDistance == distanceGround)
			{
				return .05;
			}

			if (minDistance == distanceObject)
			{
				return 0.15;
			}
		`,addGlsl:`
			float rand(vec2 co)
			{
				return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
			}

			${extrudedCubeDE[0]}
			${mengerSpongeDE[0]}

			${extrudedCubeDE[1]}
			${mengerSpongeDE[1]}

			float distanceEstimatorGround(vec3 pos)
			{
				return abs(pos.z);
			}

			float distanceEstimatorObject(vec3 pos)
			{
				float distanceObject = 0.0;

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));

				if (extrudedCubeWeight > 0.0)
				{
					distanceObject += extrudedCubeWeight * distanceEstimatorExtrudedCube(rotatedPos);
				}
				
				if (mengerSpongeWeight > 0.0)
				{
					distanceObject += mengerSpongeWeight * distanceEstimatorMengerSponge(rotatedPos);
				}
				
				return distanceObject;
			}

			vec3 getColorObject(vec3 pos)
			{
				vec3 color = vec3(0.0, 0.0, 0.0);

				float c = cos(objectRotation);
				float s = sin(objectRotation);
				vec3 rotatedPos = mat3(c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0) * (pos + vec3(0.0, 0.0, objectFloat));

				if (extrudedCubeWeight > 0.0)
				{
					color += extrudedCubeWeight * getColorExtrudedCube(rotatedPos);
				}

				if (mengerSpongeWeight > 0.0)
				{
					color += mengerSpongeWeight * getColorMengerSponge(rotatedPos);
				}

				return color;
			}
		`,uniforms:{objectRotation:["float",0],objectFloat:["float",0],sphereWeight:["float",0],extrudedCubeWeight:["float",1],extrudedCubeSeparation:["float",1.5],mengerSpongeWeight:["float",0],mengerSpongeScale:["float",3]},maxMarches:192,cameraPos:[1,1,1],theta:1.25*Math.PI,phi:2.1539,lockedOnOrigin:!1,lockZ:1,fogColor:[.6,.73,.87],useShadows:!0})}distanceEstimator(){return 1}distanceEstimatorExtrudedCube(x,y,z){var t=this.uniforms.extrudedCubeScale[1],e=(t+1)/(t-1)*this.uniforms.extrudedCubeSeparation[1];let a=[3*Math.abs(x),3*Math.abs(y),3*Math.abs(z)-2.5],o=Math.max(Math.max(a[0],a[1]),a[2])-1;for(let s=0;s<this.iterations;s++)a=a[0]>Math.max(a[1],a[2])?[t*a[0]-(t-1)*e,t*a[1],t*a[2]]:a[1]>Math.max(a[0],a[2])?[t*a[0],t*a[1]-(t-1)*e,t*a[2]]:[t*a[0],t*a[1],t*a[2]-(t-1)*e],a=[Math.abs(a[0]),Math.abs(a[1]),Math.abs(a[2])],o=Math.min(o,(Math.max(Math.max(a[0],a[1]),a[2])-1)/Math.pow(t,s+1));return Math.abs(o)/3}distanceEstimatorMengerSponge(x,y,z){var t=this.uniforms.mengerSpongeScale[1];let e=[3*Math.abs(x),3*Math.abs(y),3*Math.abs(z)-2.5];var a=Math.max(Math.max(e[0],e[1]),e[2]),o=Math.min(Math.min(e[0],e[1]),e[2]),s=e[0]+e[1]+e[2];e=[o,s-o-a,a];let n;var r=[1,1,1];let i;var c=1/t,d=2*t/(+t-1),m=2*t/(t-1),h=[(+t+1)/(1+2*t-+t)*(d-1),(+t+1)/(1+2*t-+t)*(d-1),(+t+1)/(1+2*t-+t)*(d-1)],u=[0,m-1,m-1],b=.5*(1-c),l=.5*(1+c),g=.5*(1-c),p=.5*(1+c);for(let G=0;G<16;G++){var M=Math.abs(e[0]-l)-b,f=Math.abs(e[1]-l)-b,j=Math.abs(e[2]-l)-b,S=Math.max(M,Math.max(f,j)),v=e[0]-c,C=Math.abs(e[1]-p)-g,E=Math.abs(e[2]-p)-g,O=Math.max(v,Math.max(C,E));S<O?(n=S,i=M>Math.max(f,j)?r[0]:f>Math.max(M,j)?r[1]:r[2],e=[d*e[0]-h[0],d*e[1]-h[1],d*e[2]-h[2]],r[0]*=d,r[1]*=d,r[2]*=d):(n=O,i=v>Math.max(C,E)?r[0]:C>Math.max(v,E)?r[1]:r[2],e=[t*e[0]-u[0],m*e[1]-u[1],m*e[2]-u[2]],r[0]*=t,r[1]*=m,r[2]*=m),e=[Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2])],a=Math.max(Math.max(e[0],e[1]),e[2]),o=Math.min(Math.min(e[0],e[1]),e[2]),s=e[0]+e[1]+e[2],e=[o,s-o-a,a]}return Math.abs(n)/i*.333333}}export{CubeAndSponge};