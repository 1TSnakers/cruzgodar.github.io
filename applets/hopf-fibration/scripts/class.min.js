import{getFloatGlsl,getMinGlslString,getVectorGlsl}from"/scripts/applets/applet.min.js";import{ThreeApplet}from"/scripts/applets/threeApplet.min.js";import{aspectRatio}from"/scripts/src/layout.min.js";import{addTemporaryListener}from"/scripts/src/main.min.js";import*as THREE from"/scripts/three.js";import{Wilson}from"/scripts/wilson.min.js";function hsvToRgb(h,s,v){function t(n){var t=(n+6*h)%6;return v-v*s*Math.max(0,Math.min(t,Math.min(4-t,1)))}return[255*t(5),255*t(3),255*t(1)]}class Fiber extends THREE.Curve{p;v;center;s3Point;constructor({p,v,center,s3Point}){super(),this.p=p,this.v=v,this.center=center,this.s3Point=s3Point}getPoint(t,optionalTarget=new THREE.Vector3){var e=Math.cos(2*Math.PI*t),i=Math.sin(2*Math.PI*t),s=e*this.p[0]+i*this.v[0]+this.center[0],a=e*this.p[1]+i*this.v[1]+this.center[1],e=e*this.p[2]+i*this.v[2]+this.center[2];return optionalTarget.set(s,a,e)}}class HopfFibration extends ThreeApplet{cameraPos=[2,2,2];theta=3.7518;phi=2.1482;movingSpeed=.025;numLatitudes=4;numLongitudesPerLatitude=16;fibers=[];constructor({canvas}){super(canvas);var t={renderer:"gpu",canvasWidth:500,canvasHeight:500,worldCenterX:-this.theta,worldCenterY:-this.phi,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:this.changeResolution.bind(this),mousedownCallback:this.onGrabCanvas.bind(this),touchstartCallback:this.onGrabCanvas.bind(this),mousedragCallback:this.onDragCanvas.bind(this),touchmoveCallback:this.onDragCanvas.bind(this),mouseupCallback:this.onReleaseCanvas.bind(this),touchendCallback:this.onReleaseCanvas.bind(this)};this.wilson=new Wilson(canvas,t),this.initThree();addTemporaryListener({object:window,event:"resize",callback:()=>this.changeResolution()}),this.createAllFibers(),this.resume()}createFiber(theta,phi){var t=[Math.sin(phi)*Math.cos(theta),Math.sin(phi)*Math.sin(theta),Math.cos(phi)],e=1/Math.sqrt(2*(t[2]+1)),i=[0,e*t[0],e*t[1],e*(1+t[2])],s=[i[0]/(1-i[3]),i[1]/(1-i[3]),i[2]/(1-i[3])],i=[-i[0]/(1+i[3]),-i[1]/(1+i[3]),-i[2]/(1+i[3])],i=[(s[0]+i[0])/2,(s[1]+i[1])/2,(s[2]+i[2])/2],a=Math.sqrt((s[0]-i[0])**2+(s[1]-i[1])**2+(s[2]-i[2])**2),e=[e*(1+t[2]),-e*t[1],e*t[0],0],t=[e[0]/(1-e[3]),e[1]/(1-e[3]),e[2]/(1-e[3])],e=[s[0]-i[0],s[1]-i[1],s[2]-i[2]],s=[t[0]-i[0],t[1]-i[1],t[2]-i[2]],t=(s[0]*e[0]+s[1]*e[1]+s[2]*e[2])/(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),s=[s[0]-t*e[0],s[1]-t*e[1],s[2]-t*e[2]],t=Math.sqrt(s[0]**2+s[1]**2+s[2]**2),a=[a/t*s[0],a/t*s[1],a/t*s[2]],t=new Fiber({p:e,v:a,center:i}),s=hsvToRgb(phi/Math.PI*6/7,Math.abs(theta%Math.PI-Math.PI/2)/(Math.PI/2),1),e=new THREE.Mesh(new THREE.TubeGeometry(t,100,.05,20,!1),new THREE.MeshStandardMaterial({color:new THREE.Color(s[0]/255,s[1]/255,s[2]/255)}));return this.scene.add(e),e}createAllFibers(){for(let s=0;s<this.numLatitudes;s++){var e=(s+1)/(this.numLatitudes+1)*Math.PI;for(let t=0;t<this.numLongitudesPerLatitude;t++){var i=t/this.numLongitudesPerLatitude*2*Math.PI,i=this.createFiber(i,e);this.fibers.push(i)}}}s2PointToCircle(point){if(1===Math.abs(point[2]))throw new Error("Don't pass poles to the projection function!");var t=1/Math.sqrt(2*(point[2]+1)),e=[0,t*point[0],t*point[1],t*(1+point[2])],i=[e[0]/(1-e[3]),e[1]/(1-e[3]),e[2]/(1-e[3])],e=[-e[0]/(1+e[3]),-e[1]/(1+e[3]),-e[2]/(1+e[3])],e=[(i[0]+e[0])/2,(i[1]+e[1])/2,(i[2]+e[2])/2],s=Math.sqrt((i[0]-e[0])**2+(i[1]-e[1])**2+(i[2]-e[2])**2),t=[t*(1+point[2]),-t*point[1],t*point[0],0],t=[t[0]/(1-t[3]),t[1]/(1-t[3]),t[2]/(1-t[3])],i=[i[1]*t[2]-i[2]*t[1],i[2]*t[0]-i[0]*t[2],i[0]*t[1]-i[1]*t[0]],t=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);return[e,[i[0]/t,i[1]/t,i[2]/t],s]}getDistanceEstimatorGlsl(){let e="",i=3;e+=`
			float distance1 = torusDistance(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), 1.0);
			float distance2 = length(pos.yz) - fiberThickness;
		`;for(let r=0;r<this.numLatitudes;r++){var s=(r+1)/(this.numLatitudes+1)*Math.PI;for(let t=0;t<this.numLongitudesPerLatitude;t++){var a=t/this.numLongitudesPerLatitude*2*Math.PI,a=[Math.sin(s)*Math.cos(a),Math.sin(s)*Math.sin(a),Math.cos(s)],[a,n,h]=this.s2PointToCircle(a);e+=`
					float distance${i} = torusDistance(pos, ${getVectorGlsl(a)}, ${getVectorGlsl(n)}, ${getFloatGlsl(h)});
				`,i++}}return e+=`
			float minDistance = ${getMinGlslString("distance",i-1)};
		`}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.wilson.worldCenterY=Math.min(Math.max(this.wilson.worldCenterY,.01-Math.PI),-.01),this.theta=-this.wilson.worldCenterX,this.phi=-this.wilson.worldCenterY,this.renderer.render(this.scene,this.camera)}changeResolution(resolution=this.imageSize){this.imageSize=Math.max(100,resolution),this.wilson.fullscreen.currentlyFullscreen?1<=aspectRatio?(this.imageWidth=this.imageSize,this.imageHeight=Math.floor(this.imageSize/aspectRatio)):(this.imageWidth=Math.floor(this.imageSize*aspectRatio),this.imageHeight=this.imageSize):(this.imageWidth=this.imageSize,this.imageHeight=this.imageSize),this.wilson.changeCanvasSize(this.imageWidth,this.imageHeight),this.imageWidth>=this.imageHeight?(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,this.imageWidth/this.imageHeight),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,1)):(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,1),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,this.imageWidth/this.imageHeight)),this.renderer.setSize(this.imageWidth,this.imageHeight,!1),this.camera.aspect=this.imageWidth/this.imageHeight,this.camera.updateProjectionMatrix(),this.needNewFrame=!0}}export{HopfFibration};