import{getFloatGlsl,getMinGlslString,getVectorGlsl}from"/scripts/applets/applet.min.js";import{RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";import{aspectRatio}from"/scripts/src/layout.min.js";import{addTemporaryListener}from"/scripts/src/main.min.js";import{Wilson}from"/scripts/wilson.min.js";class HopfFibration extends RaymarchApplet{cameraPos=[2,2,2];theta=3.7518;phi=2.1482;numLatitudes=3;numLongitudesPerLatitude=15;constructor({canvas}){super(canvas);var t=`
			precision highp float;
			
			varying vec2 uv;
			
			uniform float aspectRatioX;
			uniform float aspectRatioY;
			
			uniform vec3 cameraPos;
			uniform vec3 imagePlaneCenterPos;
			uniform vec3 forwardVec;
			uniform vec3 rightVec;
			uniform vec3 upVec;
			uniform float fiberThickness;
			
			uniform float focalLength;
			
			const vec3 lightPos = vec3(50.0, 70.0, 100.0);
			const float lightBrightness = 2.5;
			
			const float clipDistance = 1000.0;
			const int maxMarches = 100;
			const vec3 fogColor = vec3(0.0, 0.0, 0.0);
			const float fogScaling = .2;
			


			float torusDistance(vec3 pos, vec3 center, vec3 normal, float radius)
			{
				vec3 movedPos = pos - center;

				float posNComponent = dot(movedPos, normal);

				return length(
					vec2(
						length(movedPos - posNComponent * normal) - radius,
						posNComponent
					)
				) - fiberThickness;
			}
			
			float distanceEstimator(vec3 pos)
			{
				${this.getDistanceEstimatorGlsl()}

				return minDistance;
			}
			
			vec3 getColor(vec3 pos)
			{
				return vec3(1.0, 0.0, 0.0);
			}
			
			vec3 getSurfaceNormal(vec3 pos)
			{
				float xStep1 = distanceEstimator(pos + vec3(.00001, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, .00001, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, .00001));
				
				float xStep2 = distanceEstimator(pos - vec3(.00001, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, .00001, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, .00001));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}
			
			
			
			vec3 computeShading(vec3 pos, int iteration)
			{
				vec3 surfaceNormal = getSurfaceNormal(pos);
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = lightBrightness * abs(dotProduct);
				
				//The last factor adds ambient occlusion.
				vec3 color = getColor(pos) * lightIntensity * max((1.0 - float(iteration) / float(maxMarches)), 0.0);
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}
			
			
			
			vec3 raymarch(vec3 startPos)
			{
				vec3 rayDirectionVec = normalize(startPos - cameraPos) * .5;
				
				float epsilon = .00001;
				
				float t = 0.0;

				for (int iteration = 0; iteration < maxMarches; iteration++)
				{
					vec3 pos = startPos + t * rayDirectionVec;
					
					float distanceToScene = distanceEstimator(pos);
					
					if (distanceToScene < epsilon)
					{
						return computeShading(pos, iteration);
					}
					
					else if (t > clipDistance)
					{
						return fogColor;
					}
					
					t += distanceToScene;
				}
				
				return fogColor;
			}
			
			
			
			void main(void)
			{
				vec3 finalColor = raymarch(imagePlaneCenterPos + rightVec * uv.x * aspectRatioX + upVec * uv.y / aspectRatioY);
				
				gl_FragColor = vec4(finalColor.xyz, 1.0);
			}
		`,t=(console.log(t),{renderer:"gpu",shader:t,canvasWidth:500,canvasHeight:500,worldCenterX:-this.theta,worldCenterY:-this.phi,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:this.changeResolution.bind(this),mousedownCallback:this.onGrabCanvas.bind(this),touchstartCallback:this.onGrabCanvas.bind(this),mousedragCallback:this.onDragCanvas.bind(this),touchmoveCallback:this.onDragCanvas.bind(this),mouseupCallback:this.onReleaseCanvas.bind(this),touchendCallback:this.onReleaseCanvas.bind(this)});this.wilson=new Wilson(canvas,t),this.wilson.render.initUniforms(["aspectRatioX","aspectRatioY","fiberThickness","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","focalLength"]),this.calculateVectors(),this.imageWidth>=this.imageHeight?(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,this.imageWidth/this.imageHeight),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,1)):(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,1),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,this.imageWidth/this.imageHeight)),this.wilson.gl.uniform3fv(this.wilson.uniforms.cameraPos,this.cameraPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.imagePlaneCenterPos,this.imagePlaneCenterPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.forwardVec,this.forwardVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.rightVec,this.rightVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.upVec,this.upVec),this.wilson.gl.uniform1f(this.wilson.uniforms.focalLength,this.focalLength),this.wilson.gl.uniform1f(this.wilson.uniforms.fiberThickness,.05);addTemporaryListener({object:window,event:"resize",callback:()=>this.changeResolution()}),this.resume()}s2PointToCircle(point){if(1===Math.abs(point[2]))throw new Error("Don't pass the north pole to the projection function!");var t=1/Math.sqrt(2*(point[2]+1)),i=[0,t*point[0],t*point[1],t*(1+point[2])],e=[i[0]/(1-i[3]),i[1]/(1-i[3]),i[2]/(1-i[3])],i=[-i[0]/(1+i[3]),-i[1]/(1+i[3]),-i[2]/(1+i[3])],i=[(e[0]+i[0])/2,(e[1]+i[1])/2,(e[2]+i[2])/2],s=Math.sqrt((e[0]-i[0])**2+(e[1]-i[1])**2+(e[2]-i[2])**2),t=[t*(1+point[2]),-t*point[1],t*point[0],0],t=[t[0]/(1-t[3]),t[1]/(1-t[3]),t[2]/(1-t[3])],e=[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);return[i,[e[0]/t,e[1]/t,e[2]/t],s]}getDistanceEstimatorGlsl(){let i="",e=3;i+=`
			float distance1 = torusDistance(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), 1.0);
			float distance2 = length(pos.yz) - fiberThickness;
		`;for(let r=0;r<this.numLatitudes;r++){var s=(r+1)/(this.numLatitudes+1)*Math.PI;for(let t=0;t<this.numLongitudesPerLatitude;t++){var o=t/this.numLongitudesPerLatitude*2*Math.PI,o=[Math.sin(s)*Math.cos(o),Math.sin(s)*Math.sin(o),Math.cos(s)],[o,a,n]=this.s2PointToCircle(o);i+=`
					float distance${e} = torusDistance(pos, ${getVectorGlsl(o)}, ${getVectorGlsl(a)}, ${getFloatGlsl(n)});
				`,e++}}return i+=`
			float minDistance = ${getMinGlslString("distance",e-1)};
		`}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.wilson.worldCenterY=Math.min(Math.max(this.wilson.worldCenterY,.01-Math.PI),-.01),this.theta=-this.wilson.worldCenterX,this.phi=-this.wilson.worldCenterY,this.wilson.render.drawFrame()}distanceEstimator(x,y,z){return 1}changeResolution(resolution=this.imageSize){this.imageSize=Math.max(100,resolution),this.wilson.fullscreen.currentlyFullscreen?1<=aspectRatio?(this.imageWidth=this.imageSize,this.imageHeight=Math.floor(this.imageSize/aspectRatio)):(this.imageWidth=Math.floor(this.imageSize*aspectRatio),this.imageHeight=this.imageSize):(this.imageWidth=this.imageSize,this.imageHeight=this.imageSize),this.wilson.changeCanvasSize(this.imageWidth,this.imageHeight),this.imageWidth>=this.imageHeight?(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,this.imageWidth/this.imageHeight),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,1)):(this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,1),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,this.imageWidth/this.imageHeight)),this.needNewFrame=!0}}export{HopfFibration};