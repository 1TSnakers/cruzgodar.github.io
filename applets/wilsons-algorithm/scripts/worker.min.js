"use strict";onmessage=async function(e){gridSize=e.data[0],maximumSpeed=e.data[1],noBorders=e.data[2],reverseGenerateSkeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js"),await drawWilsonGraph(),await colorGraph(),postMessage(["done"])}};let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[],verticesInTree=[],grid=[],newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;async function drawWilsonGraph(){edgesInTree=[],verticesNotInTree=[];for(let r=0;r<gridSize;r++)for(let e=0;e<gridSize;e++)verticesNotInTree[gridSize*r+e]=[r,e],grid[gridSize*r+e]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++)}async function wilsonStep(){if(newVertices=[],reverseGenerateSkeleton){if(0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5)),jsRandomWalk(100),newVertices.splice(newVertices.length-1,1),newVertices.length<99)return void(randomWalkFromEndpointAttmepts<100?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,e=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[e][0],currentColumn=verticesInTree[e][1]));randomWalkFromEndpointAttmepts=0,currentRowBaseCamp=newVertices[newVertices.length-2][0],currentColumnBaseCamp=newVertices[newVertices.length-2][1],currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp,++numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{var e=Math.floor(Math.random()*verticesNotInTree.length);if(currentRow=verticesNotInTree[e][0],currentColumn=verticesNotInTree[e][1],0===edgesInTree.length){let e=5*gridSize;gridSize<=100?e=gridSize:gridSize<=300&&(e=3*gridSize),randomWalk(e),postMessage(["log","Got it in time!"])}else randomWalk()}for(let e=0;e<newVertices.length-1;e++)maximumSpeed?drawLine(newVertices[e][0],newVertices[e][1],newVertices[e+1][0],newVertices[e+1][1],"rgb(255, 255, 255)",0):await drawLine(newVertices[e][0],newVertices[e][1],newVertices[e+1][0],newVertices[e+1][1],"rgb(255, 255, 255)",300/gridSize);for(let e=0;e<newVertices.length;e++){grid[gridSize*newVertices[e][0]+newVertices[e][1]]=1;var r=vertexInArray(newVertices[e],verticesNotInTree);-1!==r&&(verticesNotInTree.splice(r,1),verticesInTree.push(newVertices[e])),e!==newVertices.length-1&&edgesInTree.push([newVertices[e],newVertices[e+1]])}}function wasmRandomWalk(e=0){var r=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,e,currentRow,currentColumn],{heapIn:"HEAPU32"}),n=Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT];for(let e=2;e<2*n;e+=2)newVertices.push([Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e],Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e+1]]);Module.ccall("free_from_js",null,["number"],[r]),!1===reverseGenerateSkeleton&&n<gridSize/10?10==++numShortPathsInARow&&(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."])):numShortPathsInARow=0}function jsRandomWalk(r=0){for(newVertices=[[currentRow,currentColumn]];;){let e=[];var n=(e=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*e.length)],n=(0===n?currentRow--:1===n?currentColumn++:2===n?currentRow++:currentColumn--,vertexInArray([currentRow,currentColumn],newVertices));if(-1!==n?(currentRow=newVertices[n][0],currentColumn=newVertices[n][1],newVertices=newVertices.slice(0,n+1)):newVertices.push([currentRow,currentColumn]),1===grid[gridSize*currentRow+currentColumn])break;if(0!==r&&newVertices.length===r)break}}async function colorGraph(n=!1){var t=[];for(let r=0;r<gridSize;r++){t[r]=[];for(let e=0;e<gridSize;e++)t[r][e]=[]}for(let e=0;e<edgesInTree.length;e++){var r=edgesInTree[e][0][0],i=edgesInTree[e][0][1],o=edgesInTree[e][1][0],a=edgesInTree[e][1][1];r===o?(t[r][Math.min(i,a)].includes(1)||t[r][Math.min(i,a)].push(1),t[o][Math.max(i,a)].includes(3)||t[o][Math.max(i,a)].push(3)):(t[Math.min(r,o)][i].includes(2)||t[Math.min(r,o)][i].push(2),t[Math.max(r,o)][i].includes(0)||t[Math.max(r,o)][a].push(0))}var s=[];let l=[];l=gridSize%2==1?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];var c=[];for(let r=0;r<gridSize;r++){c[r]=[];for(let e=0;e<gridSize;e++)c[r][e]=-1}for(;0<l.length;){var u=l.length;for(let e=0;e<u;e++){var d=l[e][0],m=l[e][1],g=l[e][2];c[d][m]=g,t[d][m].includes(0)&&-1===c[d-1][m]&&(l.push([d-1,m,g+1]),s.push([[d,m],[d-1,m],g])),t[d][m].includes(1)&&-1===c[d][m+1]&&(l.push([d,m+1,g+1]),s.push([[d,m],[d,m+1],g])),t[d][m].includes(2)&&-1===c[d+1][m]&&(l.push([d+1,m,g+1]),s.push([[d,m],[d+1,m],g])),t[d][m].includes(3)&&-1===c[d][m-1]&&(l.push([d,m-1,g+1]),s.push([[d,m],[d,m-1],g]))}l.splice(0,u)}s.sort((e,r)=>e[2]-r[2]);var h=7*s[s.length-1][2]/6,w=[0];let p=0;for(let e=0;e<s.length;e++)s[e][2]>p&&(w.push(e),p++);w.push(s.length);for(let r=0;r<w.length;r++){let e=0;var S=Math.min(w[r],s.length-1),f=HSVtoRGB(n?s[S][2]/h:w[r+1]/s.length*6/7,1,1);for(e=w[r];e<w[r+1]-1;e++)drawLine(s[e][0][0],s[e][0][1],s[e][1][0],s[e][1][1],`rgb(${f[0]}, ${f[1]}, ${f[2]})`,0);s[e]&&(maximumSpeed?drawLine(s[e][0][0],s[e][0][1],s[e][1][0],s[e][1][1],`rgb(${f[0]}, ${f[1]}, ${f[2]})`,24):await drawLine(s[e][0][0],s[e][0][1],s[e][1][0],s[e][1][1],`rgb(${f[0]}, ${f[1]}, ${f[2]})`,24))}}async function drawLine(e,r,n,t,i,o){var a;r===t?(a=r,n=Math.min(e,n),noBorders?postMessage([a,n,1,2,i]):postMessage([2*a+1,2*n+1,1,3,i])):(a=Math.min(r,t),n=e,noBorders?postMessage([a,n,2,1,i]):postMessage([2*a+1,2*n+1,3,1,i])),await new Promise(e=>setTimeout(e,o))}function vertexInArray(r,n){for(let e=0;e<n.length;e++)if(n[e][0]===r[0]&&n[e][1]===r[1])return e;return-1}function HSVtoRGB(e,r,n){let t,i,o,a,s,l,c,u;switch(l=n*(1-r),c=n*(1-(s=6*e-(a=Math.floor(6*e)))*r),u=n*(1-(1-s)*r),a%6){case 0:t=n,i=u,o=l;break;case 1:t=c,i=n,o=l;break;case 2:t=l,i=n,o=u;break;case 3:t=l,i=c,o=n;break;case 4:t=u,i=l,o=n;break;case 5:t=n,i=l,o=c}return[Math.round(255*t),Math.round(255*i),Math.round(255*o)]}