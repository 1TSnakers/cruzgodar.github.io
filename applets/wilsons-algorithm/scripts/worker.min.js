"use strict";let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[];const verticesInTree=[],grid=[];let newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;async function drawWilsonGraph(){edgesInTree=[],verticesNotInTree=[];for(let i=0;i<gridSize;i++)for(let j=0;j<gridSize;j++)verticesNotInTree[gridSize*i+j]=[i,j],grid[gridSize*i+j]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++)}async function wilsonStep(){if(newVertices=[],reverseGenerateSkeleton){var newIndex;if(0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5)),jsRandomWalk(100),newVertices.splice(newVertices.length-1,1),newVertices.length<99)return void(randomWalkFromEndpointAttmepts<100?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,newIndex=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[newIndex][0],currentColumn=verticesInTree[newIndex][1]));randomWalkFromEndpointAttmepts=0,currentRowBaseCamp=newVertices[newVertices.length-2][0],currentColumnBaseCamp=newVertices[newVertices.length-2][1],currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp,++numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{const newIndex=Math.floor(Math.random()*verticesNotInTree.length);if(currentRow=verticesNotInTree[newIndex][0],currentColumn=verticesNotInTree[newIndex][1],0===edgesInTree.length){let walkLength=5*gridSize;gridSize<=100?walkLength=gridSize:gridSize<=300&&(walkLength=3*gridSize),randomWalk(walkLength),postMessage(["log","Got it in time!"])}else randomWalk()}for(let i=0;i<newVertices.length-1;i++)maximumSpeed?drawLine(newVertices[i][0],newVertices[i][1],newVertices[i+1][0],newVertices[i+1][1],"rgb(255, 255, 255)",0):await drawLine(newVertices[i][0],newVertices[i][1],newVertices[i+1][0],newVertices[i+1][1],"rgb(255, 255, 255)",300/gridSize);for(let i=0;i<newVertices.length;i++){grid[gridSize*newVertices[i][0]+newVertices[i][1]]=1;var popIndex=vertexInArray(newVertices[i],verticesNotInTree);-1!==popIndex&&(verticesNotInTree.splice(popIndex,1),verticesInTree.push(newVertices[i])),i!==newVertices.length-1&&edgesInTree.push([newVertices[i],newVertices[i+1]])}}function wasmRandomWalk(fixedLength=0){var newVerticesPtr=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,fixedLength,currentRow,currentColumn],{heapIn:"HEAPU32"}),numNewVertices=Module.HEAPU32[newVerticesPtr/Uint32Array.BYTES_PER_ELEMENT];for(let i=2;i<2*numNewVertices;i+=2)newVertices.push([Module.HEAPU32[newVerticesPtr/Uint32Array.BYTES_PER_ELEMENT+i],Module.HEAPU32[newVerticesPtr/Uint32Array.BYTES_PER_ELEMENT+i+1]]);Module.ccall("free_from_js",null,["number"],[newVerticesPtr]),!1===reverseGenerateSkeleton&&numNewVertices<gridSize/10?10==++numShortPathsInARow&&(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."])):numShortPathsInARow=0}function jsRandomWalk(fixedLength=0){for(newVertices=[[currentRow,currentColumn]];;){let possibleDirections=[];var direction=(possibleDirections=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*possibleDirections.length)],direction=(0===direction?currentRow--:1===direction?currentColumn++:2===direction?currentRow++:currentColumn--,vertexInArray([currentRow,currentColumn],newVertices));if(-1!==direction?(currentRow=newVertices[direction][0],currentColumn=newVertices[direction][1],newVertices=newVertices.slice(0,direction+1)):newVertices.push([currentRow,currentColumn]),1===grid[gridSize*currentRow+currentColumn])break;if(0!==fixedLength&&newVertices.length===fixedLength)break}}async function colorGraph(linearColoring=!1){var connectionDirections=[];for(let i=0;i<gridSize;i++){connectionDirections[i]=[];for(let j=0;j<gridSize;j++)connectionDirections[i][j]=[]}for(let i=0;i<edgesInTree.length;i++){var row1=edgesInTree[i][0][0],column1=edgesInTree[i][0][1],row2=edgesInTree[i][1][0],column2=edgesInTree[i][1][1];row1===row2?(connectionDirections[row1][Math.min(column1,column2)].includes(1)||connectionDirections[row1][Math.min(column1,column2)].push(1),connectionDirections[row2][Math.max(column1,column2)].includes(3)||connectionDirections[row2][Math.max(column1,column2)].push(3)):(connectionDirections[Math.min(row1,row2)][column1].includes(2)||connectionDirections[Math.min(row1,row2)][column1].push(2),connectionDirections[Math.max(row1,row2)][column1].includes(0)||connectionDirections[Math.max(row1,row2)][column2].push(0))}var edgesByDistance=[];let activePaths=[];activePaths=gridSize%2==1?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];var distanceFromCenter=[];for(let i=0;i<gridSize;i++){distanceFromCenter[i]=[];for(let j=0;j<gridSize;j++)distanceFromCenter[i][j]=-1}for(;0<activePaths.length;){var numActivePaths=activePaths.length;for(let i=0;i<numActivePaths;i++){var row=activePaths[i][0],column=activePaths[i][1],distance=activePaths[i][2];distanceFromCenter[row][column]=distance,connectionDirections[row][column].includes(0)&&-1===distanceFromCenter[row-1][column]&&(activePaths.push([row-1,column,distance+1]),edgesByDistance.push([[row,column],[row-1,column],distance])),connectionDirections[row][column].includes(1)&&-1===distanceFromCenter[row][column+1]&&(activePaths.push([row,column+1,distance+1]),edgesByDistance.push([[row,column],[row,column+1],distance])),connectionDirections[row][column].includes(2)&&-1===distanceFromCenter[row+1][column]&&(activePaths.push([row+1,column,distance+1]),edgesByDistance.push([[row,column],[row+1,column],distance])),connectionDirections[row][column].includes(3)&&-1===distanceFromCenter[row][column-1]&&(activePaths.push([row,column-1,distance+1]),edgesByDistance.push([[row,column],[row,column-1],distance]))}activePaths.splice(0,numActivePaths)}edgesByDistance.sort((a,b)=>a[2]-b[2]);var maxDistance=7*edgesByDistance[edgesByDistance.length-1][2]/6,distanceBreaks=[0];let currentDistance=0;for(let i=0;i<edgesByDistance.length;i++)edgesByDistance[i][2]>currentDistance&&(distanceBreaks.push(i),currentDistance++);distanceBreaks.push(edgesByDistance.length);for(let i=0;i<distanceBreaks.length;i++){let j=0;var index=Math.min(distanceBreaks[i],edgesByDistance.length-1),rgb=HSVtoRGB(linearColoring?edgesByDistance[index][2]/maxDistance:distanceBreaks[i+1]/edgesByDistance.length*6/7,1,1);for(j=distanceBreaks[i];j<distanceBreaks[i+1]-1;j++)drawLine(edgesByDistance[j][0][0],edgesByDistance[j][0][1],edgesByDistance[j][1][0],edgesByDistance[j][1][1],`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`,0);edgesByDistance[j]&&(maximumSpeed?drawLine(edgesByDistance[j][0][0],edgesByDistance[j][0][1],edgesByDistance[j][1][0],edgesByDistance[j][1][1],`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`,24):await drawLine(edgesByDistance[j][0][0],edgesByDistance[j][0][1],edgesByDistance[j][1][0],edgesByDistance[j][1][1],`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`,24))}}async function drawLine(row1,column1,row2,column2,color,delay){if(column1===column2){var x=column1,row2=Math.min(row1,row2);noBorders?postMessage([x,row2,1,2,color]):postMessage([2*x+1,2*row2+1,1,3,color])}else{const x=Math.min(column1,column2),y=row1;noBorders?postMessage([x,y,2,1,color]):postMessage([2*x+1,2*y+1,3,1,color])}await new Promise(resolve=>setTimeout(resolve,delay))}function vertexInArray(element,array){for(let i=0;i<array.length;i++)if(array[i][0]===element[0]&&array[i][1]===element[1])return i;return-1}function HSVtoRGB(h,s,v){let r,g,b;var i=Math.floor(6*h),h=6*h-i,p=v*(1-s),q=v*(1-h*s),t=v*(1-(1-h)*s);switch(i%6){case 0:r=v,g=t,b=p;break;case 1:r=q,g=v,b=p;break;case 2:r=p,g=v,b=t;break;case 3:r=p,g=q,b=v;break;case 4:r=t,g=p,b=v;break;case 5:r=v,g=p,b=q}return[Math.round(255*r),Math.round(255*g),Math.round(255*b)]}onmessage=async function(e){gridSize=e.data[0],maximumSpeed=e.data[1],noBorders=e.data[2],reverseGenerateSkeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.min.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.min.js"),await drawWilsonGraph(),await colorGraph(),postMessage(["done"])}};