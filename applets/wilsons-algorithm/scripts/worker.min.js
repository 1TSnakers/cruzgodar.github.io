"use strict";onmessage=async function(e){gridSize=e.data[0],maximumSpeed=e.data[1],noBorders=e.data[2],reverseGenerateSkeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js"),await drawWilsonGraph(),await colorGraph(),postMessage(["done"])}};let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[],verticesInTree=[],grid=[],newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,lastDirection=null,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;function drawWilsonGraph(){return new Promise(async function(e,r){edgesInTree=[],verticesNotInTree=[];for(let n=0;n<gridSize;n++)for(let t=0;t<gridSize;t++)verticesNotInTree[gridSize*n+t]=[n,t],grid[gridSize*n+t]=0;for(;verticesNotInTree.length>0;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++);e()})}function wilsonStep(){return new Promise(async function(e,r){if(newVertices=[],reverseGenerateSkeleton){if(0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5)),jsRandomWalk(100),newVertices.splice(newVertices.length-1,1),newVertices.length<99){if(randomWalkFromEndpointAttmepts<100)randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp;else if(0!==verticesInTree.length&&100===randomWalkFromEndpointAttmepts){randomWalkFromEndpointAttmepts=0;let n=Math.floor(Math.random()*verticesInTree.length);currentRow=verticesInTree[n][0],currentColumn=verticesInTree[n][1]}e();return}randomWalkFromEndpointAttmepts=0,currentRowBaseCamp=newVertices[newVertices.length-2][0],currentColumnBaseCamp=newVertices[newVertices.length-2][1],currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp,++numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{let t=Math.floor(Math.random()*verticesNotInTree.length);if(currentRow=verticesNotInTree[t][0],currentColumn=verticesNotInTree[t][1],0===edgesInTree.length){let i=5*gridSize;gridSize<=100?i=gridSize:gridSize<=300&&(i=3*gridSize),randomWalk(i),postMessage(["log","Got it in time!"])}else randomWalk()}for(let o=0;o<newVertices.length-1;o++)maximumSpeed?drawLine(newVertices[o][0],newVertices[o][1],newVertices[o+1][0],newVertices[o+1][1],"rgb(255, 255, 255)",0):await drawLine(newVertices[o][0],newVertices[o][1],newVertices[o+1][0],newVertices[o+1][1],"rgb(255, 255, 255)",300/gridSize);for(let l=0;l<newVertices.length;l++){grid[gridSize*newVertices[l][0]+newVertices[l][1]]=1;let s=vertexInArray(newVertices[l],verticesNotInTree);-1!==s&&(verticesNotInTree.splice(s,1),verticesInTree.push(newVertices[l])),l!==newVertices.length-1&&edgesInTree.push([newVertices[l],newVertices[l+1]])}e()})}function wasmRandomWalk(e=0){let r=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,e,currentRow,currentColumn],{heapIn:"HEAPU32"}),n=Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT];for(let t=2;t<2*n;t+=2)newVertices.push([Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+t],Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+t+1]]);Module.ccall("free_from_js",null,["number"],[r]),!1===reverseGenerateSkeleton&&n<gridSize/10?10==++numShortPathsInARow&&(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."])):numShortPathsInARow=0}function jsRandomWalk(e=0){for(newVertices=[[currentRow,currentColumn]];;){let r=[],n=(r=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*r.length)];0===n?currentRow--:1===n?currentColumn++:2===n?currentRow++:currentColumn--;let t=vertexInArray([currentRow,currentColumn],newVertices);if(-1!==t?(currentRow=newVertices[t][0],currentColumn=newVertices[t][1],newVertices=newVertices.slice(0,t+1)):newVertices.push([currentRow,currentColumn]),1===grid[gridSize*currentRow+currentColumn]||0!==e&&newVertices.length===e)break}}function colorGraph(){return new Promise(async function(e,r){let n=[];for(let t=0;t<gridSize;t++){n[t]=[];for(let i=0;i<gridSize;i++)n[t][i]=[]}for(let o=0;o<edgesInTree.length;o++){let l=edgesInTree[o][0][0],s=edgesInTree[o][0][1],c=edgesInTree[o][1][0],u=edgesInTree[o][1][1];l===c?(n[l][Math.min(s,u)].includes(1)||n[l][Math.min(s,u)].push(1),n[c][Math.max(s,u)].includes(3)||n[c][Math.max(s,u)].push(3)):(n[Math.min(l,c)][s].includes(2)||n[Math.min(l,c)][s].push(2),n[Math.max(l,c)][s].includes(0)||n[Math.max(l,c)][u].push(0))}let a=[],d=[];d=gridSize%2==1?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];let _=[];for(let m=0;m<gridSize;m++){_[m]=[];for(let $=0;$<gridSize;$++)_[m][$]=-1}for(;d.length>0;){let g=d.length;for(let w=0;w<g;w++){let S=d[w][0],p=d[w][1],f=d[w][2];_[S][p]=f,n[S][p].includes(0)&&-1===_[S-1][p]&&(d.push([S-1,p,f+1]),a.push([[S,p],[S-1,p],f])),n[S][p].includes(1)&&-1===_[S][p+1]&&(d.push([S,p+1,f+1]),a.push([[S,p],[S,p+1],f])),n[S][p].includes(2)&&-1===_[S+1][p]&&(d.push([S+1,p,f+1]),a.push([[S,p],[S+1,p],f])),n[S][p].includes(3)&&-1===_[S][p-1]&&(d.push([S,p-1,f+1]),a.push([[S,p],[S,p-1],f]))}d.splice(0,g)}a.sort((e,r)=>e[2]-r[2]);let h=7*a[a.length-1][2]/6,z=[0],R=0;for(let V=0;V<a.length;V++)a[V][2]>R&&(z.push(V),R++);z.push(a.length);for(let I=0;I<z.length;I++){let C=0;for(C=z[I];C<z[I+1]-1;C++){let T=HSVtoRGB(a[C][2]/h,1,1);drawLine(a[C][0][0],a[C][0][1],a[C][1][0],a[C][1][1],`rgb(${T[0]}, ${T[1]}, ${T[2]})`,0)}let k=HSVtoRGB(a[C][2]/h,1,1);await drawLine(a[C][0][0],a[C][0][1],a[C][1][0],a[C][1][1],`rgb(${k[0]}, ${k[1]}, ${k[2]})`,24)}e()})}function drawLine(e,r,n,t,i,o){return new Promise(function(l,s){if(r===t){let c=r,u=Math.min(e,n);noBorders?postMessage([c,u,1,2,i]):postMessage([2*c+1,2*u+1,1,3,i])}else{let a=Math.min(r,t),d=e;noBorders?postMessage([a,d,2,1,i]):postMessage([2*a+1,2*d+1,3,1,i])}setTimeout(l,o)})}function vertexInArray(e,r){for(let n=0;n<r.length;n++)if(r[n][0]===e[0]&&r[n][1]===e[1])return n;return -1}function HSVtoRGB(e,r,n){let t,i,o,l,s,c,u,a;switch(l=Math.floor(6*e),s=6*e-l,c=n*(1-r),u=n*(1-s*r),a=n*(1-(1-s)*r),l%6){case 0:t=n,i=a,o=c;break;case 1:t=u,i=n,o=c;break;case 2:t=c,i=n,o=a;break;case 3:t=c,i=u,o=n;break;case 4:t=a,i=c,o=n;break;case 5:t=n,i=c,o=u}return[Math.round(255*t),Math.round(255*i),Math.round(255*o)]}