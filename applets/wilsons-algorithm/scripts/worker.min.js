onmessage=async function(e){gridSize=e.data[0];maximumSpeed=e.data[1];noBorders=e.data[2];reverseGenerateSkeleton=e.data[3];importScripts("/applets/wilsons-algorithm/scripts/random-walk.js");Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js");await drawWilsonGraph();await colorGraph();postMessage(["done"])}};
let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[],verticesInTree=[],grid=[],newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,lastDirection=null,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;
function drawWilsonGraph(){return new Promise(async function(e,a){edgesInTree=[];verticesNotInTree=[];for(a=0;a<gridSize;a++)for(let b=0;b<gridSize;b++)verticesNotInTree[gridSize*a+b]=[a,b],grid[gridSize*a+b]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++);e()})}
function wilsonStep(){return new Promise(async function(e,a){newVertices=[];if(reverseGenerateSkeleton){0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5));jsRandomWalk(100);newVertices.splice(newVertices.length-1,1);if(99>newVertices.length){100>randomWalkFromEndpointAttmepts?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&
100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,a=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[a][0],currentColumn=verticesInTree[a][1]);e();return}randomWalkFromEndpointAttmepts=0;currentRowBaseCamp=newVertices[newVertices.length-2][0];currentColumnBaseCamp=newVertices[newVertices.length-2][1];currentRow=currentRowBaseCamp;currentColumn=currentColumnBaseCamp;numSkeletonLines++;numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=
!1,postMessage(["log","Going back to regular LERWs"]))}else a=Math.floor(Math.random()*verticesNotInTree.length),currentRow=verticesNotInTree[a][0],currentColumn=verticesNotInTree[a][1],0===edgesInTree.length?(a=5*gridSize,100>=gridSize?a=gridSize:300>=gridSize&&(a=3*gridSize),randomWalk(a),postMessage(["log","Got it in time!"])):randomWalk();for(a=0;a<newVertices.length-1;a++)maximumSpeed?drawLine(newVertices[a][0],newVertices[a][1],newVertices[a+1][0],newVertices[a+1][1],"rgb(255, 255, 255)",0):
await drawLine(newVertices[a][0],newVertices[a][1],newVertices[a+1][0],newVertices[a+1][1],"rgb(255, 255, 255)",300/gridSize);for(a=0;a<newVertices.length;a++){grid[gridSize*newVertices[a][0]+newVertices[a][1]]=1;let b=vertexInArray(newVertices[a],verticesNotInTree);-1!==b&&(verticesNotInTree.splice(b,1),verticesInTree.push(newVertices[a]));a!==newVertices.length-1&&edgesInTree.push([newVertices[a],newVertices[a+1]])}e()})}
function wasmRandomWalk(e=0){e=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,e,currentRow,currentColumn],{heapIn:"HEAPU32"});let a=Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT];for(let b=2;b<2*a;b+=2)newVertices.push([Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT+b],Module.HEAPU32[e/Uint32Array.BYTES_PER_ELEMENT+b+1]]);Module.ccall("free_from_js",null,["number"],[e]);!1===reverseGenerateSkeleton&&a<gridSize/10?(numShortPathsInARow++,10==numShortPathsInARow&&
(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."]))):numShortPathsInARow=0}
function jsRandomWalk(e=0){for(newVertices=[[currentRow,currentColumn]];;){var a=void 0;a=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3];a=a[Math.floor(Math.random()*a.length)];0===a?currentRow--:1===a?currentColumn++:2===a?currentRow++:
currentColumn--;a=vertexInArray([currentRow,currentColumn],newVertices);-1!==a?(currentRow=newVertices[a][0],currentColumn=newVertices[a][1],newVertices=newVertices.slice(0,a+1)):newVertices.push([currentRow,currentColumn]);if(1===grid[gridSize*currentRow+currentColumn])break;else if(0!==e&&newVertices.length===e)break}}
function colorGraph(){return new Promise(async function(e,a){var b=[];for(a=0;a<gridSize;a++){b[a]=[];for(var d=0;d<gridSize;d++)b[a][d]=[]}for(a=0;a<edgesInTree.length;a++){d=edgesInTree[a][0][0];var f=edgesInTree[a][0][1],c=edgesInTree[a][1][0],h=edgesInTree[a][1][1];d===c?(b[d][Math.min(f,h)].includes(1)||b[d][Math.min(f,h)].push(1),b[c][Math.max(f,h)].includes(3)||b[c][Math.max(f,h)].push(3)):(b[Math.min(d,c)][f].includes(2)||b[Math.min(d,c)][f].push(2),b[Math.max(d,c)][f].includes(0)||b[Math.max(d,
c)][h].push(0))}a=[];d=[];d=1===gridSize%2?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];f=[];for(c=0;c<gridSize;c++)for(f[c]=[],h=0;h<gridSize;h++)f[c][h]=-1;for(;0<d.length;){c=d.length;for(h=0;h<c;h++){let g=d[h][0],k=d[h][1],l=d[h][2];f[g][k]=l;b[g][k].includes(0)&&-1===f[g-1][k]&&
(d.push([g-1,k,l+1]),a.push([[g,k],[g-1,k],l]));b[g][k].includes(1)&&-1===f[g][k+1]&&(d.push([g,k+1,l+1]),a.push([[g,k],[g,k+1],l]));b[g][k].includes(2)&&-1===f[g+1][k]&&(d.push([g+1,k,l+1]),a.push([[g,k],[g+1,k],l]));b[g][k].includes(3)&&-1===f[g][k-1]&&(d.push([g,k-1,l+1]),a.push([[g,k],[g,k-1],l]))}d.splice(0,c)}a.sort((g,k)=>g[2]-k[2]);b=7*a[a.length-1][2]/6;d=[0];f=0;for(c=0;c<a.length;c++)a[c][2]>f&&(d.push(c),f++);d.push(a.length);for(f=0;f<d.length;f++){c=0;for(c=d[f];c<d[f+1]-1;c++)h=HSVtoRGB(a[c][2]/
b,1,1),drawLine(a[c][0][0],a[c][0][1],a[c][1][0],a[c][1][1],`rgb(${h[0]}, ${h[1]}, ${h[2]})`,0);h=HSVtoRGB(a[c][2]/b,1,1);await drawLine(a[c][0][0],a[c][0][1],a[c][1][0],a[c][1][1],`rgb(${h[0]}, ${h[1]}, ${h[2]})`,24)}e()})}function drawLine(e,a,b,d,f,c){return new Promise(function(h,g){a===d?(g=Math.min(e,b),noBorders?postMessage([a,g,1,2,f]):postMessage([2*a+1,2*g+1,1,3,f])):(g=Math.min(a,d),noBorders?postMessage([g,e,2,1,f]):postMessage([2*g+1,2*e+1,3,1,f]));setTimeout(h,c)})}
function vertexInArray(e,a){for(let b=0;b<a.length;b++)if(a[b][0]===e[0]&&a[b][1]===e[1])return b;return-1}function HSVtoRGB(e,a,b){let d,f,c,h,g,k;h=Math.floor(6*e);g=6*e-h;e=b*(1-a);k=b*(1-g*a);a=b*(1-(1-g)*a);switch(h%6){case 0:d=b;f=a;c=e;break;case 1:d=k;f=b;c=e;break;case 2:d=e;f=b;c=a;break;case 3:d=e;f=k;c=b;break;case 4:d=a;f=e;c=b;break;case 5:d=b,f=e,c=k}return[Math.round(255*d),Math.round(255*f),Math.round(255*c)]};
