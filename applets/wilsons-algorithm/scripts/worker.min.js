onmessage=async function(f){gridSize=f.data[0];maximumSpeed=f.data[1];noBorders=f.data[2];reverseGenerateSkeleton=f.data[3];importScripts("/applets/wilsons-algorithm/scripts/random-walk.js");Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js");await drawWilsonGraph();await colorGraph();postMessage(["done"])}};
let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[],verticesInTree=[],grid=[],newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,lastDirection=null,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;
function drawWilsonGraph(){return new Promise(async function(f,a){edgesInTree=[];verticesNotInTree=[];for(a=0;a<gridSize;a++)for(let b=0;b<gridSize;b++)verticesNotInTree[gridSize*a+b]=[a,b],grid[gridSize*a+b]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++);f()})}
function wilsonStep(){return new Promise(async function(f,a){newVertices=[];if(reverseGenerateSkeleton){0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5));jsRandomWalk(100);newVertices.splice(newVertices.length-1,1);if(99>newVertices.length){100>randomWalkFromEndpointAttmepts?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&
100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,a=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[a][0],currentColumn=verticesInTree[a][1]);f();return}randomWalkFromEndpointAttmepts=0;currentRowBaseCamp=newVertices[newVertices.length-2][0];currentColumnBaseCamp=newVertices[newVertices.length-2][1];currentRow=currentRowBaseCamp;currentColumn=currentColumnBaseCamp;numSkeletonLines++;numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=
!1,postMessage(["log","Going back to regular LERWs"]))}else a=Math.floor(Math.random()*verticesNotInTree.length),currentRow=verticesNotInTree[a][0],currentColumn=verticesNotInTree[a][1],0===edgesInTree.length?(a=5*gridSize,100>=gridSize?a=gridSize:300>=gridSize&&(a=3*gridSize),randomWalk(a),postMessage(["log","Got it in time!"])):randomWalk();for(a=0;a<newVertices.length-1;a++)maximumSpeed?drawLine(newVertices[a][0],newVertices[a][1],newVertices[a+1][0],newVertices[a+1][1],"rgb(255, 255, 255)",0):
await drawLine(newVertices[a][0],newVertices[a][1],newVertices[a+1][0],newVertices[a+1][1],"rgb(255, 255, 255)",300/gridSize);for(a=0;a<newVertices.length;a++){grid[gridSize*newVertices[a][0]+newVertices[a][1]]=1;let b=vertexInArray(newVertices[a],verticesNotInTree);-1!==b&&(verticesNotInTree.splice(b,1),verticesInTree.push(newVertices[a]));a!==newVertices.length-1&&edgesInTree.push([newVertices[a],newVertices[a+1]])}f()})}
function wasmRandomWalk(f=0){f=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,f,currentRow,currentColumn],{heapIn:"HEAPU32"});let a=Module.HEAPU32[f/Uint32Array.BYTES_PER_ELEMENT];for(let b=2;b<2*a;b+=2)newVertices.push([Module.HEAPU32[f/Uint32Array.BYTES_PER_ELEMENT+b],Module.HEAPU32[f/Uint32Array.BYTES_PER_ELEMENT+b+1]]);Module.ccall("free_from_js",null,["number"],[f]);!1===reverseGenerateSkeleton&&a<gridSize/10?(numShortPathsInARow++,10==numShortPathsInARow&&
(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."]))):numShortPathsInARow=0}
function jsRandomWalk(f=0){for(newVertices=[[currentRow,currentColumn]];;){var a=void 0;a=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3];a=a[Math.floor(Math.random()*a.length)];0===a?currentRow--:1===a?currentColumn++:2===a?currentRow++:
currentColumn--;a=vertexInArray([currentRow,currentColumn],newVertices);-1!==a?(currentRow=newVertices[a][0],currentColumn=newVertices[a][1],newVertices=newVertices.slice(0,a+1)):newVertices.push([currentRow,currentColumn]);if(1===grid[gridSize*currentRow+currentColumn])break;else if(0!==f&&newVertices.length===f)break}}
function colorGraph(){return new Promise(async function(f,a){a=[];for(var b=0;b<gridSize;b++){a[b]=[];for(var d=0;d<gridSize;d++)a[b][d]=[]}for(b=0;b<edgesInTree.length;b++){d=edgesInTree[b][0][0];var g=edgesInTree[b][0][1],c=edgesInTree[b][1][0],k=edgesInTree[b][1][1];d===c?(a[d][Math.min(g,k)].includes(1)||a[d][Math.min(g,k)].push(1),a[c][Math.max(g,k)].includes(3)||a[c][Math.max(g,k)].push(3)):(a[Math.min(d,c)][g].includes(2)||a[Math.min(d,c)][g].push(2),a[Math.max(d,c)][g].includes(0)||a[Math.max(d,
c)][k].push(0))}b=[];d=[];d=1===gridSize%2?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];g=[];for(c=0;c<gridSize;c++)for(g[c]=[],k=0;k<gridSize;k++)g[c][k]=-1;for(;0<d.length;){c=d.length;for(k=0;k<c;k++){let e=d[k][0],h=d[k][1],l=d[k][2];g[e][h]=l;a[e][h].includes(0)&&-1===g[e-1][h]&&
(d.push([e-1,h,l+1]),b.push([[e,h],[e-1,h],l]));a[e][h].includes(1)&&-1===g[e][h+1]&&(d.push([e,h+1,l+1]),b.push([[e,h],[e,h+1],l]));a[e][h].includes(2)&&-1===g[e+1][h]&&(d.push([e+1,h,l+1]),b.push([[e,h],[e+1,h],l]));a[e][h].includes(3)&&-1===g[e][h-1]&&(d.push([e,h-1,l+1]),b.push([[e,h],[e,h-1],l]))}d.splice(0,c)}b.sort((e,h)=>e[2]-h[2]);a=7*b[b.length-1][2]/6;d=[0];g=0;for(c=0;c<b.length;c++)b[c][2]>g&&(d.push(c),g++);d.push(b.length);for(g=0;g<d.length;g++){c=0;for(c=d[g];c<d[g+1]-1;c++)k=HSVtoRGB(b[c][2]/
a,1,1),drawLine(b[c][0][0],b[c][0][1],b[c][1][0],b[c][1][1],`rgb(${k[0]}, ${k[1]}, ${k[2]})`,0);try{const e=HSVtoRGB(b[c][2]/a,1,1);await drawLine(b[c][0][0],b[c][0][1],b[c][1][0],b[c][1][1],`rgb(${e[0]}, ${e[1]}, ${e[2]})`,24)}catch(e){break}}f()})}
function drawLine(f,a,b,d,g,c){return new Promise(function(k,e){a===d?(e=Math.min(f,b),noBorders?postMessage([a,e,1,2,g]):postMessage([2*a+1,2*e+1,1,3,g])):(e=Math.min(a,d),noBorders?postMessage([e,f,2,1,g]):postMessage([2*e+1,2*f+1,3,1,g]));setTimeout(k,c)})}function vertexInArray(f,a){for(let b=0;b<a.length;b++)if(a[b][0]===f[0]&&a[b][1]===f[1])return b;return-1}
function HSVtoRGB(f,a,b){let d,g,c,k,e,h;k=Math.floor(6*f);e=6*f-k;f=b*(1-a);h=b*(1-e*a);a=b*(1-(1-e)*a);switch(k%6){case 0:d=b;g=a;c=f;break;case 1:d=h;g=b;c=f;break;case 2:d=f;g=b;c=a;break;case 3:d=f;g=h;c=b;break;case 4:d=a;g=f;c=b;break;case 5:d=b,g=f,c=h}return[Math.round(255*d),Math.round(255*g),Math.round(255*c)]};
