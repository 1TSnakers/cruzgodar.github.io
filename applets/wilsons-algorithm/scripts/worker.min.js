"use strict";onmessage=async function(e){grid_size=e.data[0],maximum_speed=e.data[1],no_borders=e.data[2],reverse_generate_skeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js"),await draw_wilson_graph(),await color_graph(),postMessage(["done"])}};let grid_size=null,maximum_speed=null,no_borders=null,reverse_generate_skeleton=null,num_skeleton_lines=0,edges_in_tree=[],vertices_not_in_tree=[],vertices_in_tree=[],grid=[],new_vertices=[],current_row=null,current_column=null,current_row_base_camp=null,current_column_base_camp=null,random_walk_from_endpoint_attmepts=0,last_direction=null,random_walk=wasm_random_walk,num_short_paths_in_a_row=0,percent_step=1;function draw_wilson_graph(){return new Promise(async function(e,r){edges_in_tree=[],vertices_not_in_tree=[];for(let e=0;e<grid_size;e++)for(let r=0;r<grid_size;r++)vertices_not_in_tree[grid_size*e+r]=[e,r],grid[grid_size*e+r]=0;for(;vertices_not_in_tree.length>0;)maximum_speed?wilson_step():await wilson_step(),vertices_in_tree.length>=grid_size*grid_size/100*percent_step&&(postMessage(["progress",percent_step]),percent_step++);e()})}function wilson_step(){return new Promise(async function(e,r){if(new_vertices=[],reverse_generate_skeleton){if(0===vertices_in_tree.length&&(current_row=Math.floor(Math.random()*grid_size/5+2*grid_size/5),current_column=Math.floor(Math.random()*grid_size/5+2*grid_size/5)),js_random_walk(100),new_vertices.splice(new_vertices.length-1,1),new_vertices.length<99){if(random_walk_from_endpoint_attmepts<100)random_walk_from_endpoint_attmepts++,current_row=current_row_base_camp,current_column=current_column_base_camp;else if(0!==vertices_in_tree.length&&100===random_walk_from_endpoint_attmepts){random_walk_from_endpoint_attmepts=0;let e=Math.floor(Math.random()*vertices_in_tree.length);current_row=vertices_in_tree[e][0],current_column=vertices_in_tree[e][1]}return void e()}random_walk_from_endpoint_attmepts=0,current_row_base_camp=new_vertices[new_vertices.length-2][0],current_column_base_camp=new_vertices[new_vertices.length-2][1],current_row=current_row_base_camp,current_column=current_column_base_camp,++num_skeleton_lines===Math.floor(grid_size/5)&&(reverse_generate_skeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{let e=Math.floor(Math.random()*vertices_not_in_tree.length);if(current_row=vertices_not_in_tree[e][0],current_column=vertices_not_in_tree[e][1],0===edges_in_tree.length){let e=5*grid_size;grid_size<=100?e=grid_size:grid_size<=300&&(e=3*grid_size),random_walk(e),postMessage(["log","Got it in time!"])}else random_walk()}for(let e=0;e<new_vertices.length-1;e++)maximum_speed?draw_line(new_vertices[e][0],new_vertices[e][1],new_vertices[e+1][0],new_vertices[e+1][1],"rgb(255, 255, 255)",0):await draw_line(new_vertices[e][0],new_vertices[e][1],new_vertices[e+1][0],new_vertices[e+1][1],"rgb(255, 255, 255)",300/grid_size);for(let e=0;e<new_vertices.length;e++){grid[grid_size*new_vertices[e][0]+new_vertices[e][1]]=1;let r=vertex_in_array(new_vertices[e],vertices_not_in_tree);-1!==r&&(vertices_not_in_tree.splice(r,1),vertices_in_tree.push(new_vertices[e])),e!==new_vertices.length-1&&edges_in_tree.push([new_vertices[e],new_vertices[e+1]])}e()})}function wasm_random_walk(e=0){let r=ccallArrays("random_walk","number",["number","array","number","number","number"],[grid_size,grid,e,current_row,current_column],{heapIn:"HEAPU32"}),t=Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT];for(let e=2;e<2*t;e+=2)new_vertices.push([Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e],Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e+1]]);Module.ccall("free_from_js",null,["number"],[r]),!1===reverse_generate_skeleton&&t<grid_size/10?10==++num_short_paths_in_a_row&&(random_walk=js_random_walk,postMessage(["log","Switching to JS..."])):num_short_paths_in_a_row=0}function js_random_walk(e=0){for(new_vertices=[[current_row,current_column]];;){let r=[],t=(r=0===current_row&&0===current_column?[1,2]:current_row===grid_size-1&&0===current_column?[0,1]:0===current_row&&current_column===grid_size-1?[2,3]:current_row===grid_size-1&&current_column===grid_size-1?[0,3]:0===current_row?[1,2,3]:current_row===grid_size-1?[0,1,3]:0===current_column?[0,1,2]:current_column===grid_size-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*r.length)];0===t?current_row--:1===t?current_column++:2===t?current_row++:current_column--;let n=vertex_in_array([current_row,current_column],new_vertices);if(-1!==n?(current_row=new_vertices[n][0],current_column=new_vertices[n][1],new_vertices=new_vertices.slice(0,n+1)):new_vertices.push([current_row,current_column]),1===grid[grid_size*current_row+current_column])break;if(0!==e&&new_vertices.length===e)break}}function color_graph(){return new Promise(async function(e,r){let t=[];for(let e=0;e<grid_size;e++){t[e]=[];for(let r=0;r<grid_size;r++)t[e][r]=[]}for(let e=0;e<edges_in_tree.length;e++){let r=edges_in_tree[e][0][0],n=edges_in_tree[e][0][1],_=edges_in_tree[e][1][0],i=edges_in_tree[e][1][1];r===_?(t[r][Math.min(n,i)].includes(1)||t[r][Math.min(n,i)].push(1),t[_][Math.max(n,i)].includes(3)||t[_][Math.max(n,i)].push(3)):(t[Math.min(r,_)][n].includes(2)||t[Math.min(r,_)][n].push(2),t[Math.max(r,_)][n].includes(0)||t[Math.max(r,_)][i].push(0))}let n=[],_=[];_=grid_size%2==1?[[Math.floor(grid_size/2),Math.floor(grid_size/2),0]]:[[Math.floor(grid_size/2)-1,Math.floor(grid_size/2)-1,0],[Math.floor(grid_size/2)-1,Math.floor(grid_size/2),0],[Math.floor(grid_size/2),Math.floor(grid_size/2)-1,0],[Math.floor(grid_size/2),Math.floor(grid_size/2),0]];let i=[];for(let e=0;e<grid_size;e++){i[e]=[];for(let r=0;r<grid_size;r++)i[e][r]=-1}for(;_.length>0;){let e=_.length;for(let r=0;r<e;r++){let e=_[r][0],s=_[r][1],o=_[r][2];i[e][s]=o,t[e][s].includes(0)&&-1===i[e-1][s]&&(_.push([e-1,s,o+1]),n.push([[e,s],[e-1,s],o])),t[e][s].includes(1)&&-1===i[e][s+1]&&(_.push([e,s+1,o+1]),n.push([[e,s],[e,s+1],o])),t[e][s].includes(2)&&-1===i[e+1][s]&&(_.push([e+1,s,o+1]),n.push([[e,s],[e+1,s],o])),t[e][s].includes(3)&&-1===i[e][s-1]&&(_.push([e,s-1,o+1]),n.push([[e,s],[e,s-1],o]))}_.splice(0,e)}n.sort((e,r)=>e[2]-r[2]);let s=7*n[n.length-1][2]/6,o=[0],a=0;for(let e=0;e<n.length;e++)n[e][2]>a&&(o.push(e),a++);o.push(n.length);for(let e=0;e<o.length;e++){let r=0;for(r=o[e];r<o[e+1]-1;r++){let e=HSVtoRGB(n[r][2]/s,1,1);draw_line(n[r][0][0],n[r][0][1],n[r][1][0],n[r][1][1],`rgb(${e[0]}, ${e[1]}, ${e[2]})`,0)}let t=HSVtoRGB(n[r][2]/s,1,1);await draw_line(n[r][0][0],n[r][0][1],n[r][1][0],n[r][1][1],`rgb(${t[0]}, ${t[1]}, ${t[2]})`,24)}e()})}function draw_line(e,r,t,n,_,i){return new Promise(function(s,o){if(r===n){let n=r,i=Math.min(e,t);no_borders?postMessage([n,i,1,2,_]):postMessage([2*n+1,2*i+1,1,3,_])}else{let t=Math.min(r,n),i=e;no_borders?postMessage([t,i,2,1,_]):postMessage([2*t+1,2*i+1,3,1,_])}setTimeout(s,i)})}function vertex_in_array(e,r){for(let t=0;t<r.length;t++)if(r[t][0]===e[0]&&r[t][1]===e[1])return t;return-1}function HSVtoRGB(e,r,t){let n,_,i,s,o,a,l,c;switch(a=t*(1-r),l=t*(1-(o=6*e-(s=Math.floor(6*e)))*r),c=t*(1-(1-o)*r),s%6){case 0:n=t,_=c,i=a;break;case 1:n=l,_=t,i=a;break;case 2:n=a,_=t,i=c;break;case 3:n=a,_=l,i=t;break;case 4:n=c,_=a,i=t;break;case 5:n=t,_=a,i=l}return[Math.round(255*n),Math.round(255*_),Math.round(255*i)]}