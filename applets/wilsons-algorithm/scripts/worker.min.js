"use strict";onmessage=async function(e){gridSize=e.data[0],maximumSpeed=e.data[1],noBorders=e.data[2],reverseGenerateSkeleton=e.data[3],importScripts("/applets/wilsons-algorithm/scripts/random-walk.js"),Module.onRuntimeInitialized=async function(){importScripts("/scripts/wasm-arrays.min.js"),await drawWilsonGraph(),await colorGraph(),postMessage(["done"])}};let gridSize=null,maximumSpeed=null,noBorders=null,reverseGenerateSkeleton=null,numSkeletonLines=0,edgesInTree=[],verticesNotInTree=[],verticesInTree=[],grid=[],newVertices=[],currentRow=null,currentColumn=null,currentRowBaseCamp=null,currentColumnBaseCamp=null,randomWalkFromEndpointAttmepts=0,randomWalk=wasmRandomWalk,numShortPathsInARow=0,percentStep=1;async function drawWilsonGraph(){edgesInTree=[],verticesNotInTree=[];for(let r=0;r<gridSize;r++)for(let e=0;e<gridSize;e++)verticesNotInTree[gridSize*r+e]=[r,e],grid[gridSize*r+e]=0;for(;0<verticesNotInTree.length;)maximumSpeed?wilsonStep():await wilsonStep(),verticesInTree.length>=gridSize*gridSize/100*percentStep&&(postMessage(["progress",percentStep]),percentStep++)}async function wilsonStep(){if(newVertices=[],reverseGenerateSkeleton){if(0===verticesInTree.length&&(currentRow=Math.floor(Math.random()*gridSize/5+2*gridSize/5),currentColumn=Math.floor(Math.random()*gridSize/5+2*gridSize/5)),jsRandomWalk(100),newVertices.splice(newVertices.length-1,1),newVertices.length<99)return void(randomWalkFromEndpointAttmepts<100?(randomWalkFromEndpointAttmepts++,currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp):0!==verticesInTree.length&&100===randomWalkFromEndpointAttmepts&&(randomWalkFromEndpointAttmepts=0,e=Math.floor(Math.random()*verticesInTree.length),currentRow=verticesInTree[e][0],currentColumn=verticesInTree[e][1]));randomWalkFromEndpointAttmepts=0,currentRowBaseCamp=newVertices[newVertices.length-2][0],currentColumnBaseCamp=newVertices[newVertices.length-2][1],currentRow=currentRowBaseCamp,currentColumn=currentColumnBaseCamp,++numSkeletonLines===Math.floor(gridSize/5)&&(reverseGenerateSkeleton=!1,postMessage(["log","Going back to regular LERWs"]))}else{var e=Math.floor(Math.random()*verticesNotInTree.length);if(currentRow=verticesNotInTree[e][0],currentColumn=verticesNotInTree[e][1],0===edgesInTree.length){let e=5*gridSize;gridSize<=100?e=gridSize:gridSize<=300&&(e=3*gridSize),randomWalk(e),postMessage(["log","Got it in time!"])}else randomWalk()}for(let e=0;e<newVertices.length-1;e++)maximumSpeed?drawLine(newVertices[e][0],newVertices[e][1],newVertices[e+1][0],newVertices[e+1][1],"rgb(255, 255, 255)",0):await drawLine(newVertices[e][0],newVertices[e][1],newVertices[e+1][0],newVertices[e+1][1],"rgb(255, 255, 255)",300/gridSize);for(let e=0;e<newVertices.length;e++){grid[gridSize*newVertices[e][0]+newVertices[e][1]]=1;var r=vertexInArray(newVertices[e],verticesNotInTree);-1!==r&&(verticesNotInTree.splice(r,1),verticesInTree.push(newVertices[e])),e!==newVertices.length-1&&edgesInTree.push([newVertices[e],newVertices[e+1]])}}function wasmRandomWalk(e=0){var r=ccallArrays("random_walk","number",["number","array","number","number","number"],[gridSize,grid,e,currentRow,currentColumn],{heapIn:"HEAPU32"}),n=Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT];for(let e=2;e<2*n;e+=2)newVertices.push([Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e],Module.HEAPU32[r/Uint32Array.BYTES_PER_ELEMENT+e+1]]);Module.ccall("free_from_js",null,["number"],[r]),!1===reverseGenerateSkeleton&&n<gridSize/10?10==++numShortPathsInARow&&(randomWalk=jsRandomWalk,postMessage(["log","Switching to JS..."])):numShortPathsInARow=0}function jsRandomWalk(r=0){for(newVertices=[[currentRow,currentColumn]];;){let e=[];var n=(e=0===currentRow&&0===currentColumn?[1,2]:currentRow===gridSize-1&&0===currentColumn?[0,1]:0===currentRow&&currentColumn===gridSize-1?[2,3]:currentRow===gridSize-1&&currentColumn===gridSize-1?[0,3]:0===currentRow?[1,2,3]:currentRow===gridSize-1?[0,1,3]:0===currentColumn?[0,1,2]:currentColumn===gridSize-1?[0,2,3]:[0,1,2,3])[Math.floor(Math.random()*e.length)],n=(0===n?currentRow--:1===n?currentColumn++:2===n?currentRow++:currentColumn--,vertexInArray([currentRow,currentColumn],newVertices));if(-1!==n?(currentRow=newVertices[n][0],currentColumn=newVertices[n][1],newVertices=newVertices.slice(0,n+1)):newVertices.push([currentRow,currentColumn]),1===grid[gridSize*currentRow+currentColumn])break;if(0!==r&&newVertices.length===r)break}}async function colorGraph(){var n=[];for(let r=0;r<gridSize;r++){n[r]=[];for(let e=0;e<gridSize;e++)n[r][e]=[]}for(let e=0;e<edgesInTree.length;e++){var r=edgesInTree[e][0][0],t=edgesInTree[e][0][1],i=edgesInTree[e][1][0],o=edgesInTree[e][1][1];r===i?(n[r][Math.min(t,o)].includes(1)||n[r][Math.min(t,o)].push(1),n[i][Math.max(t,o)].includes(3)||n[i][Math.max(t,o)].push(3)):(n[Math.min(r,i)][t].includes(2)||n[Math.min(r,i)][t].push(2),n[Math.max(r,i)][t].includes(0)||n[Math.max(r,i)][o].push(0))}var a=[];let s=[];s=gridSize%2==1?[[Math.floor(gridSize/2),Math.floor(gridSize/2),0]]:[[Math.floor(gridSize/2)-1,Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2)-1,Math.floor(gridSize/2),0],[Math.floor(gridSize/2),Math.floor(gridSize/2)-1,0],[Math.floor(gridSize/2),Math.floor(gridSize/2),0]];var l=[];for(let r=0;r<gridSize;r++){l[r]=[];for(let e=0;e<gridSize;e++)l[r][e]=-1}for(;0<s.length;){var c=s.length;for(let e=0;e<c;e++){var u=s[e][0],d=s[e][1],m=s[e][2];l[u][d]=m,n[u][d].includes(0)&&-1===l[u-1][d]&&(s.push([u-1,d,m+1]),a.push([[u,d],[u-1,d],m])),n[u][d].includes(1)&&-1===l[u][d+1]&&(s.push([u,d+1,m+1]),a.push([[u,d],[u,d+1],m])),n[u][d].includes(2)&&-1===l[u+1][d]&&(s.push([u+1,d,m+1]),a.push([[u,d],[u+1,d],m])),n[u][d].includes(3)&&-1===l[u][d-1]&&(s.push([u,d-1,m+1]),a.push([[u,d],[u,d-1],m]))}s.splice(0,c)}a.sort((e,r)=>e[2]-r[2]);var g=7*a[a.length-1][2]/6,h=[0];let w=0;for(let e=0;e<a.length;e++)a[e][2]>w&&(h.push(e),w++);h.push(a.length);for(let r=0;r<h.length;r++){let e=0;for(e=h[r];e<h[r+1]-1;e++){var p=HSVtoRGB(a[e][2]/g,1,1);drawLine(a[e][0][0],a[e][0][1],a[e][1][0],a[e][1][1],`rgb(${p[0]}, ${p[1]}, ${p[2]})`,0)}try{var S=HSVtoRGB(a[e][2]/g,1,1);await drawLine(a[e][0][0],a[e][0][1],a[e][1][0],a[e][1][1],`rgb(${S[0]}, ${S[1]}, ${S[2]})`,24)}catch(e){break}}}async function drawLine(e,r,n,t,i,o){var a;r===t?(a=r,n=Math.min(e,n),noBorders?postMessage([a,n,1,2,i]):postMessage([2*a+1,2*n+1,1,3,i])):(a=Math.min(r,t),n=e,noBorders?postMessage([a,n,2,1,i]):postMessage([2*a+1,2*n+1,3,1,i])),await new Promise(e=>setTimeout(e,o))}function vertexInArray(r,n){for(let e=0;e<n.length;e++)if(n[e][0]===r[0]&&n[e][1]===r[1])return e;return-1}function HSVtoRGB(e,r,n){let t,i,o,a,s,l,c,u;switch(l=n*(1-r),c=n*(1-(s=6*e-(a=Math.floor(6*e)))*r),u=n*(1-(1-s)*r),a%6){case 0:t=n,i=u,o=l;break;case 1:t=c,i=n,o=l;break;case 2:t=l,i=n,o=u;break;case 3:t=l,i=c,o=n;break;case 4:t=u,i=l,o=n;break;case 5:t=n,i=l,o=c}return[Math.round(255*t),Math.round(255*i),Math.round(255*o)]}