import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class EllipticCurve extends AnimationFrameApplet{resolution=500;g2=-2;g3=2;constructor({canvas}){super(canvas);var e={shaders:{shader:`
			precision highp float;
			
			varying vec2 uv;
			
			uniform float step;
			
			uniform float g2Arg;
			uniform float g3Arg;
			
			const int maxIterations = 200;
			
			
			
			float f(vec2 z)
			{
				return z.y * z.y   -   z.x * z.x * z.x   -   g2Arg * z.x   -   g3Arg;
			}
			
			
			
			void main(void)
			{
				float threshhold = 4.0 * 1000.0;
				
				vec2 z = uv * 4.0;
				
				
				
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				
				
				
				for (int i = 0; i < maxIterations; i++)
				{
					float score = abs(f(z)) / threshhold;
					
					if (score < 1.0)
					{
						float adjacentScore = (abs(f(z + vec2(step, 0.0))) + abs(f(z - vec2(step, 0.0))) + abs(f(z + vec2(0.0, step))) + abs(f(z - vec2(0.0, step)))) / threshhold;
						
						if (adjacentScore >= 6.0)
						{
							gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
							
							return;
						}
					}
					
					threshhold /= 1.25;
				}
			}
		`,shader2:`
			precision highp float;
			precision highp sampler2D;
			
			varying vec2 uv;
			
			uniform sampler2D uTexture;
			
			uniform float textureStep;
			
			
			
			void main(void)
			{
				//Dilate the pixels to make a thicker line.
				vec2 center = (uv + vec2(1.0, 1.0)) / 2.0;
				
				float state = (4.0 * texture2D(uTexture, center).y +
				
					texture2D(uTexture, center + vec2(textureStep, 0.0)).y +
					texture2D(uTexture, center - vec2(textureStep, 0.0)).y +
					texture2D(uTexture, center + vec2(0.0, textureStep)).y +
					texture2D(uTexture, center - vec2(0.0, textureStep)).y +
					
					texture2D(uTexture, center + vec2(textureStep, textureStep)).y +
					texture2D(uTexture, center + vec2(textureStep, -textureStep)).y +
					texture2D(uTexture, center + vec2(-textureStep, textureStep)).y +
					texture2D(uTexture, center + vec2(-textureStep, -textureStep)).y
				) / 2.0;
				
				gl_FragColor = vec4(state, state, state, 1.0);
			}
		`},uniforms:{shader:{step:8/this.resolution,g2Arg:this.g2,g3Arg:this.g3},shader2:{textureStep:1/this.resolution}},canvasWidth:this.resolution,worldWidth:8,verbose:window.DEBUG};this.wilson=new WilsonGPU(canvas,e),this.wilson.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilson.useFramebuffer(null),this.resume()}run({g2,g3}){this.g2=g2,this.g3=g3,this.needNewFrame=!0}drawFrame(){this.wilson.useShader("shader"),this.wilson.setUniforms({g2Arg:this.g2,g3Arg:this.g3}),this.wilson.drawFrame();var i=this.wilson.readPixels(),o=[],a=this.resolution,e=this.wilson.canvasWidth;for(let r=2;r<this.wilson.canvasHeight-2;r++)for(let e=2;e<a-2;e++){var t=a*r+e;0!==i[4*t]&&i[4*(t-1)]+i[4*(t+1)]+i[4*(t-a)]+i[4*(t+a)]+i[4*(t-1-a)]+i[4*(t+1-a)]+i[4*(t-1+a)]+i[4*(t+1+a)]<=255&&(t=i[4*(t-2*a-2)]+i[4*(t-2*a-1)]+i[4*(t-2*a)]+i[4*(t-2*a+1)]+i[4*(t-2*a+2)]+i[4*(t+2*a-2)]+i[4*(t+2*a-1)]+i[4*(t+2*a)]+i[4*(t+2*a+1)]+i[4*(t+2*a+2)]+i[4*(t-a-2)]+i[4*(t-2)]+i[4*(t+a-2)]+i[4*(t-a+2)]+i[4*(t+2)]+i[4*(t+a+2)],o.push(0===t?[r,e,!0]:[r,e,!1]))}for(let f=0;f<o.length;f++)if(!(o[f][0]<this.wilson.canvasWidth/20||o[f][1]<this.wilson.canvasHeight/20||o[f][0]>19*this.wilson.canvasWidth/20||o[f][1]>19*this.wilson.canvasHeight/20)){let t=-1,r=e;o[f][2]||(r=e/20);for(let s=0;s<o.length;s++)if(s!==f){var n=Math.sqrt((o[f][0]-o[s][0])*(o[f][0]-o[s][0])+(o[f][1]-o[s][1])*(o[f][1]-o[s][1]));if(n<r&&2<=n){var u,h,l=(o[s][0]-o[f][0])/n*1.414214,c=(o[s][1]-o[f][1])/n*1.414214,l=Math.sign(l)*Math.floor(Math.abs(l)),c=Math.sign(c)*Math.floor(Math.abs(c));let e=0;0==l?(u=a*(o[f][0]+l)+(o[f][1]+c),e+=i[4*u],u=a*(o[f][0]+l+1)+(o[f][1]+c),e+=i[4*u],u=a*(o[f][0]+l-1)+(o[f][1]+c),e+=i[4*u]):0==c?(u=a*(o[f][0]+l)+(o[f][1]+c),e+=i[4*u],u=a*(o[f][0]+l)+(o[f][1]+c+1),e+=i[4*u],u=a*(o[f][0]+l)+(o[f][1]+c-1),e+=i[4*u]):(h=a*(o[f][0]+l)+(o[f][1]+c),e+=i[4*h],h=a*o[f][0]+(o[f][1]+c),e+=i[4*h],h=a*(o[f][0]+l)+o[f][1],e+=i[4*h]),0===e&&(t=s,r=n)}}if(-1!==t)for(let e=1;e<2*r;e++){var v=e/(2*r),v=a*Math.round((1-v)*o[f][0]+v*o[t][0])+Math.round((1-v)*o[f][1]+v*o[t][1]);i[4*v]=0,i[4*v+1]=255,i[4*v+2]=0}}this.wilson.useShader("shader2"),this.wilson.setTexture({id:"0",data:i}),this.wilson.drawFrame()}changeResolution(resolution){this.resolution=resolution,this.wilson.resizeCanvas({width:this.resolution}),this.wilson.setUniforms({step:this.wilson.worldWidth/this.resolution},"shader"),this.wilson.setUniforms({textureStep:1/this.resolution},"shader2"),this.wilson.createFramebufferTexturePair({id:"0",textureType:"unsignedByte"}),this.wilson.useFramebuffer(null),this.needNewFrame=!0}}export{EllipticCurve};