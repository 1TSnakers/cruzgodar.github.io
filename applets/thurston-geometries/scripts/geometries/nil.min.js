import{ThurstonGeometry}from"../class.min.js";import{sliderValues}from"../index.min.js";import{BaseGeometry,getMinGlslString}from"./base.min.js";import{$}from"/scripts/src/main.min.js";class NilGeometry extends BaseGeometry{geodesicGlsl=`vec4 pos = getUpdatedPos(startPos, rayDirectionVec, t);

	if (abs(pos.z) > 0.5002)
	{
		// Binary search our way down until we're back in the fundamental domain.
		// It feels like we should change totalT here to reflect the new value, but that seems
		// to badly affect fog calculations.
		float oldT = t - lastTIncrease;

		// The factor by which we multiply lastTIncrease to get the usable increase.
		float currentSearchPosition = 0.5;
		float currentSearchScale = 0.25;

		for (int i = 0; i < 5; i++)
		{
			pos = getUpdatedPos(startPos, rayDirectionVec, oldT + lastTIncrease * currentSearchPosition);

			if (abs(pos.z) > 0.5002)
			{
				currentSearchPosition -= currentSearchScale;
			}

			else 
			{
				currentSearchPosition += currentSearchScale;
			}

			currentSearchScale *= .5;
		}

		t = oldT + lastTIncrease * currentSearchPosition;
		pos = getUpdatedPos(startPos, rayDirectionVec, t);
	}

	globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;normalizeGlsl=`float zFactor = dir.z - (cameraPos.x * dir.y - cameraPos.y * dir.x) / 2.0;

	float magnitude = length(vec3(dir.xy, zFactor));
	
	return dir / magnitude;`;fogGlsl="return mix(color, fogColor, 1.0 - exp(-totalT * 0.2));";functionGlsl=`mat4 getTransformationMatrix(vec4 pos)
	{
		return mat4(
			1.0, 0.0, -pos.y * .5, 0.0,
			0.0, 1.0, pos.x * .5, 0.0,
			0.0, 0.0, 1.0, 0.0,
			pos.x, pos.y, pos.z, 1.0
		);
	}
	
	float chi(float rho, float z, float phi)
	{
		float sineThing = sin(phi * 0.5);

		return -z + phi + rho*rho / (8.0 * sineThing*sineThing) * (phi - sin(phi));
	}

	float chiPrime(float rho, float z, float phi)
	{
		float sineThing = sin(phi * 0.5);

		return 1.0 - rho*rho / (8.0 * sineThing*sineThing) * (cos(phi) + (phi - sin(phi)) / tan(phi / 2.0) - 1.0);
	}
	
	const int newtonIterations = 10;
	
	// Returns the unique zero in (0, 2pi) of chi. z must be positive, so apply the flip transformation before doing this if it's not.
	float chiZero(float rho, float z)
	{
		float phi = 4.0;

		if (rho <= 0.2)
		{
			phi = 6.2;
		}

		else if (rho <= 1.0)
		{
			phi = 6.0;
		}

		else if (rho <= 4.0)
		{
			phi = 5.0;
		}

		for (int iteration = 0; iteration < newtonIterations; iteration++)
		{
			phi -= chi(rho, z, phi) / chiPrime(rho, z, phi);
		}

		return phi;
	}

	// Uses Newton's method and some nasty equations to get the exact distance to the origin.
	// Only recommended when actually close and an underestimate isn't good enough for detail.
	float exactDistanceToOrigin(vec4 pos)
	{
		if (length(pos.xy) < 0.001)
		{
			// The shortest path is just the straight line along the z-axis.
			return abs(pos.z);
		}

		if (abs(pos.z) < 0.001)
		{
			// Here phi = 0, and  we want to avoid sin(x)/x stuff when possible.

			return length(pos.xy);
		}

		// If z is negative, we need to flip the whole z-axis.
		if (pos.z < 0.0)
		{
			pos = vec4(pos.y, pos.x, -pos.z, 1.0);
		}

		float rho = length(pos.xy);

		float phi = chiZero(rho, pos.z);

		float sineThing = 2.0 * sin(phi * 0.5);

		float t = abs(phi * length(vec3(pos.xy, sineThing)) / sineThing);

		return t;
	}

	// Returns an underestimate of the distance to the origin. The paper has variables
	// m and psi that can be varied; I'm just using m = 1 and psi = 1/2.

	const float sqrt2 = 1.414213562;
	const float sqrt3 = 1.732050808;
	const float sqrt6 = 2.449489743;
	const float sqrt12 = 3.464101615;
	const float sqrt48 = 6.928203230;
	const float fourthRoot12 = 1.861209718;

	float approximateDistanceToOrigin(vec4 pos)
	{
		float fInv;
		float z = abs(pos.z);

		if (z < sqrt6)
		{
			fInv = z;
		}

		else if (z < sqrt48)
		{
			fInv = sqrt3 * sqrt(pow(6.0 * z, .666667) - 4.0);
		}

		else
		{
			fInv = fourthRoot12 * sqrt(z);
		}

		return .5 * (length(pos.xy) + fInv);
	}

	vec4 getUpdatedPos(vec4 startPos, vec4 rayDirectionVec, float t)
	{
		mat4 A = getTransformationMatrix(startPos);
	
		float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
		float a = length(rayDirectionVec.xy);
		float c = rayDirectionVec.z;
	
		vec4 pos;
	
		if (abs(c) < .001)
		{
			return A * vec4(
				a * cos(alpha) * t,
				a * sin(alpha) * t,
				0.0,
				1.0
			);
		}
	
		if (c * t < .001)
		{
			return A * vec4(
				2.0 * a / c * sin(c * t / 2.0) * cos(c * t / 2.0 + alpha),
				2.0 * a / c * sin(c * t / 2.0) * sin(c * t / 2.0 + alpha),
				c * t + a*a * (c*t*t*t / 12.0 - c*c*c*t*t*t*t*t / 240.0 + c*c*c*c*c*t*t*t*t*t*t*t / 10080.0),
				1.0
			);
		}
		
		return A * vec4(
			2.0 * a / c * sin(c * t / 2.0) * cos(c * t / 2.0 + alpha),
			2.0 * a / c * sin(c * t / 2.0) * sin(c * t / 2.0 + alpha),
			c * t + a*a / (2.0 * c*c) * (c * t - sin(c * t)),
			1.0
		);
	}

	vec4 getUpdatedDirectionVec(vec4 startPos, vec4 rayDirectionVec, float t)
	{
		mat4 A = getTransformationMatrix(startPos);
	
		float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
		float a = length(rayDirectionVec.xy);
		float c = rayDirectionVec.z;
	
		vec4 pos;
	
		// All the following formulas get differentiated dt.
		if (abs(c) < 0.001)
		{
			return A * vec4(
				a * cos(alpha),
				a * sin(alpha),
				0.0,
				0.0
			);
		}
	
		if (c * t < .001)
		{
			return A * vec4(
				a * cos(alpha + c * t),
				a * sin(alpha + c * t),
				c + a*a * (c*t*t / 4.0 - c*c*c*t*t*t*t / 48.0 + c*c*c*c*c*t*t*t*t*t*t / 1440.0),
				0.0
			);
		}
		
		return A * vec4(
			a * cos(alpha + c * t),
			a * sin(alpha + c * t),
			c - a*a / (2.0 * c) * (cos(c * t) - 1.0),
			0.0
		);
	}

	const mat4 teleportMatX1 = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.5, 0.0,
		0.0, 0.0, 1.0, 0.0,
		1.0, 0.0, 0.0, 1.0
	);

	const mat4 teleportMatX2 = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, -0.5, 0.0,
		0.0, 0.0, 1.0, 0.0,
		-1.0, 0.0, 0.0, 1.0
	);

	const mat4 teleportMatY1 = mat4(
		1.0, 0.0, -0.5, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 1.0, 0.0, 1.0
	);
	
	const mat4 teleportMatY2 = mat4(
		1.0, 0.0, 0.5, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, -1.0, 0.0, 1.0
	);
	
	const mat4 teleportMatZ1 = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 1.0, 1.0
	);
	
	const mat4 teleportMatZ2 = mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, -1.0, 1.0
	);

	vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
	{
		vec3 color = vec3(0.0, 0.0, 0.0);

		if (pos.x < -0.5)
		{
			mat4 A = getTransformationMatrix(pos);

			pos = teleportMatX1 * pos;

			// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
			// position, not the current one, so we need to calculate that current
			// position to teleport the vector correctly. The correct tangent vector
			// is just the derivative of the geodesic at the current value of t.

			// Also important! In Nil, the direction vec is from the origin, so we
			// then need to translate the teleported vector back to the origin.

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatX1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(1.0, 0.0, 0.0);
		}

		else if (pos.x > 0.5)
		{
			mat4 A = getTransformationMatrix(pos);
			pos = teleportMatX2 * pos;

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatX2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(-1.0, 0.0, 0.0);
		}

		if (pos.y < -0.5)
		{
			mat4 A = getTransformationMatrix(pos);
			pos = teleportMatY1 * pos;

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatY1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(0.0, 1.0, 0.0);
		}

		else if (pos.y > 0.5)
		{
			mat4 A = getTransformationMatrix(pos);
			pos = teleportMatY2 * pos;

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatY2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(0.0, -1.0, 0.0);
		}

		if (pos.z < -0.5)
		{
			mat4 A = getTransformationMatrix(pos);
			pos = teleportMatZ1 * pos;

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatZ1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(0.0, 0.0, 1.0);
		}

		else if (pos.z > 0.5)
		{
			mat4 A = getTransformationMatrix(pos);
			pos = teleportMatZ2 * pos;

			rayDirectionVec = getTransformationMatrix(-pos) * teleportMatZ2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

			startPos = pos;
			
			totalT += t;
			t = 0.0;

			color += vec3(0.0, 0.0, -1.0);
		}

		return color;
	}
	`;finalTeleportationGlsl=`if (pos.x > 0.499 && rayDirectionVec.x < -0.05)
	{
		pos.x = -pos.x;
	}

	else if (pos.x < -0.499 && rayDirectionVec.x > 0.05)
	{
		pos.x = -pos.x;
	}

	if (pos.y > 0.499 && rayDirectionVec.y < -0.05)
	{
		pos.y = -pos.y;
	}

	else if (pos.y < -0.499 && rayDirectionVec.y > 0.05)
	{
		pos.y = -pos.y;
	}
	`;maxMarches="250";ambientOcclusionDenominator="300.0";normalize(vec){var t=vec[2]-(this.cameraPos[0]*vec[1]-this.cameraPos[1]*vec[0])/2,t=Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+t*t);return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}followGeodesic(pos,dir,t){var e=[[1,0,0,pos[0]],[0,1,0,pos[1]],[-pos[1]/2,pos[0]/2,1,pos[2]],[0,0,0,1]],o=Math.atan2(dir[1],dir[0]),a=Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]),s=dir[2];return ThurstonGeometry.mat4TimesVector(e,Math.abs(s)<.01?[a*Math.cos(o)*t,a*Math.sin(o)*t,0,1]:[2*a/s*Math.sin(s*t/2)*Math.cos(s*t/2+o),2*a/s*Math.sin(s*t/2)*Math.sin(s*t/2+o),s*t+a*a/(2*s*s)*(s*t-Math.sin(s*t)),1])}getNormalVec(){return[0,0,0,1]}correctVectors(){}baseColorIncreases=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(){var t=[[[1,0,0,1],[0,1,0,0],[0,.5,1,0],[0,0,0,1]],[[1,0,0,-1],[0,1,0,0],[0,-.5,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,1],[-.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,-1],[.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,-1],[0,0,0,1]]];for(let e=0;e<3;e++)this.cameraPos[e]<-.5?(this.cameraPos=ThurstonGeometry.mat4TimesVector(t[2*e],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*e][0],this.baseColor[1]+=this.baseColorIncreases[2*e][1],this.baseColor[2]+=this.baseColorIncreases[2*e][2]):.5<this.cameraPos[e]&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(t[2*e+1],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*e+1][0],this.baseColor[1]+=this.baseColorIncreases[2*e+1][1],this.baseColor[2]+=this.baseColorIncreases[2*e+1][2])}}class NilRooms extends NilGeometry{static distances=`
		// A sphere at the origin (honestly, why would you want it to be anywhere else?)
		float radius = wallThickness;
		float distance1 = approximateDistanceToOrigin(pos);

		if (distance1 > radius + 1.0)
		{
			distance1 -= radius;
		}

		else
		{
			distance1 = exactDistanceToOrigin(pos) - radius;
		}

		distance1 = -distance1;

		
		// The distance to the x and y teleportation planes is the distance between the projections
		// to E^2. Unfortunately for our performance, the tolerances really do need to be this tight
		// to avoid artifacts.
		float distance2 = abs(pos.x - 0.5002);
		float distance3 = abs(pos.x + 0.5002);

		float distance4 = abs(pos.y - 0.5002);
		float distance5 = abs(pos.y + 0.5002);
	`;distanceEstimatorGlsl=`
		${NilRooms.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.35 + .65 * (.5 * (sin((.0125 * pos.x + baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
			.35 + .65 * (.5 * (sin((.0125 * pos.y + baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
			.35 + .65 * (.5 * (sin((.0125 * pos.z + baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(3.0, 2.0, 0.5, 1.0) - pos);
		float dotProduct3 = .5 * dot(surfaceNormal, lightDirection3);

		float lightIntensity = 1.2 * lightBrightness * max(max(abs(dotProduct1), abs(dotProduct2)), abs(dotProduct3));
	`;getMovingSpeed(){return console.log(this.cameraPos),1}cameraPos=[0,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["wallThickness","baseColor"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.wallThickness,.703-sliderValues.wallThickness/10),gl.uniform3fv(uniformList.baseColor,this.baseColor)}uiElementsUsed="#wall-thickness-slider";initUI(){var t=$("#wall-thickness-slider"),e=$("#wall-thickness-slider-value");t.min=-.72,t.max=.78,t.value=.78,e.textContent=.78,sliderValues.wallThickness=.78}}class NilSpheres extends NilGeometry{static distances=`
		float radius = .25;
		float distance1 = approximateDistanceToOrigin(pos);

		if (distance1 > radius + 1.0)
		{
			distance1 -= radius;
		}

		else
		{
			distance1 = exactDistanceToOrigin(pos) - radius;
		}

		
		// The distance to the x and y teleportation planes is the distance between the projections
		// to E^2. Unfortunately for our performance, the tolerances really do need to be this tight
		// to avoid artifacts.
		float distance2 = abs(pos.x - 0.515);
		float distance3 = abs(pos.x + 0.515);

		float distance4 = abs(pos.y - 0.515);
		float distance5 = abs(pos.y + 0.515);
	`;distanceEstimatorGlsl=`
		${NilSpheres.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.25 + .75 * (.5 * (sin(floor(baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.4 * lightBrightness * max(abs(dotProduct1), abs(dotProduct2));
	`;ambientOcclusionDenominator="250.0";getMovingSpeed(){return 1}cameraPos=[.163559,-.438969,.124604,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[.0748089,.997196,0,0];forwardVec=[.997199,-.074809,0,0];baseColor=[-2,0,-2];uniformGlsl=`
		uniform vec3 baseColor;
	`;uniformNames=["baseColor"];updateUniforms(gl,uniformList){gl.uniform3fv(uniformList.baseColor,this.baseColor)}}export{NilRooms,NilSpheres};