import{ThurstonGeometry}from"../class.min.js";import{BaseGeometry,getMatrixGlsl,getMinGlslString}from"./base.min.js";import{$}from"/scripts/src/main.min.js";const teleportationMatrices=[[[1,0,0,1],[0,1,0,0],[0,.5,1,0],[0,0,0,1]],[[1,0,0,-1],[0,1,0,0],[0,-.5,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,1],[-.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,-1],[.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,-1],[0,0,0,1]]];class NilGeometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = getUpdatedPos(startPos, rayDirectionVec, t);

		if (abs(pos.z) > 0.5002)
		{
			// Binary search our way down until we're back in the fundamental domain.
			// It feels like we should change totalT here to reflect the new value, but that seems
			// to badly affect fog calculations.
			float oldT = t - lastTIncrease;

			// The factor by which we multiply lastTIncrease to get the usable increase.
			float currentSearchPosition = 0.5;
			float currentSearchScale = 0.25;

			for (int i = 0; i < 5; i++)
			{
				pos = getUpdatedPos(startPos, rayDirectionVec, oldT + lastTIncrease * currentSearchPosition);

				if (abs(pos.z) > 0.5002)
				{
					currentSearchPosition -= currentSearchScale;
				}

				else 
				{
					currentSearchPosition += currentSearchScale;
				}

				currentSearchScale *= .5;
			}

			t = oldT + lastTIncrease * currentSearchPosition;
			pos = getUpdatedPos(startPos, rayDirectionVec, t);
		}

		globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * 0.2));
	`;functionGlsl=`
		mat4 getTransformationMatrix(vec4 pos)
		{
			return mat4(
				1.0, 0.0, -pos.y * .5, 0.0,
				0.0, 1.0, pos.x * .5, 0.0,
				0.0, 0.0, 1.0, 0.0,
				pos.x, pos.y, pos.z, 1.0
			);
		}
		
		float chi(float rho, float z, float phi)
		{
			float sineThing = sin(phi * 0.5);

			return -z + phi + rho*rho / (8.0 * sineThing*sineThing) * (phi - sin(phi));
		}

		float chiPrime(float rho, float z, float phi)
		{
			float sineThing = sin(phi * 0.5);

			return 1.0 - rho*rho / (8.0 * sineThing*sineThing) * (cos(phi) + (phi - sin(phi)) / tan(phi / 2.0) - 1.0);
		}
		
		const int newtonIterations = 10;
		
		// Returns the unique zero in (0, 2pi) of chi. z must be positive, so apply the flip transformation before doing this if it's not.
		float chiZero(float rho, float z)
		{
			float phi = 4.0;

			if (rho <= 0.2)
			{
				phi = 6.2;
			}

			else if (rho <= 1.0)
			{
				phi = 6.0;
			}

			else if (rho <= 4.0)
			{
				phi = 5.0;
			}

			for (int iteration = 0; iteration < newtonIterations; iteration++)
			{
				phi -= chi(rho, z, phi) / chiPrime(rho, z, phi);
			}

			return phi;
		}

		// Uses Newton's method and some nasty equations to get the exact distance to the origin.
		// Only recommended when actually close and an underestimate isn't good enough for detail.
		float exactDistanceToOrigin(vec4 pos)
		{
			float rho = length(pos.xy);

			if (rho < 0.001)
			{
				// The shortest path is just the straight line along the z-axis.
				return abs(pos.z);
			}

			if (abs(pos.z) < 0.001)
			{
				// Here phi = 0, and  we want to avoid sin(x)/x stuff when possible.

				return rho;
			}

			// If z is negative, we need to flip the whole z-axis.
			if (pos.z < 0.0)
			{
				pos = vec4(pos.y, pos.x, -pos.z, 1.0);
			}

			float phi = chiZero(rho, pos.z);

			float sineThing = 2.0 * sin(phi * 0.5);

			float t = abs(phi * length(vec3(pos.xy, sineThing)) / sineThing);

			return t;
		}

		// Returns an underestimate of the distance to the origin. The paper has variables
		// m and psi that can be varied; I'm just using m = 1 and psi = 1/2.

		const float sqrt2 = ${Math.sqrt(2)};
		const float sqrt3 = ${Math.sqrt(3)};
		const float sqrt6 = ${Math.sqrt(6)};
		const float sqrt12 = ${Math.sqrt(12)};
		const float sqrt48 = ${Math.sqrt(48)};
		const float fourthRoot12 = ${Math.sqrt(Math.sqrt(12))};

		float approximateDistanceToOrigin(vec4 pos)
		{
			float fInv;
			float z = abs(pos.z);

			if (z < sqrt6)
			{
				fInv = z;
			}

			else if (z < sqrt48)
			{
				fInv = sqrt3 * sqrt(pow(6.0 * z, .666667) - 4.0);
			}

			else
			{
				fInv = fourthRoot12 * sqrt(z);
			}

			return .5 * (length(pos.xy) + fInv);
		}

		float metricToOrigin(vec4 pos)
		{
			return length(vec3(pos.xyz));
		}

		vec4 getUpdatedPos(vec4 startPos, vec4 rayDirectionVec, float t)
		{
			mat4 A = getTransformationMatrix(startPos);
		
			float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
			float a = length(rayDirectionVec.xy);
			float c = rayDirectionVec.z;
		
			if (abs(c) < .0002)
			{
				return A * vec4(
					a * cos(alpha) * t,
					a * sin(alpha) * t,
					0.0,
					1.0
				);
			}
		
			if (c * t < .001)
			{
				return A * vec4(
					2.0 * a / c * sin(c * t / 2.0) * cos(c * t / 2.0 + alpha),
					2.0 * a / c * sin(c * t / 2.0) * sin(c * t / 2.0 + alpha),
					c * t + a*a * (c*t*t*t / 12.0 - c*c*c*t*t*t*t*t / 240.0 + c*c*c*c*c*t*t*t*t*t*t*t / 10080.0),
					1.0
				);
			}
			
			return A * vec4(
				2.0 * a / c * sin(c * t / 2.0) * cos(c * t / 2.0 + alpha),
				2.0 * a / c * sin(c * t / 2.0) * sin(c * t / 2.0 + alpha),
				c * t + a*a / (2.0 * c*c) * (c * t - sin(c * t)),
				1.0
			);
		}

		vec4 getUpdatedDirectionVec(vec4 startPos, vec4 rayDirectionVec, float t)
		{
			mat4 A = getTransformationMatrix(startPos);
		
			float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
			float a = length(rayDirectionVec.xy);
			float c = rayDirectionVec.z;
		
			vec4 pos;
		
			// All the following formulas get differentiated dt.
			if (abs(c) < 0.001)
			{
				return A * vec4(
					a * cos(alpha),
					a * sin(alpha),
					0.0,
					0.0
				);
			}
		
			if (c * t < .001)
			{
				return A * vec4(
					a * cos(alpha + c * t),
					a * sin(alpha + c * t),
					c + a*a * (c*t*t / 4.0 - c*c*c*t*t*t*t / 48.0 + c*c*c*c*c*t*t*t*t*t*t / 1440.0),
					0.0
				);
			}
			
			return A * vec4(
				a * cos(alpha + c * t),
				a * sin(alpha + c * t),
				c - a*a / (2.0 * c) * (cos(c * t) - 1.0),
				0.0
			);
		}

		const mat4 teleportMatX1 = ${getMatrixGlsl(teleportationMatrices[0])};
		const mat4 teleportMatX2 = ${getMatrixGlsl(teleportationMatrices[1])};
		const mat4 teleportMatY1 = ${getMatrixGlsl(teleportationMatrices[2])};
		const mat4 teleportMatY2 = ${getMatrixGlsl(teleportationMatrices[3])};
		const mat4 teleportMatZ1 = ${getMatrixGlsl(teleportationMatrices[4])};
		const mat4 teleportMatZ2 = ${getMatrixGlsl(teleportationMatrices[5])};

		vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			vec3 color = vec3(0.0, 0.0, 0.0);

			if (pos.x < -0.5)
			{
				pos = teleportMatX1 * pos;

				// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
				// position, not the current one, so we need to calculate that current
				// position to teleport the vector correctly. The correct tangent vector
				// is just the derivative of the geodesic at the current value of t.

				// Also important! In Nil, the direction vec is from the origin, so we
				// then need to translate the teleported vector back to the origin.

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatX1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(1.0, 0.0, 0.0);
			}

			else if (pos.x > 0.5)
			{
				pos = teleportMatX2 * pos;

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatX2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(-1.0, 0.0, 0.0);
			}

			if (pos.y < -0.5)
			{
				pos = teleportMatY1 * pos;

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatY1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(0.0, 1.0, 0.0);
			}

			else if (pos.y > 0.5)
			{
				pos = teleportMatY2 * pos;

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatY2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(0.0, -1.0, 0.0);
			}

			if (pos.z < -0.5)
			{
				pos = teleportMatZ1 * pos;

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatZ1 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(0.0, 0.0, 1.0);
			}

			else if (pos.z > 0.5)
			{
				pos = teleportMatZ2 * pos;

				rayDirectionVec = getTransformationMatrix(-pos) * teleportMatZ2 * getUpdatedDirectionVec(startPos, rayDirectionVec, t);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				color += vec3(0.0, 0.0, -1.0);
			}

			return color;
		}
	`;finalTeleportationGlsl=`
		if (pos.x > 0.499 && rayDirectionVec.x < -0.05)
		{
			pos.x = -pos.x;
		}

		else if (pos.x < -0.499 && rayDirectionVec.x > 0.05)
		{
			pos.x = -pos.x;
		}

		if (pos.y > 0.499 && rayDirectionVec.y < -0.05)
		{
			pos.y = -pos.y;
		}

		else if (pos.y < -0.499 && rayDirectionVec.y > 0.05)
		{
			pos.y = -pos.y;
		}
	`;maxMarches="250";maxT="30.0";ambientOcclusionDenominator="300.0";normalize(vec){var t=vec[2]-(this.cameraPos[0]*vec[1]-this.cameraPos[1]*vec[0])/2,t=Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+t*t);return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}followGeodesic(pos,dir,t){var e=[[1,0,0,pos[0]],[0,1,0,pos[1]],[-pos[1]/2,pos[0]/2,1,pos[2]],[0,0,0,1]],o=Math.atan2(dir[1],dir[0]),a=Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]),s=dir[2];return ThurstonGeometry.mat4TimesVector(e,Math.abs(s)<.01?[a*Math.cos(o)*t,a*Math.sin(o)*t,0,1]:[2*a/s*Math.sin(s*t/2)*Math.cos(s*t/2+o),2*a/s*Math.sin(s*t/2)*Math.sin(s*t/2+o),s*t+a*a/(2*s*s)*(s*t-Math.sin(s*t)),1])}getNormalVec(){return[0,0,0,1]}correctVectors(){}baseColorIncreases=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(){for(let t=0;t<3;t++)this.cameraPos[t]<-.5?(this.cameraPos=ThurstonGeometry.mat4TimesVector(teleportationMatrices[2*t],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*t][0],this.baseColor[1]+=this.baseColorIncreases[2*t][1],this.baseColor[2]+=this.baseColorIncreases[2*t][2]):.5<this.cameraPos[t]&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(teleportationMatrices[2*t+1],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*t+1][0],this.baseColor[1]+=this.baseColorIncreases[2*t+1][1],this.baseColor[2]+=this.baseColorIncreases[2*t+1][2])}}class NilRooms extends NilGeometry{static distances=`
		// A sphere at the origin (honestly, why would you want it to be anywhere else?)
		float distance1 = wallThickness - metricToOrigin(pos);

		// The distance to the x and y teleportation planes is the distance between the projections
		// to E^2. Unfortunately for our performance, the tolerances really do need to be this tight
		// to avoid artifacts.
		float distance2 = abs(pos.x - 0.5002);
		float distance3 = abs(pos.x + 0.5002);

		float distance4 = abs(pos.y - 0.5002);
		float distance5 = abs(pos.y + 0.5002);

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${NilRooms.distances}

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.3 + .7 * (.5 * (sin((.01 * (pos.x + pos.z) + baseColor.x + baseColor.z + globalColor.x + globalColor.z) * 40.0) + 1.0)),
			.3 + .7 * (.5 * (sin((.01 * (pos.y + pos.z) + baseColor.y + baseColor.z + globalColor.y + globalColor.z) * 57.0) + 1.0)),
			.3 + .7 * (.5 * (sin((.01 * (pos.x + pos.y) + baseColor.x + baseColor.y + globalColor.x + globalColor.y) * 89.0) + 1.0))
		);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(1.5, 1.5, 1.5, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.25 + .75 * dotProduct1 * dotProduct1) * 1.15;
	`;cameraPos=[0,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["wallThickness","baseColor"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.wallThickness,.703-this.sliderValues.wallThickness/10),gl.uniform3fv(uniformList.baseColor,this.baseColor)}uiElementsUsed="#wall-thickness-slider";initUI(){var t=$("#wall-thickness-slider"),e=$("#wall-thickness-slider-value");t.min=-.72,t.max=.78,t.value=.78,e.textContent=.78,this.sliderValues.wallThickness=.78}}class NilSpheres extends NilGeometry{static distances=`
		float distance1 = metricToOrigin(pos) - .2;

		float distance2 = abs(pos.x - 0.515);
		float distance3 = abs(pos.x + 0.515);

		float distance4 = abs(pos.y - 0.515);
		float distance5 = abs(pos.y + 0.515);

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${NilSpheres.distances}

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.25 + .75 * (.5 * (sin(floor(baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(1.5, 1.5, 1.5, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.2 + .8 * max(dotProduct1, -.75 * dotProduct1)) * 1.15;
	`;ambientOcclusionDenominator="250.0";cameraPos=[.163559,-.438969,.124604,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[.0748089,.997196,0,0];forwardVec=[.997199,-.074809,0,0];baseColor=[-2,0,-2];uiElementsUsed="#disable-teleportation-checkbox";uniformGlsl=`
		uniform vec3 baseColor;
	`;uniformNames=["baseColor"];updateUniforms(gl,uniformList){gl.uniform3fv(uniformList.baseColor,this.baseColor)}}export{NilRooms,NilSpheres};