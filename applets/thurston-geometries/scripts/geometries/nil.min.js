import{ThurstonGeometry}from"../class.min.js";import{sliderValues}from"../index.min.js";import{BaseGeometry}from"./base.min.js";import{$}from"/scripts/src/main.min.js";const baseColorIncreases=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],baseColor=[0,0,0];class NilGeometry extends BaseGeometry{geodesicGlsl=`mat4 A = mat4(
		1.0, 0.0, -startPos.y * .5, 0.0,
		0.0, 1.0, startPos.x * .5, 0.0,
		0.0, 0.0, 1.0, 0.0,
		startPos.x, startPos.y, startPos.z, 1.0
	);

	vec4 v = mat4(
		1.0, 0.0, startPos.y * .5, 0.0,
		0.0, 1.0, -startPos.x * .5, 0.0,
		0.0, 0.0, 1.0, 0.0,
		-startPos.x, -startPos.y, -startPos.z, 1.0
	) * rayDirectionVec;

	float alpha = atan(v.y, v.x);
	float a = length(v.xy);
	float c = v.z;

	vec4 pos;

	if (abs(c) < 0.00001)
	{
		pos = A * vec4(
			a * cos(alpha) * t,
			a * sin(alpha) * t,
			0.0,
			0.0
		);
	}
	
	pos = A * vec4(
		2.0 * a / c * sin(c * t / 2.0) * cos(c * t / 2.0 + alpha),
		2.0 * a / c * sin(c * t / 2.0) * sin(c * t / 2.0 + alpha),
		c * t + a*a / (2.0 * c*c) * (c * t - sin(c * t)),
		0.0
	);

	// globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;dotProductGlsl="return 0.0;";normalizeGlsl=`float zFactor = dir.z - (cameraPos.x * dir.y - cameraPos.y * dir.x) / 2.0;

	float magnitude = length(vec3(dir.xy, zFactor));
	
	return dir / magnitude;`;fogGlsl="return mix(color, fogColor, 1.0 - exp(0.5 - totalT * 0.075));";normalize(vec){var t=vec[2]-(this.cameraPos[0]*vec[1]-this.cameraPos[1]*vec[0])/2,t=Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+t*t);return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}followGeodesic(pos,dir,t){var s=[[1,0,0,pos[0]],[0,1,0,pos[1]],[-pos[1]/2,pos[0]/2,1,pos[2]],[0,0,0,1]],e=[[1,0,0,-pos[0]],[0,1,0,-pos[1]],[pos[1]/2,-pos[0]/2,1,-pos[2]],[0,0,0,1]],e=ThurstonGeometry.mat4TimesVector(e,dir),o=Math.atan2(e[1],e[0]),a=Math.sqrt(e[0]*e[0]+e[1]*e[1]),e=e[2];return ThurstonGeometry.mat4TimesVector(s,Math.abs(e)<1e-5?[a*Math.cos(o)*t,a*Math.sin(o)*t,0,0]:[2*a/e*Math.sin(e*t/2)*Math.cos(e*t/2+o),2*a/e*Math.sin(e*t/2)*Math.sin(e*t/2+o),e*t+a*a/(2*e*e)*(e*t-Math.sin(e*t)),0])}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],-cameraPos[2],cameraPos[3]])}lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(1.0, 1.0, 1.0, 0.0) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-1.0, -1.0, -1.0, 0.0) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity = lightBrightness * max(
			max(abs(dotProduct1), abs(dotProduct2)),
			max(abs(dotProduct3), abs(dotProduct4))
		);
	`;correctVectors(){var t=this.dotProduct(this.cameraPos,this.upVec),s=this.dotProduct(this.cameraPos,this.rightVec),e=this.dotProduct(this.cameraPos,this.forwardVec);for(let o=0;o<4;o++)this.upVec[o]+=t*this.cameraPos[o],this.rightVec[o]+=s*this.cameraPos[o],this.forwardVec[o]+=e*this.cameraPos[o];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}teleportCamera(rotatedForwardVec,recomputeRotation){var t=Math.cos(sliderValues.gluingAngle),s=Math.sin(sliderValues.gluingAngle),e=[[[1,0,0,1/Math.sqrt(3)],[[2,0,0,Math.sqrt(3)],[0,t,-s,0],[0,s,t,0],[Math.sqrt(3),0,0,2]]],[[-1,0,0,1/Math.sqrt(3)],[[2,0,0,-Math.sqrt(3)],[0,t,s,0],[0,-s,t,0],[-Math.sqrt(3),0,0,2]]],[[0,1,0,1/Math.sqrt(3)],[[t,0,-s,0],[0,2,0,Math.sqrt(3)],[s,0,t,0],[0,Math.sqrt(3),0,2]]],[[0,-1,0,1/Math.sqrt(3)],[[t,0,s,0],[0,2,0,-Math.sqrt(3)],[-s,0,t,0],[0,-Math.sqrt(3),0,2]]],[[0,0,1,1/Math.sqrt(3)],[[t,-s,0,0],[s,t,0,0],[0,0,2,Math.sqrt(3)],[0,0,Math.sqrt(3),2]]],[[0,0,-1,1/Math.sqrt(3)],[[t,s,0,0],[-s,t,0,0],[0,0,2,-Math.sqrt(3)],[0,0,-Math.sqrt(3),2]]]];for(let o=0;o<e.length;o++)ThurstonGeometry.dotProduct(this.cameraPos,e[o][0])<0&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(e[o][1],this.cameraPos),this.forwardVec=ThurstonGeometry.mat4TimesVector(e[o][1],this.forwardVec),this.rightVec=ThurstonGeometry.mat4TimesVector(e[o][1],this.rightVec),this.upVec=ThurstonGeometry.mat4TimesVector(e[o][1],this.upVec),recomputeRotation(ThurstonGeometry.mat4TimesVector(e[o][1],rotatedForwardVec)),baseColor[0]+=baseColorIncreases[o][0],baseColor[1]+=baseColorIncreases[o][1],baseColor[2]+=baseColorIncreases[o][2])}}class NilSpheres extends NilGeometry{static distances=`
		float distance1 = 1.0;
		/*
		// Translate the reflection plane to the x = 0 plane, then get the distance to it.
		// The DE to x = 0 is abs(asinh(pos.x)).
		float distance2 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, 0.0, 0.71939),
				pos
			)
		));
		
		float distance3 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, 0.0, -0.71939),
				pos
			)
		));

		float distance4 = abs(asinh(
			dot(
				vec4(0.0, 1.23188, 0.0, 0.71939),
				pos
			)
		));
		
		float distance5 = abs(asinh(
			dot(
				vec4(0.0, -1.23188, 0.0, 0.71939),
				pos
			)
		));

		float distance6 = abs(asinh(
			dot(
				vec4(0.0, 0.0, 1.23188, 0.71939),
				pos
			)
		));
		
		float distance7 = abs(asinh(
			dot(
				vec4(0.0, 0.0, -1.23188, 0.71939),
				pos
			)
		));
		*/
	`;distanceEstimatorGlsl=`
		${NilSpheres.distances}

		float minDistance = distance1;

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.25 + .75 * (.5 * (sin(floor(baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		);
	`;getMovingSpeed(){return 1.5}cameraPos=[0,0,0,1];normalVec=[0,0,0,-1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float wallThickness;
		uniform float gluingAngle;
		uniform vec3 baseColor;
	`;uniformNames=["wallThickness","gluingAngle","baseColor"];updateUniforms(gl,uniformList){var t=1.5-(sliderValues.wallThickness- -.357)/.5*.5;gl.uniform1f(uniformList.wallThickness,t),gl.uniform1f(uniformList.gluingAngle,sliderValues.gluingAngle),gl.uniform3fv(uniformList.baseColor,baseColor)}uiElementsUsed="#wall-thickness-slider, #gluing-angle-slider";initUI(){var t=$("#wall-thickness-slider"),s=$("#wall-thickness-slider-value"),t=(t.min=-.357,t.max=.143,t.value=.143,s.textContent=.143,sliderValues.wallThickness=.143,$("#gluing-angle-slider")),s=$("#gluing-angle-slider-value");t.min=0,t.max=2*Math.PI,t.value=0,s.textContent=0,sliderValues.gluingAngle=0}}export{NilSpheres};