class BaseGeometry{geodesicGlsl="vec4 pos = startPos + t * rayDirectionVec;";dotProductGlsl="return dot(v, w);";normalizeGlsl="return normalize(dir);";fogGlsl="return mix(color, fogColor, 1.0 - exp(-length(pos - cameraPos) * fogScaling));";updateTGlsl="t += distance * stepFactor;";dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}normalize(vec){var e=Math.sqrt(this.dotProduct(vec,vec));return[vec[0]/e,vec[1]/e,vec[2]/e,vec[3]/e]}followGeodesic(pos,dir,t){var e=[...pos];for(let r=0;r<4;r++)e[r]=e[r]+t*dir[r];return e}teleportCamera(){}getGeodesicDirection(pos1,pos2){var e=[pos2[0]-pos1[0],pos2[1]-pos1[1],pos2[2]-pos1[2],pos2[3]-pos1[3]];return this.normalize(e)}getGeodesicDistance(pos1,pos2){var e=[pos2[0]-pos1[0],pos2[1]-pos1[1],pos2[2]-pos1[2],pos2[3]-pos1[3]];return Math.sqrt(this.dotProduct(e,e))}getNormalVec(){return[0,0,0,1]}getGammaPrime(_pos,dir){return[...dir]}getGammaDoublePrime(){return[0,0,0,0]}getGammaTriplePrime(){return[0,0,0,0]}gammaTriplePrimeIsLinearlyIndependent=!1;correctVectors(){console.log(this.upVec);var e=this.dotProduct(this.normalVec,this.upVec),r=(console.log(this.normalVec),this.dotProduct(this.normalVec,this.rightVec)),t=this.dotProduct(this.normalVec,this.forwardVec);for(let o=0;o<4;o++)this.upVec[o]-=e*this.normalVec[o],this.rightVec[o]-=r*this.normalVec[o],this.forwardVec[o]-=t*this.normalVec[o];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec),console.log(this.upVec)}getMovingSpeed(){return 3}distanceEstimatorGlsl;getColorGlsl;lightGlsl;functionGlsl;raymarchSetupGlsl;cameraPos;normalVec;upVec;rightVec;forwardVec;uniformGlsl;uniformNames;uniformData={};updateUniforms(){}initUI(){}uiElementsUsed=""}function getMinGlslString(varName,numVars,functionName="min"){var e=Math.ceil(Math.log2(numVars));let r=new Array(numVars);for(let o=0;o<numVars;o++)r[o]=""+varName+(o+1);for(let s=0;s<e;s++){var t=new Array(Math.ceil(r.length/2));for(let e=0;e<r.length;e+=2)t[e/2]=`${functionName}(${r[e]}, ${r[e+1]})`;r.length%2==1&&(t[t.length-1]=r[r.length-1]),r=t}return r[0]}function getMaxGlslString(varName,numVars){return getMinGlslString(varName,numVars,"max")}function getColorGlslString(varName,minVarName,colors){let e="";for(let r=0;r<colors.length;r++)e+=`if (${minVarName} == ${varName}${r+1}) { return vec3(${colors[r][0]/255}, ${colors[r][1]/255}, ${colors[r][2]/255}); }
		`;return e}export{BaseGeometry,getMinGlslString,getMaxGlslString,getColorGlslString};