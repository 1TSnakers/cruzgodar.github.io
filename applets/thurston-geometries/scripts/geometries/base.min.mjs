import{ThurstonGeometry}from"../class.min.mjs";class BaseGeometry{geodesicGlsl="vec4 pos = startPos + t * rayDirectionVec;";fogGlsl="return mix(color, fogColor, 1.0 - exp(-length(pos - cameraPos) * fogScaling));";updateTGlsl="t += distance * stepFactor;";dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}updateCameraPos(cameraPos,tangentVec,dt){var e=[...cameraPos];for(let r=0;r<4;r++)e[r]=e[r]+dt*tangentVec[r];return e}getGeodesicDirection(pos1,pos2){var e=new Array(4);for(let t=0;t<4;t++)e[t]=pos2[t]-pos1[t];var r=ThurstonGeometry.magnitude(e);return[ThurstonGeometry.normalize(e),r]}normalizeToMagnitude(vec,targetMag){var e=this.dotProduct(vec,vec);Math.sqrt(targetMag/e);return[vec[0]*e,vec[1]*e,vec[2]*e,vec[3]*e]}getNormalVec(){return[0,0,0,1]}getGammaPrime(_pos,dir){return[...dir]}getGammaDoublePrime(){return[0,0,0,0]}getGammaTriplePrime(){return[0,0,0,0]}gammaTriplePrimeIsLinearlyIndependent=!1;getMovingSpeed(){return 3}distanceEstimatorGlsl;getColorGlsl;lightGlsl;functionGlsl;raymarchSetupGlsl;cameraPos;normalVec;upVec;rightVec;forwardVec}function getMinGlslString(varName,numVars){var e=Math.ceil(Math.log2(numVars));let r=new Array(numVars);for(let a=0;a<numVars;a++)r[a]=""+varName+(a+1);for(let o=0;o<e;o++){var t=new Array(Math.ceil(r.length/2));for(let e=0;e<r.length;e+=2)t[e/2]=`min(${r[e]}, ${r[e+1]})`;r.length%2==1&&(t[t.length-1]=r[r.length-1]),r=t}return r[0]}function getColorGlslString(varName,minVarName,colors){let e="";for(let r=0;r<colors.length;r++)e+=`if (${minVarName} == ${varName}${r+1}) { return vec3(${colors[r][0]/255}, ${colors[r][1]/255}, ${colors[r][2]/255}); }
		`;return e}export{BaseGeometry,getMinGlslString,getColorGlslString};