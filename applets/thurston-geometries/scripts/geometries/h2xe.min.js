import{ThurstonGeometry}from"../class.min.js";import{sliderValues}from"../index.min.js";import{BaseGeometry,getMinGlslString}from"./base.min.js";import{$}from"/scripts/src/main.min.js";class H2xEGeometry extends BaseGeometry{geodesicGlsl=`float h2Mag = sqrt(abs(
		rayDirectionVec.x * rayDirectionVec.x
		+ rayDirectionVec.y * rayDirectionVec.y
		- rayDirectionVec.z * rayDirectionVec.z
	));
	
	vec4 pos = vec4(
		cosh(h2Mag * t) * startPos.xyz + sinh(h2Mag * t) * rayDirectionVec.xyz / h2Mag,
		startPos.w + t * rayDirectionVec.w
	);
	
	globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);`;dotProductGlsl="return v.x * w.x + v.y * w.y - v.z * w.z + v.w * w.w;";normalizeGlsl=`float magnitude = sqrt(abs(geometryDot(dir, dir)));
	
	return dir / magnitude;`;fogGlsl="return mix(color, fogColor, 1.0 - exp(-totalT * 0.4));";functionGlsl=`float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float asinh(float x)
		{
			return log(x + sqrt(x*x + 1.0));
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}

		vec3 teleportPos(inout vec4 pos, inout vec4 startPos, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			vec4 teleportVec1 = vec4(1.0, 0.0, 0.577350269, 0.0);
			mat4 teleportMat1 = mat4(
				2.0, 0.0, 1.73205081, 0.0,
				0.0, 1.0, 0.0, 0.0,
				1.73205081, 0.0, 2.0, 0.0,
				0.0, 0.0, 0.0, 1.0
			);

			vec4 teleportVec2 = vec4(-1.0, 0.0, 0.577350269, 0.0);
			mat4 teleportMat2 = mat4(
				2.0, 0.0, -1.73205081, 0.0,
				0.0, 1.0, 0.0, 0.0,
				-1.73205081, 0.0, 2.0, 0.0,
				0.0, 0.0, 0.0, 1.0
			);

			vec4 teleportVec3 = vec4(0.0, 1.0, 0.577350269, 0.0);
			mat4 teleportMat3 = mat4(
				1.0, 0.0, 0.0, 0.0,
				0.0, 2.0, 1.73205081, 0.0,
				0.0, 1.73205081, 2.0, 0.0,
				0.0, 0.0, 0.0, 1.0
			);

			vec4 teleportVec4 = vec4(0.0, -1.0, 0.577350269, 0.0);
			mat4 teleportMat4 = mat4(
				1.0, 0.0, 0.0, 0.0,
				0.0, 2.0, -1.73205081, 0.0,
				0.0, -1.73205081, 2.0, 0.0,
				0.0, 0.0, 0.0, 1.0
			);



			if (dot(pos, teleportVec1) < 0.0)
			{
				pos = teleportMat1 * pos;

				// !!!IMPORTANT!!! rayDirectionVec is the tangent vector from the *starting*
				// position, not the current one, so we need to calculate that current
				// position to teleport the vector correctly. The correct tangent vector
				// is just the derivative of the geodesic at the current value of t.

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));

				rayDirectionVec = teleportMat1 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 1.0, 0.0);
			}

			if (dot(pos, teleportVec2) < 0.0)
			{
				pos = teleportMat2 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat2 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, -1.0, 0.0);
			}

			if (dot(pos, teleportVec3) < 0.0)
			{
				pos = teleportMat3 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat3 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, 1.0);
			}

			if (dot(pos, teleportVec4) < 0.0)
			{
				pos = teleportMat4 * pos;

				float h2Mag = sqrt(abs(
					rayDirectionVec.x * rayDirectionVec.x
					+ rayDirectionVec.y * rayDirectionVec.y
					- rayDirectionVec.z * rayDirectionVec.z
				));
				
				rayDirectionVec = teleportMat4 * vec4(
					h2Mag * sinh(h2Mag * t) * startPos.xyz + cosh(h2Mag * t) * rayDirectionVec.xyz,
					rayDirectionVec.w
				);

				startPos = pos;
				
				totalT += t;
				t = 0.0;

				return vec3(0.0, 0.0, -1.0);
			}

			return vec3(0.0, 0.0, 0.0);
		}
	`;followGeodesic(pos,dir,t){var e=Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]),e=0===e?[pos[0],pos[1],pos[2],pos[3]+t*dir[3]]:[Math.cosh(e*t)*pos[0]+Math.sinh(e*t)*dir[0]/e,Math.cosh(e*t)*pos[1]+Math.sinh(e*t)*dir[1]/e,Math.cosh(e*t)*pos[2]+Math.sinh(e*t)*dir[2]/e,pos[3]+t*dir[3]],o=Math.sqrt(-e[0]*e[0]-e[1]*e[1]+e[2]*e[2]);return e[0]/=o,e[1]/=o,e[2]/=o,e}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],cameraPos[2],0])}dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]+vec1[3]*vec2[3]}normalize(vec){var t=Math.sqrt(Math.abs(this.dotProduct(vec,vec)));return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}correctVectors(){function t(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]-vec1[2]*vec2[2]}var e=t(this.cameraPos,this.upVec),o=t(this.cameraPos,this.rightVec),r=t(this.cameraPos,this.forwardVec);for(let s=0;s<3;s++)this.upVec[s]+=e*this.cameraPos[s],this.rightVec[s]+=o*this.cameraPos[s],this.forwardVec[s]+=r*this.cameraPos[s];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}baseColorIncreases=[[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(rotatedForwardVec,recomputeRotation){var t=[[[1,0,1/Math.sqrt(3),0],[[2,0,Math.sqrt(3),0],[0,1,0,0],[Math.sqrt(3),0,2,0],[0,0,0,1]]],[[-1,0,1/Math.sqrt(3),0],[[2,0,-Math.sqrt(3),0],[0,1,0,0],[-Math.sqrt(3),0,2,0],[0,0,0,1]]],[[0,1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,Math.sqrt(3),0],[0,Math.sqrt(3),2,0],[0,0,0,1]]],[[0,-1,1/Math.sqrt(3),0],[[1,0,0,0],[0,2,-Math.sqrt(3),0],[0,-Math.sqrt(3),2,0],[0,0,0,1]]]];for(let e=0;e<t.length;e++)ThurstonGeometry.dotProduct(this.cameraPos,t[e][0])<0&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(t[e][1],this.cameraPos),this.forwardVec=ThurstonGeometry.mat4TimesVector(t[e][1],this.forwardVec),this.rightVec=ThurstonGeometry.mat4TimesVector(t[e][1],this.rightVec),this.upVec=ThurstonGeometry.mat4TimesVector(t[e][1],this.upVec),recomputeRotation(ThurstonGeometry.mat4TimesVector(t[e][1],rotatedForwardVec)),this.baseColor[0]+=this.baseColorIncreases[e][0],this.baseColor[1]+=this.baseColorIncreases[e][1],this.baseColor[2]+=this.baseColorIncreases[e][2])}}class H2xERooms extends H2xEGeometry{static distances=`
		float spacing = 1.875;
		float distance1 = wallThickness - length(vec2(acosh(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));

		// Translate the reflection plane to the x = 0 plane, then get the distance to it.
		// The DE to x = 0 is abs(asinh(pos.x)).
		float distance2 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, 0.71939, 0),
				pos
			)
		));
		
		float distance3 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, -0.71939, 0),
				pos
			)
		));

		float distance4 = abs(asinh(
			dot(
				vec4(0.0, 1.23188, 0.71939, 0),
				pos
			)
		));
		
		float distance5 = abs(asinh(
			dot(
				vec4(0.0, -1.23188, 0.71939, 0),
				pos
			)
		));
	`;distanceEstimatorGlsl=`
		${H2xERooms.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		return minDistance;
	`;getColorGlsl=`
		${H2xERooms.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		float wColor = floor((pos.w + 3.0 * spacing / 2.0) / spacing) - spacing / 2.0;

		return vec3(
			.4 + .6 * .5 * (sin((.05 * pos.x + wColor + globalColor.y + baseColor.y + globalColor.z + baseColor.z) * 5.0) + 1.0),
			.4 + .6 * .5 * (sin((.05 * pos.y + wColor + globalColor.y + baseColor.y) * 7.0) + 1.0),
			.4 + .6 * .5 * (sin((.05 * pos.z + wColor + globalColor.z + baseColor.z) * 11.0) + 1.0)
		);
	`;lightGlsl=`
		float spacing = 1.875;
		vec4 moddedPos = vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0);

		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - moddedPos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		vec4 lightDirection2 = normalize(vec4(1.0, -1.0, 0.0, -.5) - moddedPos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		

		float lightIntensity = 1.5 * lightBrightness * max(dotProduct1, dotProduct2);
	`;cameraPos=[0,0,1,0];normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];getMovingSpeed(){return 1.25}uniformGlsl="uniform float wallThickness; uniform vec3 baseColor;";uniformNames=["wallThickness","baseColor"];updateUniforms(gl,uniformList){var t=1.145-sliderValues.wallThickness/10;gl.uniform1f(uniformList.wallThickness,t),gl.uniform3fv(uniformList.baseColor,this.baseColor)}uiElementsUsed="#wall-thickness-slider";initUI(){var t=$("#wall-thickness-slider"),e=$("#wall-thickness-slider-value");t.min=-.55,t.max=1.05,t.value=1.05,e.textContent=1.05,sliderValues.wallThickness=1.05}}class H2xESpheres extends H2xEGeometry{static distances=`
		float spacing = 1.5;
		float distance1 = length(vec2(acosh(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0)) - .5;

		// Translate the reflection plane to the x = 0 plane, then get the distance to it.
		// The DE to x = 0 is abs(asinh(pos.x)).
		float distance2 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, 0.71939, 0),
				pos
			)
		));
		
		float distance3 = abs(asinh(
			dot(
				vec4(1.23188, 0.0, -0.71939, 0),
				pos
			)
		));

		float distance4 = abs(asinh(
			dot(
				vec4(0.0, 1.23188, 0.71939, 0),
				pos
			)
		));
		
		float distance5 = abs(asinh(
			dot(
				vec4(0.0, -1.23188, 0.71939, 0),
				pos
			)
		));
	`;distanceEstimatorGlsl=`
		${H2xESpheres.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		return minDistance;
	`;getColorGlsl=`
		${H2xESpheres.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		float wColor = floor((pos.w + spacing / 2.0) / spacing);

		float colorSum = globalColor.x + baseColor.x + globalColor.y + baseColor.y + globalColor.z + baseColor.z;

		return vec3(
			.1 + .8 * .5 * (sin((wColor + colorSum) * 7.0) + 1.0),
			.1 + .8 * .5 * (sin((wColor + colorSum) * 11.0) + 1.0),
			.1 + .8 * .5 * (sin((wColor + colorSum) * 17.0) + 1.0)
		);
	`;lightGlsl=`
		// Equally weird to the S^2 x E fix, and equally necessary.
		pos.xyz *= 1.001;
		surfaceNormal = getSurfaceNormal(pos);

		float spacing = 1.5;
		vec4 moddedPos = vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0);

		vec4 lightDirection1 = normalize(vec4(-1.0, 1.0, 0.0, .5) - moddedPos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		vec4 lightDirection2 = normalize(vec4(1.0, -1.0, 0.0, -.5) - moddedPos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 2.0 * lightBrightness * max(dotProduct1, dotProduct2);
	`;cameraPos=[0,0,1,.75];normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];getMovingSpeed(){return 1.25}uniformGlsl="uniform vec3 baseColor;";uniformNames=["baseColor"];updateUniforms(gl,uniformList){gl.uniform3fv(uniformList.baseColor,this.baseColor)}}export{H2xERooms,H2xESpheres};