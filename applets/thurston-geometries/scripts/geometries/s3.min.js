import{getColorGlslString,getMaxGlslString,getMinGlslString}from"../../../../scripts/applets/applet.min.js";import{ThurstonGeometry}from"../class.min.js";import{BaseGeometry}from"./base.min.js";class S3Geometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = cos(t) * startPos + sin(t) * rayDirectionVec;
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-acos(dot(pos, cameraPos)) * fogScaling));
	`;maxMarches="100";maxT="6.283";correctPosition(pos){return ThurstonGeometry.normalize(pos)}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],-cameraPos[2],-cameraPos[3]])}}class S3Axes extends S3Geometry{static distances=`
		float distance1 = acos(length(pos.xw)) - .05;
		float distance2 = acos(length(pos.yw)) - .05;
		float distance3 = acos(length(pos.zw)) - .05;

		float minDistance = ${getMinGlslString("distance",3)};
	`;distanceEstimatorGlsl=`
		${S3Axes.distances}

		return minDistance;
	`;getColorGlsl=`
		${S3Axes.distances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(20.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(20.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(20.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(20.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(20.0 * pos.z) + 1.0)),
			.5 + .25 * (.5 * (cos(20.0 * pos.z) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(.5, .5, .5, .5) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-.5, -.5, -.5, -.5) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.5 * min(abs(dotProduct1), abs(dotProduct2));
	`;cameraPos=[.6247,.6247,.4683,-.0157];normalVec=[-.6247,-.6247,-.4683,.0157];upVec=[-.3268,-.3268,.8657,-.1925];rightVec=[.7071,-.7071,0,0];forwardVec=[-.0542,-.0542,.1773,.9812]}class S3Rooms extends S3Geometry{static distances=`
		float minRoomDistance = 1000000.0;
		float minSphereDistance = 1000000.0;

		float acosX = acos(pos.x);
		float acosNegX = pi - acosX;
		float acosY = acos(pos.y);
		float acosNegY = pi - acosY;
		float acosZ = acos(pos.z);
		float acosNegZ = pi - acosZ;
		float acosW = acos(pos.w);
		float acosNegW = pi - acosW;

		float roomDistance1 = maxT * 2.0;
		float roomDistance2 = maxT * 2.0;
		float roomDistance3 = maxT * 2.0;
		float roomDistance4 = maxT * 2.0;
		float roomDistance5 = maxT * 2.0;
		float roomDistance6 = maxT * 2.0;
		float roomDistance7 = maxT * 2.0;
		float roomDistance8 = maxT * 2.0;

		if (sceneTransition < 1.0)
		{
			float scale = exp(max(sceneTransition - 0.8, 0.0) * 5.0);

			float effectiveWallThickness = wallThickness + sceneTransition * .125 / .75;
			roomDistance1 = effectiveWallThickness - acosX;
			roomDistance2 = effectiveWallThickness - acosNegX;
			roomDistance3 = effectiveWallThickness - acosY;
			roomDistance4 = effectiveWallThickness - acosNegY;
			roomDistance5 = effectiveWallThickness - acosZ;
			roomDistance6 = effectiveWallThickness - acosNegZ;
			roomDistance7 = effectiveWallThickness - acosW;
			roomDistance8 = effectiveWallThickness - acosNegW;

			minRoomDistance = ${getMaxGlslString("roomDistance",8)} * scale;
		}

		float sphereDistance1 = maxT * 2.0;
		float sphereDistance2 = maxT * 2.0;
		float sphereDistance3 = maxT * 2.0;
		float sphereDistance4 = maxT * 2.0;
		float sphereDistance5 = maxT * 2.0;
		float sphereDistance6 = maxT * 2.0;
		float sphereDistance7 = maxT * 2.0;

		if (sceneTransition > 0.0)
		{
			float scale = exp(max(0.2 - sceneTransition, 0.0) * 5.0);

			float effectiveRadius = .3 - .3 / .75 * (1.0 - sceneTransition);
			sphereDistance1 = acosX - effectiveRadius;
			sphereDistance2 = acosNegX - effectiveRadius;
			sphereDistance3 = acosY - effectiveRadius;
			sphereDistance4 = acosNegY - effectiveRadius;
			sphereDistance5 = acosZ - effectiveRadius;
			sphereDistance6 = acosNegZ - effectiveRadius;
			sphereDistance7 = acosW - effectiveRadius;

			minSphereDistance = ${getMinGlslString("sphereDistance",7)} * scale;
		}
		
		float minDistance = min(minRoomDistance, minSphereDistance);
	`;distanceEstimatorGlsl=`
		${S3Rooms.distances}

		return minDistance;
	`;getColorGlsl=`
		${S3Rooms.distances}

		float variation = .075;

		if (minDistance == roomDistance1)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.y) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance2)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.y) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance3)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance4)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance5)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance6)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance7)
		{
			return vec3(
				.5 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == roomDistance8)
		{
			return vec3(
				.65 + .35 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.65 + .35 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.65 + .35 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == sphereDistance1)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.y) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance2)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.y) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance3)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance4)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance5)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		if (minDistance == sphereDistance6)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.w) * 29.0) + 1.0))
			) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
		}

		return vec3(
			.5 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
			.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
			.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
		) * getBanding(pos.x + pos.y + pos.z + pos.w, 7.854);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, -1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity1 = 4.0 * max(dotProduct1, dotProduct2);



		vec4 lightDirection3 = normalize(vec4(.5, .5, .5, .5) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-.5, -.5, -.5, -.5) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity2 = 1.75 * min(abs(dotProduct3), abs(dotProduct4));



		float lightIntensity = mix(lightIntensity1, lightIntensity2, sceneTransition);
	`;cameraPos=[0,-.20927,0,-.97785];normalVec=[-0,.20934,-0,.97784];upVec=[0,0,1,0];rightVec=[1,0,0,0];forwardVec=[0,-.97784,0,.20934];uniformGlsl=`
		uniform float sceneTransition;
		uniform float wallThickness;
	`;uniformNames=["sceneTransition","wallThickness"];updateUniforms(gl,uniformList){var i=.97-(this.sliderValues.wallThickness- -.15)/.5*(.97-.92);gl.uniform1f(uniformList.sceneTransition,this.sliderValues.sceneTransition),gl.uniform1f(uniformList.wallThickness,i)}uiElementsUsed="#wall-thickness-slider, #switch-scene-button";wallThicknessData=[.35,-.15,.35];getNearestCenter(){var i=[[1,0,0,0],[-1,0,0,0],[0,1,0,0],[0,-1,0,0],[0,0,1,0],[0,0,-1,0],[0,0,0,1],[0,0,0,-1]];let t=Math.PI,s=0;for(let e=0;e<i.length;e++){var o=Math.acos(ThurstonGeometry.dotProduct(i[e],this.cameraPos));o<t&&(t=o,s=e)}return i[s]}getNearestCorner(){var i=[[.5,.5,.5,.5],[.5,.5,.5,-.5],[.5,.5,-.5,.5],[.5,.5,-.5,-.5],[.5,-.5,.5,.5],[.5,-.5,.5,-.5],[.5,-.5,-.5,.5],[.5,-.5,-.5,-.5],[-.5,.5,.5,.5],[-.5,.5,.5,-.5],[-.5,.5,-.5,.5],[-.5,.5,-.5,-.5],[-.5,-.5,.5,.5],[-.5,-.5,.5,-.5],[-.5,-.5,-.5,.5],[-.5,-.5,-.5,-.5]];let t=Math.PI,s=0;for(let e=0;e<i.length;e++){var o=Math.acos(ThurstonGeometry.dotProduct(i[e],this.cameraPos));o<t&&(t=o,s=e)}return i[s]}}function hsvToRgb(h,s,v){function i(n){var i=(n+6*h)%6;return v-v*s*Math.max(0,Math.min(i,Math.min(4-i,1)))}return[255*i(5),255*i(3),255*i(1)]}function getHopfFiber(index,numFibers,theta,startingFiber){var i=index/numFibers*(2*Math.PI),t=hsvToRgb(theta/Math.PI,Math.abs(i%Math.PI-Math.PI/2)/(Math.PI/2),1),i=[Math.cos(i)*Math.sin(theta),Math.sin(i)*Math.sin(theta),Math.cos(theta)],s=ThurstonGeometry.normalize([1+i[2],-i[1],i[0],0]),i=ThurstonGeometry.normalize([0,i[0],i[1],1+i[2]]);return[`
		float distance${index+1+startingFiber} = greatCircleDistance(
			pos,
			vec4(${s[0]}, ${s[1]}, ${s[2]}, ${s[3]}),
			vec4(${i[0]}, ${i[1]}, ${i[2]}, ${i[3]}),
			fiberThickness);
		`,t]}class S3HopfFibration extends S3Geometry{constructor(){super();var i=20,t=(this.distanceEstimatorGlsl="",new Array(60));for(let a=0;a<i;a++){var s=getHopfFiber(a,i,Math.PI/4,0);this.distanceEstimatorGlsl+=s[0],t[a]=s[1]}for(let n=0;n<i;n++){var o=getHopfFiber(n,i,Math.PI/2,i);this.distanceEstimatorGlsl+=o[0],t[i+n]=o[1]}for(let r=0;r<i;r++){var e=getHopfFiber(r,i,3*Math.PI/4,40);this.distanceEstimatorGlsl+=e[0],t[40+r]=e[1]}this.distanceEstimatorGlsl+=`
			float minDistance = ${getMinGlslString("distance",60)};
		`,this.getColorGlsl=this.distanceEstimatorGlsl+getColorGlslString("distance","minDistance",t),this.distanceEstimatorGlsl+="return minDistance;"}functionGlsl=`
		//p and v must be orthonormal.
		float greatCircleDistance(vec4 pos, vec4 p, vec4 v, float r)
		{
			float dot1 = dot(pos, p);
			float dot2 = dot(pos, v);

			return acos(sqrt(dot1 * dot1 + dot2 * dot2)) - r;
		}
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(1.0, 1.0, 1.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-1.0, -1.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(1.0, 1.0, 1.0, 0.0) - pos);
		float dotProduct3 = dot(surfaceNormal, lightDirection3);

		vec4 lightDirection4 = normalize(vec4(-1.0, -1.0, -1.0, 0.0) - pos);
		float dotProduct4 = dot(surfaceNormal, lightDirection4);

		float lightIntensity = max(
			max(abs(dotProduct1), abs(dotProduct2)),
			max(abs(dotProduct3), abs(dotProduct4))
		);
	`;cameraPos=[0,0,0,-1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float fiberThickness;
	`;uniformNames=["fiberThickness"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.fiberThickness,this.sliderValues.fiberThickness)}}export{S3Axes,S3Rooms,S3HopfFibration};