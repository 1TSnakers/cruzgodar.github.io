import{ThurstonGeometry}from"../class.min.js";import{BaseGeometry,getMinGlslString}from"./base.min.js";class SL2RGeometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = getUpdatedPos(startPos, rayDirectionVec, t);

		// globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;normalizeGlsl=`
		return normalize(dir);
	`;fogGlsl=`
		return color;//mix(color, fogColor, 1.0 - exp(-totalT * 0.2));
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float tanh(float x)
		{
			float expTerm = exp(2.0 * x);

			return (expTerm - 1.0) / (expTerm + 1.0);
		}

		// Projects a point p in the universal cover, i.e. H^2 x R, down to Q.
		vec4 projectToQ(vec4 p)
		{
			float denominator = sqrt(2.0 * p.z + 2.0);

			float zetaOutput = vec4(
				sqrt((p.z + 1.0) * 0.5),
				0.0,
				p.x / denominator,
				p.y / denominator
			);

			float cosineTerm = cos(pos.w * 0.5);
			float sineTerm = sin(pos.w * 0.5);

			return mat4(
				cosineTerm, sineTerm, 0.0, 0.0,
				-sineTerm, cosineTerm, 0.0, 0.0,
				0.0, 0.0, cosineTerm, -sineTerm,
				0.0, 0.0, sineTerm, cosineTerm
			) * zetaOutput;
		}

		const mat2 E0 = mat2(1.0, 0.0, 0.0, 1.0);
		const mat2 E1 = mat2(0.0, -1.0, 1.0, 0.0);
		const mat2 E2 = mat2(0.0, 1.0, 1.0, 0.0);
		const mat2 E0 = mat2(1.0, 0.0, 0.0, -1.0);

		void applyH2Isometry(vec4 qElement, inout vec3 h2Element)
		{
			mat2 h2Matrix = -h2Element.x * E3 + h2Element.y * E2 + h2Element.z * E1;
			mat2 qMatrix = qElement.x * E0 + qElement.y * E1 + qElement.z * E2 + qElement.w * E3;

			mat2 conjugatedh2Matrix = qMatrix * h2Matrix * inverse(qMatrix);

			h2Element = vec3(
				conjugatedh2Matrix[1][1],
				0.5 * (conjugatedh2Matrix[1][0] + conjugatedh2Matrix[0][1]),
				0.5 * (conjugatedh2Matrix[1][0] - conjugatedh2Matrix[0][1])
			);
		}

		const float root2Over2 = 0.70710678;
		
		vec4 getUpdatedPos(vec4 startPos, vec4 rayDirectionVec, float t)
		{
			float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
			float a = length(rayDirectionVec.xy);
			float c = rayDirectionVec.w;
			float kappa = sqrt(abs(c*c - a*a));
		
			vec4 pos;
		
			if (c > a)
			{
				float trigArg = kappa * t * 0.5;
				float sineFactor = sin(trigArg);

				pos = vec3(
					2.0 * a / kappa * sineFactor * cos(trigArg),
					-2.0 * a * c / (kappa * kappa) * sineFactor * sineFactor,
					1.0 + 2.0 * a * a / (kappa * kappa) * sineFactor * sineFactor,
					2.0 * c * t + 2.0 * atan(-c / kappa * tan(trigArg))
						- sign(c) * floor(0.5 * kappa * t / 3.14159265 + 0.5) * 6.28318531
						// Had to go digging in their code for this last term
						// since it's only referred to in the paper as a adjustment by
						// "the correct multiple of 2pi". This belongs in the paper!!
				);
			}

			else if (c == a)
			{
				pos = vec4(
					root2Over2 * t,
					-t * t * 0.25,
					1.0 + t * t * 0.25,
					2.0 * c * t - root2Over2 * t
				);
			}

			else
			{
				float trigArg = kappa * t * 0.5;
				float sineFactor = sinh(trigArg);

				pos = vec3(
					2.0 * a / kappa * sineFactor * cosh(trigArg),
					-2.0 * a * c / (kappa * kappa) * sineFactor * sineFactor,
					1.0 + 2.0 * a * a / (kappa * kappa) * sineFactor * sineFactor,
					2.0 * c * t + 2.0 * atan(-c / kappa * tanh(trigArg))
				);
			}

			// Apply r_alpha.
			pos.xy = mat2(
				cos(alpha), sin(alpha),
				-sin(alpha), cos(alpha)
			) * pos.xy;

			// Finally, translate this to the starting position, beginning by getting the element
			// of Q corresponding to this.
			vec4 qElement = projectToQ(startPos);

			// Now this element induces an isomorphism of H^2 by conjugation. We'll apply
			// it to the H^2 part of pos.
			applyH2Isometry(qElement, pos.xyz);

			pos.w += startPos.w;
		}
	`;followGeodesic(pos,dir,t){var e=Math.atan2(dir[1],dir[0]),o=Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]),a=dir[2];return ThurstonGeometry.mat4TimesVector(A,Math.abs(a)<.01?[o*Math.cos(e)*t,o*Math.sin(e)*t,0,1]:[2*o/a*Math.sin(a*t/2)*Math.cos(a*t/2+e),2*o/a*Math.sin(a*t/2)*Math.sin(a*t/2+e),a*t+o*o/(2*a*a)*(a*t-Math.sin(a*t)),1])}getNormalVec(){return[0,0,0,1]}correctVectors(){}baseColorIncreases=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];baseColor=[0,0,0];teleportCamera(){var t=[[[1,0,0,1],[0,1,0,0],[0,.5,1,0],[0,0,0,1]],[[1,0,0,-1],[0,1,0,0],[0,-.5,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,1],[-.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,-1],[.5,0,1,0],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,1],[0,0,0,1]],[[1,0,0,0],[0,1,0,0],[0,0,1,-1],[0,0,0,1]]];for(let e=0;e<3;e++)this.cameraPos[e]<-.5?(this.cameraPos=ThurstonGeometry.mat4TimesVector(t[2*e],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*e][0],this.baseColor[1]+=this.baseColorIncreases[2*e][1],this.baseColor[2]+=this.baseColorIncreases[2*e][2]):.5<this.cameraPos[e]&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(t[2*e+1],this.cameraPos),this.baseColor[0]+=this.baseColorIncreases[2*e+1][0],this.baseColor[1]+=this.baseColorIncreases[2*e+1][1],this.baseColor[2]+=this.baseColorIncreases[2*e+1][2])}}class SL2RSpheres extends SL2RGeometry{static distances=`
		float radius = .25;
		float distance1 = approximateDistanceToOrigin(pos);

		if (distance1 > radius + 1.0)
		{
			distance1 -= radius;
		}

		else
		{
			distance1 = exactDistanceToOrigin(pos) - radius;
		}

		
		// The distance to the x and y teleportation planes is the distance between the projections
		// to E^2. Unfortunately for our performance, the tolerances really do need to be this tight
		// to avoid artifacts.
		float distance2 = abs(pos.x - 0.515);
		float distance3 = abs(pos.x + 0.515);

		float distance4 = abs(pos.y - 0.515);
		float distance5 = abs(pos.y + 0.515);
	`;distanceEstimatorGlsl=`
		${SL2RSpheres.distances}

		float minDistance = ${getMinGlslString("distance",5)};

		return minDistance;
	`;getColorGlsl=`
		return vec3(
			.25 + .75 * (.5 * (sin(floor(baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
			.25 + .75 * (.5 * (sin(floor(baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.4 * lightBrightness * max(abs(dotProduct1), abs(dotProduct2));
	`;ambientOcclusionDenominator="250.0";getMovingSpeed(){return 1}cameraPos=[.163559,-.438969,.124604,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[.0748089,.997196,0,0];forwardVec=[.997199,-.074809,0,0];baseColor=[-2,0,-2];uniformGlsl=`
		uniform vec3 baseColor;
	`;uniformNames=["baseColor"];updateUniforms(gl,uniformList){gl.uniform3fv(uniformList.baseColor,this.baseColor)}}export{SL2RSpheres};