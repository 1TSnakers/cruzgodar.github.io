import{ThurstonGeometry}from"../class.min.js";import{sliderValues}from"../index.min.js";import{BaseGeometry,getMatrixGlsl,getMinGlslString,getVectorGlsl}from"./base.min.js";import{$}from"/scripts/src/main.min.js";function getTransformationMatrix(pos){return[[pos[0],-pos[1],pos[2],pos[3]],[pos[1],pos[0],pos[3],-pos[2]],[pos[2],pos[3],pos[0],-pos[1]],[pos[3],-pos[2],pos[1],pos[0]]]}const root2=Math.sqrt(2),root2Over2=Math.sqrt(2)/2,root1PlusRoot2=Math.sqrt(1+Math.sqrt(2)),delta=Math.sqrt(2)*Math.sqrt(Math.sqrt(2)-1),teleportElements=[[root2Over2+1,-root2Over2-1,-root2*root1PlusRoot2,0],[root2Over2+1,-root2Over2-1,root2*root1PlusRoot2,0],[root2Over2+1,root2Over2+1,root1PlusRoot2,-root1PlusRoot2],[root2Over2+1,root2Over2+1,-root1PlusRoot2,root1PlusRoot2],[1,0,0,0]],teleportElementsInv=teleportElements.map(e=>[e[0],-e[1],-e[2],-e[3]]),teleportMatrices=[[getTransformationMatrix(teleportElementsInv[2]),getTransformationMatrix(teleportElementsInv[3])],[getTransformationMatrix(teleportElements[0]),getTransformationMatrix(teleportElements[1])],[getTransformationMatrix(teleportElements[2]),getTransformationMatrix(teleportElements[3])],[getTransformationMatrix(teleportElementsInv[0]),getTransformationMatrix(teleportElementsInv[1])],[getTransformationMatrix(teleportElements[4]),getTransformationMatrix(teleportElements[4])]],teleportFibers=[[-Math.PI/2,-Math.PI/2],[-Math.PI/2,-Math.PI/2],[Math.PI/2,Math.PI/2],[Math.PI/2,Math.PI/2],[-2*Math.PI,2*Math.PI]],teleportVectors=[[[1,0,0],delta],[[root2Over2,root2Over2,0],delta],[[0,1,0],delta],[[-root2Over2,root2Over2,0],delta],[[0,0,1],Math.PI]];function getTeleportGlslChunk({comparisonVec,dotProductThreshhold,teleportMatPos,teleportMatNeg,fiberAdjustPos,fiberAdjustNeg,numTeleportations}){return`
		for (int i = 0; i < ${numTeleportations}; i++)
		{
			dotProduct = dot(kleinElement, ${comparisonVec});

			if (dotProduct > (${dotProductThreshhold}))
			{
				pos = ${teleportMatPos} * pos;
				fiber += ${fiberAdjustPos};

				startPos = pos;
				startFiber = fiber;
				totalT += t;
				t = 0.0;

				kleinElement = getKleinElement(pos, fiber);
			}

			else if (dotProduct < -(${dotProductThreshhold}))
			{
				pos = ${teleportMatNeg} * pos;
				fiber += ${fiberAdjustNeg};

				startPos = pos;
				startFiber = fiber;
				totalT += t;
				t = 0.0;

				kleinElement = getKleinElement(pos, fiber);
			}

			else
			{
				break;
			}
		}
	`}function getBinarySearchGlslChunk({comparisonVec,dotProductThreshhold,searchIterations}){return`
		dotProduct = dot(kleinElement, ${comparisonVec});

		if (abs(dotProduct) > ${dotProductThreshhold})
		{
			// Binary search our way down until we're back in the fundamental domain.
			// It feels like we should change totalT here to reflect the new value, but that seems
			// to badly affect fog calculations.
			float oldT = t - lastTIncrease;

			// The factor by which we multiply lastTIncrease to get the usable increase.
			float currentSearchPosition = 0.5;
			float currentSearchScale = 0.25;

			for (int i = 0; i < ${searchIterations}; i++)
			{
				getUpdatedPos(startPos, startFiber, rayDirectionVec, oldT + lastTIncrease * currentSearchPosition, pos, fiber);

				kleinElement = getKleinElement(pos, fiber);

				dotProduct = dot(kleinElement, ${comparisonVec});

				if (abs(dotProduct) > ${dotProductThreshhold})
				{
					currentSearchPosition -= currentSearchScale;
				}

				else 
				{
					currentSearchPosition += currentSearchScale;
				}

				currentSearchScale *= .5;
			}

			t = oldT + lastTIncrease * currentSearchPosition;

			totalT -= lastTIncrease * (1.0 - currentSearchPosition);

			getUpdatedPos(startPos, startFiber, rayDirectionVec, t, pos, fiber);

			kleinElement = getKleinElement(pos, fiber);
		}
	`}function getH2Element(qElement){return[2*qElement[0]*qElement[2]-2*qElement[1]*qElement[3],2*qElement[0]*qElement[3]+2*qElement[1]*qElement[2],qElement[0]*qElement[0]+qElement[1]*qElement[1]+qElement[2]*qElement[2]+qElement[3]*qElement[3]]}function getKleinElement(qElement,fiber){var e=getH2Element(qElement);return[e[0]/e[2],e[1]/e[2],fiber]}class SL2RGeometry extends BaseGeometry{raymarchSetupGlsl=`
		float startFiber = cameraFiber;
	`;geodesicGlsl=`
		vec4 pos;
		float fiber;

		getUpdatedPos(startPos, startFiber, rayDirectionVec, t, pos, fiber);

		vec3 kleinElement = getKleinElement(pos, fiber);
		
		float dotProduct;

	${getBinarySearchGlslChunk({comparisonVec:"teleportVec1",dotProductThreshhold:"delta + .00005",searchIterations:"10"})}

	${getBinarySearchGlslChunk({comparisonVec:"teleportVec2",dotProductThreshhold:"delta + .00005",searchIterations:"10"})}

	${getBinarySearchGlslChunk({comparisonVec:"teleportVec3",dotProductThreshhold:"delta + .00005",searchIterations:"10"})}

	${getBinarySearchGlslChunk({comparisonVec:"teleportVec4",dotProductThreshhold:"delta + .00005",searchIterations:"10"})}

	${getBinarySearchGlslChunk({comparisonVec:"teleportVec5",dotProductThreshhold:"pi + .00005",searchIterations:"10"})}

		globalColor += teleportPos(pos, fiber, startPos, startFiber, rayDirectionVec, t, totalT);
	`;fogGlsl=`
		return color;//mix(color, fogColor, 1.0 - exp(-totalT * 0.2));
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float tanh(float x)
		{
			float expTerm = exp(2.0 * x);

			return (expTerm - 1.0) / (expTerm + 1.0);
		}

		float acosh(float x)
		{
			return log(x + sqrt(x*x - 1.0));
		}

		// Given an element in SL(2, R), returns an isometry sending the origin to that point.
		// For future reference: the inverse to one of these is given by negating y, z, and w.
		mat4 getTransformationMatrix(vec4 pos)
		{
			return mat4(
				pos.x, pos.y, pos.z, pos.w,
				-pos.y, pos.x, pos.w, -pos.z,
				pos.z, pos.w, pos.x, pos.y,
				pos.w, -pos.z, -pos.y, pos.x
			);
		}

		// Projects a point p in the universal cover, i.e. H^2 x R, down to Q, via the map lambda.
		vec4 projectToQ(vec4 p)
		{
			float denominator = sqrt(2.0 * p.z + 2.0);

			vec4 zetaOutput = vec4(
				sqrt((p.z + 1.0) * 0.5),
				0.0,
				p.x / denominator,
				p.y / denominator
			);

			float cosineTerm = cos(p.w * 0.5);
			float sineTerm = sin(p.w * 0.5);

			return mat4(
				cosineTerm, sineTerm, 0.0, 0.0,
				-sineTerm, cosineTerm, 0.0, 0.0,
				0.0, 0.0, cosineTerm, -sineTerm,
				0.0, 0.0, sineTerm, cosineTerm
			) * zetaOutput;
		}

		const mat2 E0 = mat2(1.0, 0.0, 0.0, 1.0);
		const mat2 E1 = mat2(0.0, -1.0, 1.0, 0.0);
		const mat2 E2 = mat2(0.0, 1.0, 1.0, 0.0);
		const mat2 E3 = mat2(1.0, 0.0, 0.0, -1.0);

		void applyH2Isometry(vec4 qElement, inout vec3 h2Element)
		{
			// Yet another thing that should be in the paper but is only knowable
			// by digging around in their code. I'd prefer to use mat4x3 and mat3x4 here,
			// but WebGL doesn't seem to understand.
			h2Element = mat3(
				mat4(
					qElement.x, qElement.y, qElement.z, 0.0,
					-qElement.y, qElement.x, qElement.w, 0.0,
					qElement.z, qElement.w, qElement.x, 0.0,
					//Weird that this one is negative
					-qElement.w, qElement.z, qElement.y, 0.0
				) * mat4(
					qElement.x, qElement.y, qElement.z, qElement.w,
					-qElement.y, qElement.x, qElement.w, -qElement.z,
					qElement.z, qElement.w, qElement.x, qElement.y,
					0.0, 0.0, 0.0, 0.0
				)
			) * h2Element;
		}

		// A special case of the previous function that acts on (0, 0, 1).
		vec3 getH2Element(vec4 qElement)
		{
			return vec3(
				2.0 * qElement.x * qElement.z - 2.0 * qElement.y * qElement.w,
				2.0 * qElement.x * qElement.w + 2.0 * qElement.y * qElement.z,
				qElement.x * qElement.x + qElement.y * qElement.y + qElement.z * qElement.z + qElement.w * qElement.w
			);
		}

		vec3 getKleinElement(vec4 qElement, float fiber)
		{
			vec3 h2Element = getH2Element(qElement);

			return vec3(h2Element.x / h2Element.z, h2Element.y / h2Element.z, fiber);
		}

		const float root2Over2 = 0.70710678;
		
		void getUpdatedPos(
			vec4 startPos,
			float startFiber,
			vec4 rayDirectionVec,
			float t,
			inout vec4 pos,	
			inout float fiber
		) {
			float alpha = atan(rayDirectionVec.y, rayDirectionVec.x);
			float a = length(rayDirectionVec.xy);
			float c = rayDirectionVec.w;
			float kappa = sqrt(abs(c*c - a*a));

			vec4 eta;

			if (abs(c) == a)
			{
				eta = vec4(1.0, -0.5 * root2Over2 * t, 0.5 * root2Over2 * t, 0.0);

				fiber = 2.0 * c * t + 2.0 * atan(-0.5 * root2Over2 * t);
			}
		
			else if (abs(c) > a)
			{
				float trigArg = kappa * t * 0.5;
				float sineFactor = sin(trigArg);

				eta = vec4(cos(trigArg), -c / kappa * sineFactor, a / kappa * sineFactor, 0.0);
				
				// Had to go digging in their code for this last term
				// since it's only referred to in the paper as a adjustment by
				// "the correct multiple of 2pi". This belongs in the paper!!
				fiber = 2.0 * c * t + 2.0 * atan(-c / kappa * tan(trigArg))
					- sign(c) * floor(0.5 * kappa * t / 3.14159265 + 0.5) * 6.28318531;
			}

			else
			{
				float trigArg = kappa * t * 0.5;
				float sinhFactor = sinh(trigArg);

				eta = vec4(cosh(trigArg), -c / kappa * sinhFactor, a / kappa * sinhFactor, 0.0);

				fiber = 2.0 * c * t + 2.0 * atan(-c / kappa * tanh(trigArg));
			}

			// This is eta * ksi, where ksi = (cos(ct), sin(ct), 0, 0) and the multiplication
			// is group multiplication in SL(2, R).
			float sinct = sin(c * t);
			float cosct = cos(c * t);

			eta = vec4(
				eta.x * cosct - eta.y * sinct,
				eta.x * sinct + eta.y * cosct,
				eta.z * cosct,
				-eta.z * sinct
			);

			// Finally, apply R_alpha.
			float sinAlpha = sin(alpha);
			float cosAlpha = cos(alpha);

			eta.zw = vec2(cosAlpha * eta.z - sinAlpha * eta.w, sinAlpha * eta.z + cosAlpha * eta.w);

			// What we have at this point is eta in SL(2, R) and fiber, together specifying
			// a point in the universal cover after flowing from the origin for time t. We now
			// need to translate these to startPos and startFiber, respectively.
			pos = getTransformationMatrix(startPos) * eta;

			fiber += startFiber;
		}

		const float pi = 3.14159265;
		const float piOver2 = 1.5707963;

		const float root2 = 1.41421356;
		const float root2Over2Plus1 = 1.7071068;
		const float root1PlusRoot2 = 1.55377397;

		const vec3 teleportVec1 = ${getVectorGlsl(teleportVectors[0][0])};
		const vec3 teleportVec2 = ${getVectorGlsl(teleportVectors[1][0])};
		const vec3 teleportVec3 = ${getVectorGlsl(teleportVectors[2][0])};
		const vec3 teleportVec4 = ${getVectorGlsl(teleportVectors[3][0])};
		const vec3 teleportVec5 = ${getVectorGlsl(teleportVectors[4][0])};

		const mat4 teleportMat1Pos = ${getMatrixGlsl(teleportMatrices[0][0])};
		const mat4 teleportMat1Neg = ${getMatrixGlsl(teleportMatrices[0][1])};
		const mat4 teleportMat2Pos = ${getMatrixGlsl(teleportMatrices[1][0])};
		const mat4 teleportMat2Neg = ${getMatrixGlsl(teleportMatrices[1][1])};
		const mat4 teleportMat3Pos = ${getMatrixGlsl(teleportMatrices[2][0])};
		const mat4 teleportMat3Neg = ${getMatrixGlsl(teleportMatrices[2][1])};
		const mat4 teleportMat4Pos = ${getMatrixGlsl(teleportMatrices[3][0])};
		const mat4 teleportMat4Neg = ${getMatrixGlsl(teleportMatrices[3][1])};
		const mat4 teleportMat5Pos = ${getMatrixGlsl(teleportMatrices[4][0])};
		const mat4 teleportMat5Neg = ${getMatrixGlsl(teleportMatrices[4][1])};

		const float fiberAdjust1Pos = ${teleportFibers[0][0]};
		const float fiberAdjust1Neg = ${teleportFibers[0][1]};
		const float fiberAdjust2Pos = ${teleportFibers[1][0]};
		const float fiberAdjust2Neg = ${teleportFibers[1][1]};
		const float fiberAdjust3Pos = ${teleportFibers[2][0]};
		const float fiberAdjust3Neg = ${teleportFibers[2][1]};
		const float fiberAdjust4Pos = ${teleportFibers[3][0]};
		const float fiberAdjust4Neg = ${teleportFibers[3][1]};
		const float fiberAdjust5Pos = ${teleportFibers[4][0]};
		const float fiberAdjust5Neg = ${teleportFibers[4][1]};

		const float dotProductThreshhold1 = ${teleportVectors[0][1]};
		const float dotProductThreshhold2 = ${teleportVectors[1][1]};
		const float dotProductThreshhold3 = ${teleportVectors[2][1]};
		const float dotProductThreshhold4 = ${teleportVectors[3][1]};
		const float dotProductThreshhold5 = ${teleportVectors[4][1]};

		const vec4 teleportElement1Pos = ${getVectorGlsl(teleportElementsInv[2])};
		const vec4 teleportElement1Neg = ${getVectorGlsl(teleportElementsInv[3])};
		const vec4 teleportElement2Pos = ${getVectorGlsl(teleportElements[0])};
		const vec4 teleportElement2Neg = ${getVectorGlsl(teleportElements[1])};
		const vec4 teleportElement3Pos = ${getVectorGlsl(teleportElements[2])};
		const vec4 teleportElement3Neg = ${getVectorGlsl(teleportElements[3])};
		const vec4 teleportElement4Pos = ${getVectorGlsl(teleportElementsInv[0])};
		const vec4 teleportElement4Neg = ${getVectorGlsl(teleportElementsInv[1])};
		const vec4 teleportElement5Pos = ${getVectorGlsl(teleportElements[4])};
		const vec4 teleportElement5Neg = ${getVectorGlsl(teleportElements[4])};

		const float delta = ${delta};

		vec3 teleportPos(inout vec4 pos, inout float fiber, inout vec4 startPos, inout float startFiber, inout vec4 rayDirectionVec, inout float t, inout float totalT)
		{
			vec3 color = vec3(0.0, 0.0, 0.0);

			// First, we need to get the corresponding point in the Klein model of H^2, which is given by the intersection
			// of the line from our point on the hyperboloid to the origin with the plane z = 1.
			vec3 kleinElement = getKleinElement(pos, fiber);

			float dotProduct;

	${getTeleportGlslChunk({comparisonVec:"teleportVec1",dotProductThreshhold:"dotProductThreshhold1",teleportMatPos:"teleportMat1Pos",teleportMatNeg:"teleportMat1Neg",fiberAdjustPos:"fiberAdjust1Pos",fiberAdjustNeg:"fiberAdjust1Neg",numTeleportations:"1"})}

	${getTeleportGlslChunk({comparisonVec:"teleportVec2",dotProductThreshhold:"dotProductThreshhold2",teleportMatPos:"teleportMat2Pos",teleportMatNeg:"teleportMat2Neg",fiberAdjustPos:"fiberAdjust2Pos",fiberAdjustNeg:"fiberAdjust2Neg",teleportElementPos:"teleportElement2Pos",teleportElementNeg:"teleportElement2Neg",numTeleportations:"1"})}

	${getTeleportGlslChunk({comparisonVec:"teleportVec3",dotProductThreshhold:"dotProductThreshhold3",teleportMatPos:"teleportMat3Pos",teleportMatNeg:"teleportMat3Neg",fiberAdjustPos:"fiberAdjust3Pos",fiberAdjustNeg:"fiberAdjust3Neg",teleportElementPos:"teleportElement3Pos",teleportElementNeg:"teleportElement3Neg",numTeleportations:"1"})}

	${getTeleportGlslChunk({comparisonVec:"teleportVec4",dotProductThreshhold:"dotProductThreshhold4",teleportMatPos:"teleportMat4Pos",teleportMatNeg:"teleportMat4Neg",fiberAdjustPos:"fiberAdjust4Pos",fiberAdjustNeg:"fiberAdjust4Neg",teleportElementPos:"teleportElement4Pos",teleportElementNeg:"teleportElement4Neg",numTeleportations:"1"})}

	${getTeleportGlslChunk({comparisonVec:"teleportVec5",dotProductThreshhold:"dotProductThreshhold5",teleportMatPos:"teleportMat5Pos",teleportMatNeg:"teleportMat5Neg",fiberAdjustPos:"fiberAdjust5Pos",fiberAdjustNeg:"fiberAdjust5Neg",teleportElementPos:"teleportElement5Pos",teleportElementNeg:"teleportElement5Neg",numTeleportations:"1"})}

			return color;
		}
	`;usesFiberComponent=!0;correctPosition(pos){var e=Math.sqrt(pos[0]*pos[0]+pos[1]*pos[1]-pos[2]*pos[2]-pos[3]*pos[3]);return[pos[0]/e,pos[1]/e,pos[2]/e,pos[3]/e]}getNormalVec(){return[0,0,1,0]}followGeodesic(pos,dir,t){var e,o=Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]),r=dir[3],s=Math.sqrt(Math.abs(r*r-o*o));let l,a;a=Math.abs(r)===o?(l=[1,-.35355339*t,.5*t,0],2*r*t+2*Math.atan(-.35355339*t)):Math.abs(r)>o?(o=s*t*.5,e=Math.sin(o),l=[Math.cos(o),-r/s*e,1/s*e,0],2*r*t+2*Math.atan(-r/s*Math.tan(o))-Math.sign(r)*Math.floor(.5*s*t/Math.PI+.5)*2*Math.PI):(e=s*t*.5,o=Math.sinh(e),l=[Math.cosh(e),-r/s*o,1/s*o,0],2*r*t+2*Math.atan(-r/s*Math.tanh(e)));o=Math.sin(r*t),s=Math.cos(r*t);return l=[l[0]*s-l[1]*o,l[0]*o+l[1]*s,l[2]*s,-l[2]*o],l=ThurstonGeometry.mat4TimesVector([[1,0,0,0],[0,1,0,0],[0,0,dir[0],-dir[1]],[0,0,dir[1],dir[0]]],l),this.cameraFiber+=a,ThurstonGeometry.mat4TimesVector([[pos[0],-pos[1],pos[2],pos[3]],[pos[1],pos[0],pos[3],-pos[2]],[pos[2],pos[3],pos[0],-pos[1]],[pos[3],-pos[2],pos[1],pos[0]]],l)}correctVectors(){}teleportCamera(){let e=getKleinElement(this.cameraPos,this.cameraFiber);for(let o=0;o<teleportMatrices.length;o++){var t=e[0]*teleportVectors[o][0][0]+e[1]*teleportVectors[o][0][1]+e[2]*teleportVectors[o][0][2];t>teleportVectors[o][1]?(this.cameraPos=ThurstonGeometry.mat4TimesVector(teleportMatrices[o][0],this.cameraPos),this.cameraFiber+=teleportFibers[o][0],e=getKleinElement(this.cameraPos,this.cameraFiber)):t<-teleportVectors[o][1]&&(this.cameraPos=ThurstonGeometry.mat4TimesVector(teleportMatrices[o][1],this.cameraPos),this.cameraFiber+=teleportFibers[o][1],e=getKleinElement(this.cameraPos,this.cameraFiber))}}}class SL2RRooms extends SL2RGeometry{static distances=`
		vec3 h2Element = getH2Element(pos);

		float distance1 = length(vec2(acosh(h2Element.z), fiber)) - 1.83;

		// The fundamental domain has height 2pi, so to evenly space three balls,
		// we want the gap between them to be (2pi - 6 * radius) / 3.
		// Solving for the center of the other spheres gives +/- 2pi/3.

		float distance2 = length(vec2(acosh(h2Element.z), fiber - 0.66667 * pi)) - 1.83;
		float distance3 = length(vec2(acosh(h2Element.z), fiber + 0.66667 * pi)) - 1.83;
	`;distanceEstimatorGlsl=`
		${SL2RRooms.distances}

		float minDistance = ${getMinGlslString("distance",3)};

		return -minDistance;
	`;getColorGlsl=`
		return vec3(0.5, 0.5, 0.5);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.0;//max(dotProduct1, dotProduct2);
	`;getMovingSpeed(){return 1}cameraPos=[1.0001,0,.014142,0];cameraFiber=0;normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float cameraFiber;
	`;uniformNames=["cameraFiber"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.cameraFiber,this.cameraFiber)}}class SL2RSpheres extends SL2RGeometry{static distances=`
		vec3 h2Element = getH2Element(pos);

		float distance1 = length(vec2(acosh(h2Element.z), fiber)) - wallThickness;

		// The fundamental domain has height 2pi, so to evenly space three balls,
		// we want the gap between them to be (2pi - 6 * radius) / 3.
		// Solving for the center of the other spheres gives +/- 2pi/3.

		float distance2 = length(vec2(acosh(h2Element.z), fiber - 0.66667 * pi)) - wallThickness;
		float distance3 = length(vec2(acosh(h2Element.z), fiber + 0.66667 * pi)) - wallThickness;
	`;distanceEstimatorGlsl=`
		${SL2RSpheres.distances}

		float minDistance = ${getMinGlslString("distance",3)};

		return minDistance;
	`;getColorGlsl=`
		return vec3(0.5, 0.5, 0.5);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.0;//max(dotProduct1, dotProduct2);
	`;getMovingSpeed(){return 1}cameraPos=[1.0001,0,.014142,0];cameraFiber=0;normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float cameraFiber;
		uniform float wallThickness;
	`;uniformNames=["cameraFiber","wallThickness"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.cameraFiber,this.cameraFiber),gl.uniform1f(uniformList.wallThickness,sliderValues.wallThickness)}uiElementsUsed="#wall-thickness-slider";initUI(){var e=$("#wall-thickness-slider"),t=$("#wall-thickness-slider-value");e.min=0,e.max=1,e.value=0,t.textContent=0,sliderValues.wallThickness=0}}export{SL2RRooms,SL2RSpheres};