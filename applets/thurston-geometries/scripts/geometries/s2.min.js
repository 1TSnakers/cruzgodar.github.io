import{BaseGeometry,getMinGlslString}from"./base.min.js";import{E3Geometry}from"./e3.min.js";import{S2xEGeometry}from"./s2xe.min.js";class E3S2Demo extends E3Geometry{distanceEstimatorGlsl=`
		float distance1 = length(pos.xyz) - 1.0;

		return distance1;
	`;getColorGlsl=`
		pos.xyz /= 1.001;

		float radius = .5;

		if (acos(dot(pos.xyz, normalize(vec3(1, 0, 0)))) - radius < 0.0)
		{
			return vec3(1.0, 0.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 1, 0)))) - radius < 0.0)
		{
			return vec3(0.0, 1.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(-1, 0, 0)))) - radius < 0.0)
		{
			return vec3(0.0, 0.0, 1.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, -1, 0)))) - radius < 0.0)
		{
			return vec3(1.0, 1.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 0, -1)))) - radius < 0.0)
		{
			return vec3(0.5, 0.5, 0.5);
		}

		return vec3(1.0, 1.0, 1.0);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(-3.0, 1.5, 1.5, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.5 + .5 * dotProduct1 * dotProduct1) * 1.15;
	`;correctPosition(pos){var e=Math.sqrt(pos[0]*pos[0]+pos[1]*pos[1]+pos[2]*pos[2])/2.5;return[pos[0]/e,pos[1]/e,pos[2]/e,1]}correctVectors(){this.forwardVec=this.normalize([-this.cameraPos[0],-this.cameraPos[1],0,0]);var e=this.dotProduct(this.forwardVec,this.rightVec);for(let t=0;t<4;t++)this.rightVec[t]-=e*this.forwardVec[t];this.rightVec=this.normalize(this.rightVec)}cameraPos=[-2.5,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];movingSpeed=5;lockedOnOrigin=!0;fov=Math.tan(30*Math.PI/180);controlMode=BaseGeometry.REQUIRE_MODIFIER}class S2xES2Demo extends S2xEGeometry{static distances=`
		float distance1 = length(vec2(acos(pos.x), pos.w)) - .5;
		float distance2 = length(vec2(acos(-pos.x), pos.w)) - .5;
		float distance3 = length(vec2(acos(pos.y), pos.w)) - .5;
		float distance4 = length(vec2(acos(-pos.y), pos.w)) - .5;
		float distance5 = length(vec2(acos(-pos.z), pos.w)) - .5;

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${S2xES2Demo.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xES2Demo.distances}

		if (minDistance == distance1)
		{
			return vec3(1.0, 0.0, 0.0);
		}

		if (minDistance == distance2)
		{
			return vec3(0.0, 1.0, 0.0);
		}

		if (minDistance == distance3)
		{
			return vec3(0.0, 0.0, 1.0);
		}

		if (minDistance == distance4)
		{
			return vec3(1.0, 1.0, 0.0);
		}

		return vec3(0.5, 0.5, 0.5);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(0.0, 0.0, 1.0, 0.0) - pos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.25 * abs(dotProduct1);
	`;render1D=!0;cameraPos=[0,0,1,0];normalVec=[0,0,1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];aspectRatio=10;controlMode=BaseGeometry.DISALLOW_MODIFIER}export{E3S2Demo,S2xES2Demo};