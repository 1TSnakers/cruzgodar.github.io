import{getMinGlslString}from"../../../../scripts/applets/applet.min.js";import{E3Geometry}from"./e3.min.js";import{S2xEGeometry}from"./s2xe.min.js";function getSphereBandGlsl(index){return`
		if (
			length((normalizedPos - dot(normalizedPos, testVec${index}.xyz) * testVec${index}.xyz)) > 0.99995
		){
			float effectiveDistance = distanceToCamera;

			if (dot(directionToCamera, rayDir${index}.xyz) < 0.0)
			{
				effectiveDistance = 2.0 * pi - effectiveDistance;
			}

			if (effectiveDistance < rayLength${index})
			{
				return rayColor${index};
			}
		}
	`}class E3S2Demo extends E3Geometry{numRays=15;rayDirs=Array(this.numRays).fill([0,0,0,0]);testVecs=Array(this.numRays).fill([0,0,0,0]);rayLengths=Array(this.numRays).fill(0);rayColors=Array(this.numRays).fill([0,0,0]);static distances=`
		// The sphere itself.
		float distance1 = length(pos.xyz) - 1.0;

		// The camera.
		float distance2 = length(pos.xyz - cameraDotPos.xyz) - 0.05;

		float minDistance =  ${getMinGlslString("distance",2)};
	`;distanceEstimatorGlsl=`
		${E3S2Demo.distances}

		return minDistance;
	`;getColorGlsl=`
		${E3S2Demo.distances}

		if (minDistance == distance2)
		{
			return vec3(1.5);
		}

		pos.xyz /= 1.001;

		float radius = .35;
		float variation = .175;

		if (acos(dot(pos.xyz, normalize(vec3(1, 0, 0)))) - radius < 0.0)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 1, 0)))) - radius < 0.0)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (acos(dot(pos.xyz, normalize(vec3(-1, 0, 0)))) - radius < 0.0)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, -1, 0)))) - radius < 0.0)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 0, -1)))) - radius < 0.0)
		{
			return vec3(
				.5 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		float distanceToCamera = acos(dot(pos.xyz, cameraDotPos.xyz));
		vec3 directionToCamera = normalize((pos.xyz - cos(distanceToCamera) * cameraDotPos.xyz) / sin(distanceToCamera));

		vec3 normalizedPos = normalize(pos.xyz);

		${this.rayLengths.map((_,index)=>getSphereBandGlsl(index+1)).join("")}



		return vec3(1.0, 1.0, 1.0);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(-3.0, 1.5, 1.5, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.5 + .5 * dotProduct1 * dotProduct1) * 1.15;
	`;cameraPos=[-2.5,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];movingSpeed=0;lockedOnOrigin=!0;fov=Math.tan(30*Math.PI/180);cameraDotPos=[0,0,1,0];uniformGlsl=`
		uniform vec4 cameraDotPos;

		${this.rayLengths.map((_,index)=>"uniform vec4 rayDir"+(index+1)).join(";")};
		${this.rayLengths.map((_,index)=>"uniform vec4 testVec"+(index+1)).join(";")};
		${this.rayLengths.map((_,index)=>"uniform float rayLength"+(index+1)).join(";")};
		${this.rayLengths.map((_,index)=>"uniform vec3 rayColor"+(index+1)).join(";")};
	`;uniformNames=["cameraDotPos",...this.rayLengths.map((_,index)=>"rayDir"+(index+1)),...this.rayLengths.map((_,index)=>"testVec"+(index+1)),...this.rayLengths.map((_,index)=>"rayLength"+(index+1)),...this.rayLengths.map((_,index)=>"rayColor"+(index+1))];updateUniforms(gl,uniformList){gl.uniform4fv(uniformList.cameraDotPos,this.cameraDotPos);for(let i=0;i<this.numRays;i++)gl.uniform4fv(uniformList["rayDir"+(i+1)],this.rayDirs[i]),gl.uniform4fv(uniformList["testVec"+(i+1)],this.testVecs[i]),gl.uniform1f(uniformList["rayLength"+(i+1)],this.rayLengths[i]),gl.uniform3fv(uniformList["rayColor"+(i+1)],this.rayColors[i])}}class S2xES2Demo extends S2xEGeometry{static distances=`
		float radius = .35;

		float distance1 = acos(pos.x) - radius;
		float distance2 = acos(pos.y) - radius;
		float distance3 = acos(-pos.x) - radius;
		float distance4 = acos(-pos.y) - radius;
		float distance5 = acos(-pos.z) - radius;

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${S2xES2Demo.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xES2Demo.distances}

		float variation = .175;
		
		if (minDistance == distance1)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == distance3)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		if (minDistance == distance4)
		{
			return vec3(
				.85 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
				.5 + .15 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
				.5 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
			);
		}

		return vec3(
			.5 + .15 * (.5 * (sin((variation * pos.x) * 17.0) + 1.0)),
			.5 * (.5 * (sin((variation * pos.y) * 23.0) + 1.0)),
			.85 + .15 * (.5 * (sin((variation * pos.z) * 29.0) + 1.0))
		);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(0.0, 0.0, 1.0, 0.0) - pos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = abs(dotProduct1);
	`;render1D=!0;cameraPos=[0,0,1,0];normalVec=[0,0,1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];aspectRatio=10;ignoreAspectRatio=!0;distanceEstimator(pos){var i=.34,a=Math.acos(pos[0])-i,s=Math.acos(-pos[0])-i,t=Math.acos(pos[1])-i,o=Math.acos(-pos[1])-i,i=Math.acos(-pos[2])-i;return Math.min(Math.min(Math.min(a,s),Math.min(t,o)),i)}getColor(pos){var i=.35,a=Math.acos(pos[0])-i,s=Math.acos(pos[1])-i,t=Math.acos(-pos[0])-i,o=Math.acos(-pos[1])-i,i=Math.acos(-pos[2])-i,i=Math.min(Math.min(Math.min(a,s),Math.min(t,o)),i),n=.175;return 1e-5<i?[0,0,0]:i===a?[.5*(Math.sin(n*pos[0]*17)+1)*.5,.85+.5*(Math.sin(n*pos[1]*23)+1)*.15,.85+.5*(Math.sin(n*pos[2]*29)+1)*.15]:i===s?[.5*(Math.sin(n*pos[0]*17)+1)*.5,.5*(Math.sin(n*pos[1]*23)+1)*.5,.85+.5*(Math.sin(n*pos[2]*29)+1)*.15]:i===t?[.85+.5*(Math.sin(n*pos[0]*17)+1)*.15,.5*(Math.sin(n*pos[1]*23)+1)*.5,.5*(Math.sin(n*pos[2]*29)+1)*.5]:i===o?[.85+.5*(Math.sin(n*pos[0]*17)+1)*.15,.5+.5*(Math.sin(n*pos[1]*23)+1)*.15,.5*(Math.sin(n*pos[2]*29)+1)*.5]:[.5+.5*(Math.sin(n*pos[0]*17)+1)*.15,.5*(Math.sin(n*pos[1]*23)+1)*.5,.85+.5*(Math.sin(n*pos[2]*29)+1)*.15]}getRayData(rayDirs){var s=new Array(rayDirs.length),t=new Array(rayDirs.length);for(let e=0;e<rayDirs.length;e++){let i=0;var o=[...this.cameraPos];let a=[...o];for(var n;n=this.distanceEstimator(a),i+=.99*n,a=[Math.cos(i)*o[0]+Math.sin(i)*rayDirs[e][0],Math.cos(i)*o[1]+Math.sin(i)*rayDirs[e][1],Math.cos(i)*o[2]+Math.sin(i)*rayDirs[e][2],0],1e-5<n&&i<2*Math.PI;);s[e]=i,t[e]=this.getColor(a)}return[s,t]}}export{E3S2Demo,S2xES2Demo};