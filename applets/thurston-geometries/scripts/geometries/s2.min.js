import{getMinGlslString}from"./base.min.js";import{E3Geometry}from"./e3.min.js";import{S2xEGeometry}from"./s2xe.min.js";class E3S2Demo extends E3Geometry{distanceEstimatorGlsl=`
		float distance1 = length(pos.xyz) - 1.0;

		return distance1;
	`;getColorGlsl=`
		pos.xyz /= 1.001;

		float radius = .5;

		if (acos(dot(pos.xyz, normalize(vec3(1, 0, 0)))) - radius < 0.0)
		{
			return vec3(1.0, 0.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 1, 0)))) - radius < 0.0)
		{
			return vec3(0.0, 1.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(-1, 0, 0)))) - radius < 0.0)
		{
			return vec3(0.0, 0.0, 1.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, -1, 0)))) - radius < 0.0)
		{
			return vec3(1.0, 1.0, 0.0);
		}

		if (acos(dot(pos.xyz, normalize(vec3(0, 0, -1)))) - radius < 0.0)
		{
			return vec3(0.5, 0.5, 0.5);
		}

		return vec3(1.0, 1.0, 1.0);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(-3.0, 1.5, 1.5, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		float lightIntensity = (.5 + .5 * dotProduct1 * dotProduct1) * 1.15;
	`;cameraPos=[-1.5,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];lockedOnOrigin=!0;movingSpeed=1}class S2xES2Demo extends S2xEGeometry{static distances=`
		float distance1 = length(vec2(acos(pos.x), pos.w)) - .25;
		float distance2 = length(vec2(acos(-pos.x), pos.w)) - .25;
		float distance3 = length(vec2(acos(pos.y), pos.w)) - .25;
		float distance4 = length(vec2(acos(-pos.y), pos.w)) - .25;
		float distance5 = length(vec2(acos(pos.z), pos.w)) - .25;

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${S2xES2Demo.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xES2Demo.distances}

		if (minDistance == distance1)
		{
			return vec3(1.0, 0.0, 0.0);
		}

		if (minDistance == distance2)
		{
			return vec3(0.0, 1.0, 0.0);
		}

		if (minDistance == distance3)
		{
			return vec3(0.0, 0.0, 1.0);
		}

		if (minDistance == distance4)
		{
			return vec3(1.0, 1.0, 0.0);
		}

		return vec3(0.5, 0.5, 0.5);
	`;lightGlsl=`
		vec4 lightDirection1 = normalize(vec4(2.0, 2.0, 2.0, -2.0) - pos);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.5 * dotProduct1;
	`;cameraPos=[0,0,-1,0];normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[1,0,0,0];forwardVec=[0,-1,0,0]}export{E3S2Demo,S2xES2Demo};