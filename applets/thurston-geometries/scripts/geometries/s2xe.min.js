import{BaseGeometry,getMaxGlslString,getMinGlslString}from"./base.min.js";import{$}from"/scripts/src/main.min.js";class S2xEGeometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = vec4(
			cos(length(rayDirectionVec.xyz) * t) * startPos.xyz + sin(length(rayDirectionVec.xyz) * t) * normalize(rayDirectionVec.xyz),
			startPos.w + t * rayDirectionVec.w
		);
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * fogScaling * 8.0));
	`;correctPosition(pos){var s=Math.sqrt(pos[0]*pos[0]+pos[1]*pos[1]+pos[2]*pos[2]);return[pos[0]/s,pos[1]/s,pos[2]/s,pos[3]]}getNormalVec(cameraPos){return this.normalize([-cameraPos[0],-cameraPos[1],-cameraPos[2],0])}}class S2xEAxes extends S2xEGeometry{static distances=`
		float distance1 = length(vec2(acos(sqrt(1.0 - pos.y * pos.y)), pos.w)) - .1;
		float distance2 = length(vec2(acos(sqrt(1.0 - pos.x * pos.x)), pos.w)) - .1;
		float distance3 = acos(pos.z) - .1;

		float minDistance = ${getMinGlslString("distance",3)};
	`;distanceEstimatorGlsl=`
		${S2xEAxes.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xEAxes.distances}

		if (minDistance == distance1)
		{
			return vec3(
				1.0,
				.5 + .25 * (.5 * (sin(20.0 * pos.x) + 1.0)),
				.5 + .25 * (.5 * (cos(20.0 * pos.x) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.5 + .25 * (.5 * (sin(20.0 * pos.y) + 1.0)),
				1.0,
				.5 + .25 * (.5 * (cos(20.0 * pos.y) + 1.0))
			);
		}

		return vec3(
			.5 + .25 * (.5 * (sin(5.0 * pos.w) + 1.0)),
			.5 + .25 * (.5 * (cos(5.0 * pos.w) + 1.0)),
			1.0
		);
	`;lightGlsl=`
		vec4 lightDirection1 = vec4(normalize(vec3(2.0, 2.0, -2.0) - pos.xyz), 0.0);
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.5 * dotProduct1;
	`;cameraPos=[-.69965,-.70677,.10463,.61483];normalVec=[.69965,.70676,-.10471,0];upVec=[0,0,0,1];rightVec=[.71092,-.70325,.00345,0];forwardVec=[.0712,.07685,.99449,0]}class S2xERooms extends S2xEGeometry{static distances=`
		float spacing = 1.09;

		float distance1 = wallThickness - length(vec2(acos(pos.x), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float distance2 = wallThickness - length(vec2(acos(-pos.x), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float distance3 = wallThickness - length(vec2(acos(pos.y), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float distance4 = wallThickness - length(vec2(acos(-pos.y), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float distance5 = wallThickness - length(vec2(acos(pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float distance6 = wallThickness - length(vec2(acos(-pos.z), mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));

		float minDistance = ${getMaxGlslString("distance",6)};
	`;distanceEstimatorGlsl=`
		${S2xERooms.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xERooms.distances}

		float wColor = floor((pos.w + spacing / 2.0) / spacing);

		if (minDistance == distance1)
		{
			return vec3(
				.75 + .25 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.z + wColor) * 89.0) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.65 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
				.75 + .25 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.z + wColor) * 89.0) + 1.0))
			);
		}

		if (minDistance == distance3)
		{
			return vec3(
				.65 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
				.75 + .25 * (.5 * (sin((.03 * pos.z + wColor) * 17.0) + 1.0))
			);
		}

		if (minDistance == distance4)
		{
			return vec3(
				.75 + .25 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
				.75 + .25 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.z + wColor) * 17.0) + 1.0))
			);
		}

		if (minDistance == distance5)
		{
			return vec3(
				.75 + .25 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
				.65 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
				.75 + .25 * (.5 * (sin((.03 * pos.z + wColor) * 17.0) + 1.0))
			);
		}

		return vec3(
			.65 * (.5 * (sin((.03 * pos.x + wColor) * 7.0) + 1.0)),
			.75 + .25 * (.5 * (sin((.03 * pos.y + wColor) * 11.0) + 1.0)),
			.75 + .25 * (.5 * (sin((.03 * pos.z + wColor) * 17.0) + 1.0))
		);
	`;lightGlsl=`
		float spacing = 1.09;

		vec4 lightDirection1 = normalize(vec4(2.0, 2.0, 2.0, -2.0) - vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float dotProduct1 = abs(dot(surfaceNormal, lightDirection1));

		float lightIntensity = 1.5 * dotProduct1;
	`;cameraPos=[0,0,-1,0];normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float wallThickness;
	`;uniformNames=["wallThickness"];updateUniforms(gl,uniformList){var s=.9557-this.sliderValues.wallThickness/10;gl.uniform1f(uniformList.wallThickness,s)}uiElementsUsed="#wall-thickness-slider";initUI(){var s=$("#wall-thickness-slider"),o=$("#wall-thickness-slider-value");s.min=-.45,s.max=.8,s.value=.8,o.textContent=.8,this.sliderValues.wallThickness=.8}}class S2xESpheres extends S2xEGeometry{static distances=`
		float distance1 = length(vec2(acos(pos.x), mod(pos.w + .785398, 1.570796) - .785398)) - .3;
		float distance2 = length(vec2(acos(-pos.x), mod(pos.w + .785398, 1.570796) - .785398)) - .3;
		float distance3 = length(vec2(acos(pos.y), mod(pos.w + .785398, 1.570796) - .785398)) - .3;
		float distance4 = length(vec2(acos(-pos.y), mod(pos.w + .785398, 1.570796) - .785398)) - .3;
		float distance5 = length(vec2(acos(pos.z), mod(pos.w + .785398, 1.570796) - .785398)) - .3;

		float minDistance = ${getMinGlslString("distance",5)};
	`;distanceEstimatorGlsl=`
		${S2xESpheres.distances}

		return minDistance;
	`;getColorGlsl=`
		${S2xESpheres.distances}

		float wColor = floor((pos.w + .785398) / 1.570796);

		if (minDistance == distance1)
		{
			return vec3(
				.75 + .25 * (.5 * (sin(wColor * 7.0) + 1.0)),
				.65 * (.5 * (sin(wColor * 11.0) + 1.0)),
				.65 * (.5 * (sin(wColor * 89.0) + 1.0))
			);
		}

		if (minDistance == distance2)
		{
			return vec3(
				.65 * (.5 * (sin(wColor * 7.0) + 1.0)),
				.75 + .25 * (.5 * (sin(wColor * 11.0) + 1.0)),
				.65 * (.5 * (sin(wColor * 89.0) + 1.0))
			);
		}

		if (minDistance == distance3)
		{
			return vec3(
				.65 * (.5 * (sin(wColor * 7.0) + 1.0)),
				.65 * (.5 * (sin(wColor * 11.0) + 1.0)),
				.75 + .25 * (.5 * (sin(wColor * 17.0) + 1.0))
			);
		}

		if (minDistance == distance4)
		{
			return vec3(
				.75 + .25 * (.5 * (sin(wColor * 7.0) + 1.0)),
				.75 + .25 * (.5 * (sin(wColor * 11.0) + 1.0)),
				.65 * (.5 * (sin(wColor * 17.0) + 1.0))
			);
		}

		if (minDistance == distance5)
		{
			return vec3(
				.88 + .12 * (.5 * (sin(wColor * 7.0) + 1.0)),
				.88 + .12 * (.5 * (sin(wColor * 11.0) + 1.0)),
				.88 + .12 * (.5 * (sin(wColor * 17.0) + 1.0))
			);
		}
	`;lightGlsl=`
		// This is very weird, but it fixes an issue where the north and south poles
		// of spheres had dots of incorrect lighting.
		pos.xyz /= 1.001;
		surfaceNormal = getSurfaceNormal(pos);

		float spacing = 1.570796;

		vec4 lightDirection1 = normalize(vec4(0.0, 2.0, 2.0, 2.5) - vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(2.0, 0.0, -2.0, 2.5) - vec4(pos.xyz, mod(pos.w + spacing / 2.0, spacing) - spacing / 2.0));
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		float lightIntensity = 1.3 * max(dotProduct1, dotProduct2);
	`;cameraPos=[0,0,-1,0];normalVec=[0,0,-1,0];upVec=[0,0,0,1];rightVec=[0,1,0,0];forwardVec=[1,0,0,0]}export{S2xEAxes,S2xERooms,S2xESpheres};