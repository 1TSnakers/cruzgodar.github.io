import{sliderValues}from"../index.min.js";import{BaseGeometry}from"./base.min.js";import{$}from"/scripts/src/main.min.js";class SolGeometry extends BaseGeometry{geodesicGlsl=`
		vec4 pos = getUpdatedPos(startPos, rayDirectionVec, t);

		// globalColor += teleportPos(pos, startPos, rayDirectionVec, t, totalT);
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-totalT * 0.2));
	`;functionGlsl=`
		float sinh(float x)
		{
			return .5 * (exp(x) - exp(-x));
		}

		float cosh(float x)
		{
			return .5 * (exp(x) + exp(-x));
		}

		float tanh(float x)
		{
			float expTerm = exp(2.0 * x);

			return (expTerm - 1.0) / (expTerm + 1.0);
		}

		mat4 getTransformationMatrix(vec4 pos)
		{
			return mat4(
				exp(pos.z), 0.0, 0.0, 0.0,
				0.0, exp(-pos.z), 0.0, 0.0,
				0.0, 0.0, 1.0, 0.0,
				pos.x, pos.y, pos.z, 1.0
			);
		}

		vec4 getUpdatedPos(vec4 startPos, vec4 rayDirectionVec, float t)
		{
			mat4 A = getTransformationMatrix(startPos);
		
			float a = abs(rayDirectionVec.x);
			float b = abs(rayDirectionVec.y);
			float c = rayDirectionVec.z;

			vec4 pos;
		
			// All the following formulas get differentiated dt.
			if (a == 0.0)
			{
				float tanhT = tanh(t);

				pos = vec4(
					0.0,
					b * tanhT / (1.0 + c * tanhT),
					log(cosh(t) + c * sinh(t)),
					1.0
				);
			}
		
			else if (b == 0.0)
			{
				float tanhT = tanh(t);

				pos = vec4(
					a * tanhT / (1.0 - c * tanhT),
					0.0,
					-log(cosh(t) - c * sinh(t)),
					1.0
				);
			}
			
			else
			{
				pos = vec4(0.0, 0.0, 0.0, 1.0);
			}

			return pos;
		}
	`;normalize(vec){var e=Math.exp(2*vec[2]),e=Math.sqrt(vec[0]*vec[0]/e+vec[1]*vec[1]*e+vec[2]*vec[2]);return[vec[0]/e,vec[1]/e,vec[2]/e,vec[3]/e]}followGeodesic(pos,dir,t){}getNormalVec(){return[0,0,0,1]}correctVectors(){}}class SolRooms extends SolGeometry{static distances=`
		float radius = wallThickness;
		float distance1 = 0.0;
	`;distanceEstimatorGlsl=`
		${SolRooms.distances}

		float minDistance = distance1;

		return minDistance;
	`;getColorGlsl=`
		// return vec3(
		// 	.35 + .65 * (.5 * (sin((.0125 * pos.x + baseColor.x + globalColor.x + .5) * 40.0) + 1.0)),
		// 	.35 + .65 * (.5 * (sin((.0125 * pos.y + baseColor.y + globalColor.y + .5) * 57.0) + 1.0)),
		// 	.35 + .65 * (.5 * (sin((.0125 * pos.z + baseColor.z + globalColor.z + .5) * 89.0) + 1.0))
		// );

		return vec3(0.5, 0.5, 0.5);
	`;lightGlsl=`
		surfaceNormal.w = 0.0;

		vec4 lightDirection1 = normalize(vec4(3.0, -3.0, 3.0, 1.0) - pos);
		float dotProduct1 = dot(surfaceNormal, lightDirection1);

		vec4 lightDirection2 = normalize(vec4(-4.0, 2.0, -1.0, 1.0) - pos);
		float dotProduct2 = dot(surfaceNormal, lightDirection2);

		vec4 lightDirection3 = normalize(vec4(3.0, 2.0, 0.5, 1.0) - pos);
		float dotProduct3 = .5 * dot(surfaceNormal, lightDirection3);

		float lightIntensity = 1.2 * lightBrightness * max(max(abs(dotProduct1), abs(dotProduct2)), abs(dotProduct3));

		lightIntensity = 1.0;
	`;getMovingSpeed(){return 1}cameraPos=[0,0,0,1];normalVec=[0,0,0,1];upVec=[0,0,1,0];rightVec=[0,1,0,0];forwardVec=[1,0,0,0];uniformGlsl=`
		uniform float wallThickness;
		uniform vec3 baseColor;
	`;uniformNames=["wallThickness","baseColor"];updateUniforms(gl,uniformList){gl.uniform1f(uniformList.wallThickness,.703-sliderValues.wallThickness/10),gl.uniform3fv(uniformList.baseColor,[0,0,0])}uiElementsUsed="#wall-thickness-slider";initUI(){var e=$("#wall-thickness-slider"),o=$("#wall-thickness-slider-value");e.min=-.72,e.max=.78,e.value=.78,o.textContent=.78,sliderValues.wallThickness=.78}}export{SolRooms};