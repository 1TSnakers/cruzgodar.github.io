class BaseGeometry{geodesicGlsl=`
		vec4 pos = startPos + t * rayDirectionVec;
	`;dotProductGlsl=`
		return dot(v, w);
	`;normalizeGlsl=`
		return normalize(dir);
	`;fogGlsl=`
		return mix(color, fogColor, 1.0 - exp(-length(pos - cameraPos) * fogScaling));
	`;updateTGlsl=`
		lastTIncrease = distance * stepFactor;
		
		t += lastTIncrease;
	`;maxMarches="200";ambientOcclusionDenominator="100.0";stepFactor="0.99";dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}normalize(vec){var t=Math.sqrt(this.dotProduct(vec,vec));return[vec[0]/t,vec[1]/t,vec[2]/t,vec[3]/t]}followGeodesic(pos,dir,t){return[pos[0]+t*dir[0],pos[1]+t*dir[1],pos[2]+t*dir[2],pos[3]+t*dir[3]]}teleportCamera(){}getNormalVec(){return[0,0,0,1]}correctPosition(pos){return pos}correctVectors(){var t=this.dotProduct(this.normalVec,this.upVec),r=this.dotProduct(this.normalVec,this.rightVec),e=this.dotProduct(this.normalVec,this.forwardVec);for(let o=0;o<4;o++)this.upVec[o]-=t*this.normalVec[o],this.rightVec[o]-=r*this.normalVec[o],this.forwardVec[o]-=e*this.normalVec[o];this.upVec=this.normalize(this.upVec),this.rightVec=this.normalize(this.rightVec),this.forwardVec=this.normalize(this.forwardVec)}getMovingSpeed(){return 2}distanceEstimatorGlsl;getColorGlsl;lightGlsl;functionGlsl;raymarchSetupGlsl;finalTeleportationGlsl;usesFiberComponent=!1;cameraPos;normalVec;upVec;rightVec;forwardVec;uniformGlsl;uniformNames;uniformData={};updateUniforms(){}initUI(){}uiElementsUsed=""}function getMinGlslString(varName,numVars,functionName="min"){var t=Math.ceil(Math.log2(numVars));let r=new Array(numVars);for(let o=0;o<numVars;o++)r[o]=""+varName+(o+1);for(let a=0;a<t;a++){var e=new Array(Math.ceil(r.length/2));for(let t=0;t<r.length;t+=2)e[t/2]=`${functionName}(${r[t]}, ${r[t+1]})`;r.length%2==1&&(e[e.length-1]=r[r.length-1]),r=e}return r[0]}function getMaxGlslString(varName,numVars){return getMinGlslString(varName,numVars,"max")}function getColorGlslString(varName,minVarName,colors){let t="";for(let r=0;r<colors.length;r++)t+=`if (${minVarName} == ${varName}${r+1}) { return vec3(${colors[r][0]/255}, ${colors[r][1]/255}, ${colors[r][2]/255}); }
		`;return t}function getFloatGlsl(float){return"string"==typeof float||float!==Math.floor(float)?float:`float(${float})`}function getVectorGlsl(vector){return 2===vector.length?`vec2(${vector[0]}, ${vector[1]})`:3===vector.length?`vec3(${vector[0]}, ${vector[1]}, ${vector[2]})`:4===vector.length?`vec4(${vector[0]}, ${vector[1]}, ${vector[2]}, ${vector[3]})`:(console.error("Invalid vector length!"),"")}function getMatrixGlsl(matrix){return 2===matrix.length?`mat2(
			${matrix[0][0]}, ${matrix[1][0]},
			${matrix[0][1]}, ${matrix[1][1]}
		)`:3===matrix.length?`mat3(
			${matrix[0][0]}, ${matrix[1][0]}, ${matrix[2][0]},
			${matrix[0][1]}, ${matrix[1][1]}, ${matrix[2][1]},
			${matrix[0][2]}, ${matrix[1][2]}, ${matrix[2][2]}
		)`:4===matrix.length?`mat4(
			${matrix[0][0]}, ${matrix[1][0]}, ${matrix[2][0]}, ${matrix[3][0]},
			${matrix[0][1]}, ${matrix[1][1]}, ${matrix[2][1]}, ${matrix[3][1]},
			${matrix[0][2]}, ${matrix[1][2]}, ${matrix[2][2]}, ${matrix[3][2]},
			${matrix[0][3]}, ${matrix[1][3]}, ${matrix[2][3]}, ${matrix[3][3]}
		)`:(console.error("Invalid matrix shape!"),"")}export{BaseGeometry,getMinGlslString,getMaxGlslString,getColorGlslString,getFloatGlsl,getVectorGlsl,getMatrixGlsl};