import{hexToRgb,rgbToHex}from"../../../scripts/applets/applet.min.js";import anime from"/scripts/anime.min.js";import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{changeOpacity}from"/scripts/src/animation.min.js";import{siteSettings}from"/scripts/src/settings.min.js";import{WilsonGPU}from"/scripts/wilson.min.js";class NewtonsMethod extends AnimationFrameApplet{wilsonHidden;rootSetterElement;rootAInput;rootBInput;colorSetterElement;colors={root0:[216/255,1/255,42/255],root1:[1,139/255,56/255],root2:[249/255,239/255,20/255],root3:[27/255,181/255,61/255],root4:[0,86/255,195/255],root5:[154/255,82/255,164/255],root6:[32/255,32/255,32/255],root7:[155/255,92/255,15/255]};lastActiveRoot="root0";numRoots=0;numIterations=100;secantProportion=0;pastBrightnessScales=[];resolution=500;resolutionHidden=100;constructor({canvas,rootSetterElement,rootAInput,rootBInput,colorSetterElement}){super(canvas),this.rootSetterElement=rootSetterElement,this.rootAInput=rootAInput,this.rootBInput=rootBInput,this.colorSetterElement=colorSetterElement;var o=this.createHiddenCanvas(),t={shader:`
			precision highp float;
			
			varying vec2 uv;
			
			uniform vec2 worldCenter;
			uniform vec2 worldSize;
			
			uniform int numRoots;
			
			uniform vec2 root0;
			uniform vec2 root1;
			uniform vec2 root2;
			uniform vec2 root3;
			uniform vec2 root4;
			uniform vec2 root5;
			uniform vec2 root6;
			uniform vec2 root7;
			
			uniform vec3 color0;
			uniform vec3 color1;
			uniform vec3 color2;
			uniform vec3 color3;
			uniform vec3 color4;
			uniform vec3 color5;
			uniform vec3 color6;
			uniform vec3 color7;
			
			uniform vec2 a;
			uniform vec2 c;
			
			uniform float brightnessScale;

			uniform float secantProportion;
			
			const float derivativePrecision = 6.0;
			
			const float threshhold = .05;
			
			
			
			//Returns z1 * z2.
			vec2 cmul(vec2 z1, vec2 z2)
			{
				return vec2(z1.x * z2.x - z1.y * z2.y, z1.x * z2.y + z1.y * z2.x);
			}
			
			
			
			//Returns 1/z.
			vec2 cinv(vec2 z)
			{
				float magnitude = z.x*z.x + z.y*z.y;
				
				return vec2(z.x / magnitude, -z.y / magnitude);
			}
			
			
			
			//Returns f(z) for a polynomial f with given roots.
			vec2 cpoly(vec2 z)
			{
				vec2 result = vec2(1.0, 0.0);

				if (numRoots >= 1)
				{
					result = cmul(result, z - root0);
				}

				if (numRoots >= 2)
				{
					result = cmul(result, z - root1);
				}

				if (numRoots >= 3)
				{
					result = cmul(result, z - root2);
				}

				if (numRoots >= 4)
				{
					result = cmul(result, z - root3);
				}

				if (numRoots >= 5)
				{
					result = cmul(result, z - root4);
				}

				if (numRoots >= 6)
				{
					result = cmul(result, z - root5);
				}

				if (numRoots >= 7)
				{
					result = cmul(result, z - root6);
				}

				if (numRoots >= 8)
				{
					result = cmul(result, z - root7);
				}

				return result;
			}
			
			
			
			//Approximates f'(z) for a polynomial f with given roots.
			vec2 cderiv(vec2 z)
			{
				return derivativePrecision * (cpoly(z + vec2(1.0 / (2.0*derivativePrecision), 0.0)) - cpoly(z - vec2(1.0 / (2.0*derivativePrecision), 0.0)));
			}



			void computeColor(
				vec2 lastZ,
				vec2 root,
				vec3 color,
				float d0,
				int iteration
			) {
				float d1 = length(lastZ - root);
				
				float brightnessAdjust = (log(threshhold) - log(d0)) / (log(d1) - log(d0));
				
				float brightness = 1.0 - (float(iteration) - brightnessAdjust) / brightnessScale;
				
				gl_FragColor = vec4(color * brightness, 1.0);
			}
			
			
			
			void main(void)
			{
				vec2 z = uv * worldSize * 0.5 + worldCenter;
				vec2 lastZ = vec2(0.0, 0.0);
				
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
				
				
				
				for (int iteration = 0; iteration < 100; iteration++)
				{
					vec2 temp = mix(
						cmul(cmul(cpoly(z), cinv(cderiv(z))), a) + c,
						cmul(cmul(cpoly(z), cmul(z - lastZ, cinv(cpoly(z) - cpoly(lastZ)))), a) + c,
						secantProportion
					);
					
					lastZ = z;
					
					z -= temp;

					if (numRoots >= 1)
					{
						float d0 = length(z - root0);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root0, color0, d0, iteration);
							return;
						}
					}

					if (numRoots >= 2)
					{
						float d0 = length(z - root1);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root1, color1, d0, iteration);
							return;
						}
					}

					if (numRoots >= 3)
					{
						float d0 = length(z - root2);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root2, color2, d0, iteration);
							return;
						}
					}

					if (numRoots >= 4)
					{
						float d0 = length(z - root3);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root3, color3, d0, iteration);
							return;
						}
					}

					if (numRoots >= 5)
					{
						float d0 = length(z - root4);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root4, color4, d0, iteration);
							return;
						}
					}

					if (numRoots >= 6)
					{
						float d0 = length(z - root5);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root5, color5, d0, iteration);
							return;
						}
					}

					if (numRoots >= 7)
					{
						float d0 = length(z - root6);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root6, color6, d0, iteration);
							return;
						}
					}

					if (numRoots >= 8)
					{
						float d0 = length(z - root7);

						if (d0 < threshhold)
						{
							computeColor(lastZ, root7, color7, d0, iteration);
							return;
						}
					}
				}
			}
		`,uniforms:{worldCenter:[0,0],worldSize:[2,2],numRoots:3,root0:[0,0],root1:[0,0],root2:[0,0],root3:[0,0],root4:[0,0],root5:[0,0],root6:[0,0],root7:[0,0],color0:this.colors.root0,color1:this.colors.root1,color2:this.colors.root2,color3:this.colors.root3,color4:this.colors.root4,color5:this.colors.root5,color6:this.colors.root6,color7:this.colors.root7,a:[1,0],c:[0,0],brightnessScale:this.brightnessScale,secantProportion:this.secantProportion},canvasWidth:this.resolution,worldWidth:4,worldHeight:4,worldCenterX:0,worldCenterY:0,minWorldWidth:1e-5,maxWorldWidth:40,minWorldHeight:1e-5,maxWorldHeight:40,onResizeCanvas:this.drawFrame.bind(this),reduceMotion:siteSettings.reduceMotion,interactionOptions:{useForPanAndZoom:!0,onPanAndZoom:this.drawFrame.bind(this)},draggableOptions:{draggables:{a:[1,0],c:[0,0],root0:[0,0],root1:[0,0],root2:[0,0],root3:[0,0],root4:[0,0],root5:[0,0],root6:[0,0],root7:[0,0]},callbacks:{onrelease:this.onReleaseDraggable.bind(this)}},fullscreenOptions:{fillScreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}};this.wilson=new WilsonGPU(canvas,t),this.wilsonHidden=new WilsonGPU(o,{...t,canvasWidth:this.resolutionHidden});for(let e=3;e<8;e++)this.wilson.draggables["root"+e].element.style.display="none";this.spreadRoots(!0),this.resume()}switchMethod(instant){const o={t:this.secantProportion};var t=0===this.secantProportion?1:0;anime({targets:o,t:t,duration:instant?10:1e3,easing:"easeInOutQuad",update:()=>{this.secantProportion=o.t,this.needNewFrame=!0}})}addRoot(){var o,t;8!==this.numRoots&&(o=3*Math.random()-1.5,t=3*Math.random()-1.5,this.wilson.setDraggablePosition({id:"root"+this.numRoots,location:[o,t]}),this.wilson.draggables["root"+this.numRoots].element.style.display="block",this.numRoots++,this.wilson.setUniform({name:"root"+this.numRoots,value:this.draggables["root"+this.numRoots].worldCoordinates}),this.wilson.setUniform({name:"numRoots",value:this.numRoots}),this.needNewFrame=!0)}removeRoot(){1!==this.numRoots&&(this.numRoots--,this.wilson.draggables["root"+this.numRoots].element.style.display="none",this.wilson.setUniform({name:"numRoots",value:this.numRoots}),this.needNewFrame=!0)}spreadRoots(noAnimation=!1,randomize=!1){const r=Object.fromEntries(Object.entries(this.wilson.draggables).map(([id,draggable])=>[id,draggable.location])),i={};for(let t=0;t<8;t++){var o=1+.75*randomize*Math.random();i["root"+t]=[o*Math.cos(2*Math.PI*t/this.numRoots),o*Math.sin(2*Math.PI*t/this.numRoots)]}const s={t:0};anime({targets:s,t:1,duration:noAnimation?10:1e3,easing:"easeInOutQuad",update:()=>{for(const e of Object.keys(i)){var o=r[e],t=i[e],o=[(1-s.t)*o+s.t*t,(1-s.t)*o+s.t*t];this.wilson.setDraggablePosition({id:e,location:o})}this.needNewFrame=!0}})}setRoot(x,y){this.wilson.setDraggablePosition({id:this.lastActiveRoot,location:[x,y]}),this.needNewFrame=!0}setColor(hex){if(this.lastActiveRoot in this.colors){const i=hexToRgb(hex);var o=i.r/255,t=i.g/255,e=i.b/255,r=(i.r=this.colors[this.lastActiveRoot][0],i.g=this.colors[this.lastActiveRoot][1],i.b=this.colors[this.lastActiveRoot][2],this.lastActiveRoot.slice(4));const s="color"+r;anime({targets:i,r:o,g:t,b:e,easing:"easeInOutQuad",duration:250,update:()=>{this.colors[this.lastActiveRoot][0]=i.r,this.colors[this.lastActiveRoot][1]=i.g,this.colors[this.lastActiveRoot][2]=i.b,this.wilson.setUniform({name:s,value:this.colors[this.lastActiveRoot]}),this.wilsonHidden.setUniform({name:s,value:this.colors[this.lastActiveRoot]}),this.needNewFrame=!0}})}}async onReleaseDraggable({id}){var o;this.lastActiveRoot=id,this.rootSetterElement&&this.colorSetterElement&&(await Promise.all([changeOpacity({element:this.rootSetterElement,opacity:0}),changeOpacity({element:this.colorSetterElement,opacity:0})]),this.rootAInput.setValue(Math.round(1e3*this.wilson.draggables[this.lastActiveRoot].location[0])/1e3,!1),this.rootBInput.setValue(Math.round(1e3*this.wilson.draggables[this.lastActiveRoot].location[1])/1e3,!1),this.lastActiveRoot in this.colors&&(o=this.colors[this.lastActiveRoot],this.colorSetterElement.value=rgbToHex(255*o[0],255*o[1],255*o[2])),changeOpacity({element:this.rootSetterElement,opacity:1}),changeOpacity({element:this.colorSetterElement,opacity:1}))}drawFrame(){this.wilson.setUniform({name:"worldSize",value:[this.wilson.worldWidth,this.wilson.worldHeight]}),this.wilson.setUniform({name:"worldCenter",value:[this.wilson.worldCenterX,this.wilson.worldCenterY]}),this.wilson.drawFrame()}}export{NewtonsMethod};