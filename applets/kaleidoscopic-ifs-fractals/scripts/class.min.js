import{getVectorGlsl}from"/scripts/applets/applet.min.js";import{dotProduct,mat3TimesVector,RaymarchApplet}from"/scripts/applets/raymarchApplet.min.js";import{changeOpacity}from"/scripts/src/animation.min.js";import{clamp}from"/scripts/src/utils.min.js";const ns={tetrahedron:[[-.57735,0,.816496],[.288675,-.5,.816496],[.288675,.5,.816496]],cube:[[1,0,0],[0,1,0],[0,0,1]],octahedron:[[.707107,0,.707107],[0,.707107,.707107],[-.707107,0,.707107],[0,-.707107,.707107]],dodecahedron:[[.809016,-.5,.309017],[.309017,.809016,-.5],[-.5,.309017,.809016],[.809016,-.5,.309017],[.309017,.809016,-.5],[-.5,.309017,.809016],[.809016,-.5,.309017]],icosahedron:[[0,1,0],[-.5,-.309017,.809016],[.5,-.309017,.809016],[-.809016,.5,.309017],[.809016,.5,.309017],[0,1,0]]},scaleCenters={tetrahedron:[0,0,1],cube:[.57735,.57735,.57735],octahedron:[0,0,1],dodecahedron:[.57735,.57735,.57735],icosahedron:[0,.525731,.850651]};function getDistanceEstimatorGlsl(shape,useForGetColor=!1){const t=shape.charAt(0).toUpperCase()+shape.slice(1);var e=ns[shape].length;return`
		${useForGetColor?"vec3 color = vec3(1.0, 1.0, 1.0); float colorScale = .5;":""}
		//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.
		for (int iteration = 0; iteration < 72; iteration++)
		{
			if (iteration >= numIterations)
			{
				break;
			}

			${Array(e).fill(0).map((_,i)=>`
			float t${i} = dot(pos, n${i}${t});
			
			if (t${i} < 0.0)
			{
				pos -= 2.0 * t${i} * n${i}${t};
			}
		`).join("\n")}
			
			//Scale the system -- this one takes me a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.
			pos = scale * pos - (scale - 1.0) * scaleCenter${t};
			
			pos = rotationMatrix * pos;

			${useForGetColor?"float r = length(pos); color = mix(color, abs(pos.yxz / r), colorScale); colorScale *= .2;":""}
		}
		
		return ${useForGetColor?"color":"length(pos) * pow(1.0 / scale, float(numIterations))"};
	`}class KaleidoscopicIFSFractals extends RaymarchApplet{shape="octahedron";constructor({canvas,shape="octahedron"}){var t=[];for(const a in ns){const o=a.charAt(0).toUpperCase()+a.slice(1);var e=Array(ns[a].length).fill(0).map((_,i)=>`
					const vec3 n${i}${o} = ${getVectorGlsl(ns[a][i])};
				`).join("\n")+`
				const vec3 scaleCenter${o} = ${getVectorGlsl(scaleCenters[a])};
			`;t.push(e)}var s=t.join("\n");super({canvas:canvas,distanceEstimatorGlsl:getDistanceEstimatorGlsl(shape),getColorGlsl:getDistanceEstimatorGlsl(shape,!0),uniformsGlsl:`
			uniform float scale;
			uniform mat3 rotationMatrix;
			uniform int numIterations;
		`,addGlsl:s,uniforms:{scale:2,rotationMatrix:[[1,0,0],[0,1,0],[0,0,1]],numIterations:12},theta:.2004,phi:1.6538,cameraPos:[-2.03816,-.526988,.30503],lightPos:[-50,-70,100],lightBrightness:1.25,epsilonScaling:.75,stepFactor:.6}),this.shape=shape}drawFrame(){super.drawFrame();var t=this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),e=2*(1/(this.uniforms.scale-1)-1)/7,t=clamp(Math.floor(14-2*Math.log(t)),14,24)+Math.round(28*e);this.uniforms.numIterations!==t&&this.setUniforms({numIterations:t})}distanceEstimator(x,y,z){var e=ns[this.shape??"octahedron"],s=scaleCenters[this.shape??"octahedron"];for(let t=0;t<this.uniforms.numIterations;t++){for(let t=0;t<e.length;t++){var a=dotProduct([x,y,z],e[t]);a<0&&(x-=2*a*e[t][0],y-=2*a*e[t][1],z-=2*a*e[t][2])}x=this.uniforms.scale*x-(this.uniforms.scale-1)*s[0],y=this.uniforms.scale*y-(this.uniforms.scale-1)*s[1],z=this.uniforms.scale*z-(this.uniforms.scale-1)*s[2],[x,y,z]=mat3TimesVector(this.uniforms.rotationMatrix,[x,y,z])}return Math.sqrt(x*x+y*y+z*z)*Math.pow(this.uniforms.scale,-this.uniforms.numIterations)}async changePolyhedron(newShape){await changeOpacity({element:this.canvas,opacity:0}),this.shape=newShape;var t=getDistanceEstimatorGlsl(this.shape),e=getDistanceEstimatorGlsl(this.shape,!0);this.reloadShader({distanceEstimatorGlsl:t,getColorGlsl:e}),await changeOpacity({element:this.canvas,opacity:1})}}export{KaleidoscopicIFSFractals};