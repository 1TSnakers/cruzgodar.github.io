!function(){"use strict";let t={renderer:"gpu",shader:"\n\t\tprecision highp float;\n\t\t\n\t\tvarying vec2 uv;\n\t\t\n\t\tuniform float aspect_ratio_x;\n\t\tuniform float aspect_ratio_y;\n\t\t\n\t\tuniform vec3 camera_pos;\n\t\tuniform vec3 image_plane_center_pos;\n\t\tuniform vec3 forward_vec;\n\t\tuniform vec3 right_vec;\n\t\tuniform vec3 up_vec;\n\t\t\n\t\tuniform float focal_length;\n\t\t\n\t\tuniform vec3 light_pos;\n\t\tconst float light_brightness = 2.0;\n\t\t\n\t\tuniform int image_size;\n\t\t\n\t\t\n\t\t\n\t\tconst float clip_distance = 1000.0;\n\t\tconst int max_marches = 32;\n\t\tconst vec3 fog_color = vec3(0.0, 0.0, 0.0);\n\t\tconst float fog_scaling = .2;\n\t\tconst int max_iterations = 24;\n\t\t\n\t\t\n\t\t\n\t\tconst vec3 color_1 = vec3(1.0, 0.0, 0.0);\n\t\tconst vec3 color_2 = vec3(0.0, 1.0, 0.0);\n\t\tconst vec3 color_3 = vec3(0.0, 0.0, 1.0);\n\t\tconst vec3 color_4 = vec3(1.0, 1.0, 0.0);\n\t\t\n\t\t\n\t\t\n\t\tuniform vec3 scale_center;\n\t\t\n\t\tuniform int num_ns;\n\t\t\n\t\tuniform vec3 n1;\n\t\tuniform vec3 n2;\n\t\tuniform vec3 n3;\n\t\tuniform vec3 n4;\n\t\t\n\t\t\n\t\t\n\t\tconst float scale = 2.0;\n\t\t\n\t\t\n\t\t\n\t\tuniform mat3 rotation_matrix_1;\n\t\tuniform mat3 rotation_matrix_2;\n\t\t\n\t\t\n\t\t\n\t\tfloat distance_estimator(vec3 pos)\n\t\t{\n\t\t\tvec3 mutable_pos = pos;\n\t\t\t\n\t\t\t//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.\n\t\t\tfor (int iteration = 0; iteration < max_iterations; iteration++)\n\t\t\t{\n\t\t\t\t//Fold space over on itself so that we can reference only the top vertex.\n\t\t\t\tfloat t1 = dot(mutable_pos, n1);\n\t\t\t\t\n\t\t\t\tif (t1 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t1 * n1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t2 = dot(mutable_pos, n2);\n\t\t\t\t\n\t\t\t\tif (t2 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t2 * n2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t3 = dot(mutable_pos, n3);\n\t\t\t\t\n\t\t\t\tif (t3 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t3 * n3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (num_ns >= 4)\n\t\t\t\t{\n\t\t\t\t\tfloat t4 = dot(mutable_pos, n4);\n\t\t\t\t\t\n\t\t\t\t\tif (t4 < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmutable_pos -= 2.0 * t4 * n4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_1 * mutable_pos;\n\t\t\t\t\n\t\t\t\t//Scale the system -- this one takes me a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.\n\t\t\t\tmutable_pos = scale * mutable_pos - (scale - 1.0) * scale_center;\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_2 * mutable_pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn length(mutable_pos) * pow(1.0/scale, float(max_iterations));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_color(vec3 pos)\n\t\t{\n\t\t\tvec3 mutable_pos = pos;\n\t\t\t\n\t\t\tvec3 color = vec3(1.0, 1.0, 1.0);\n\t\t\tfloat color_scale = .5;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.\n\t\t\tfor (int iteration = 0; iteration < max_iterations; iteration++)\n\t\t\t{\n\t\t\t\t//Fold space over on itself so that we can reference only the top vertex.\n\t\t\t\tfloat t1 = dot(mutable_pos, n1);\n\t\t\t\t\n\t\t\t\tif (t1 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t1 * n1;\n\t\t\t\t\t\n\t\t\t\t\tcolor = mix(color, color_1, color_scale);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t2 = dot(mutable_pos, n2);\n\t\t\t\t\n\t\t\t\tif (t2 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t2 * n2;\n\t\t\t\t\t\n\t\t\t\t\tcolor = mix(color, color_2, color_scale);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t3 = dot(mutable_pos, n3);\n\t\t\t\t\n\t\t\t\tif (t3 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t3 * n3;\n\t\t\t\t\t\n\t\t\t\t\tcolor = mix(color, color_3, color_scale);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (num_ns >= 4)\n\t\t\t\t{\n\t\t\t\t\tfloat t4 = dot(mutable_pos, n4);\n\t\t\t\t\t\n\t\t\t\t\tif (t4 < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmutable_pos -= 2.0 * t4 * n4;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcolor = mix(color, color_4, color_scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_1 * mutable_pos;\n\t\t\t\t\n\t\t\t\t//Scale the system -- this one takes me a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.\n\t\t\t\tmutable_pos = scale * mutable_pos - (scale - 1.0) * scale_center;\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_2 * mutable_pos;\n\t\t\t\t\n\t\t\t\tcolor_scale *= .5;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_surface_normal(vec3 pos)\n\t\t{\n\t\t\tfloat x_step_1 = distance_estimator(pos + vec3(.000001, 0.0, 0.0));\n\t\t\tfloat y_step_1 = distance_estimator(pos + vec3(0.0, .000001, 0.0));\n\t\t\tfloat z_step_1 = distance_estimator(pos + vec3(0.0, 0.0, .000001));\n\t\t\t\n\t\t\tfloat x_step_2 = distance_estimator(pos - vec3(.000001, 0.0, 0.0));\n\t\t\tfloat y_step_2 = distance_estimator(pos - vec3(0.0, .000001, 0.0));\n\t\t\tfloat z_step_2 = distance_estimator(pos - vec3(0.0, 0.0, .000001));\n\t\t\t\n\t\t\treturn normalize(vec3(x_step_1 - x_step_2, y_step_1 - y_step_2, z_step_1 - z_step_2));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 compute_shading(vec3 pos, int iteration)\n\t\t{\n\t\t\tvec3 surface_normal = get_surface_normal(pos);\n\t\t\t\n\t\t\tvec3 light_direction = normalize(light_pos - pos);\n\t\t\t\n\t\t\tfloat dot_product = dot(surface_normal, light_direction);\n\t\t\t\n\t\t\tfloat light_intensity = light_brightness * max(dot_product, -.25 * dot_product);\n\t\t\t\n\t\t\t//The last factor adds ambient occlusion.\n\t\t\tvec3 color = get_color(pos) * light_intensity * max((1.0 - float(iteration) / float(max_marches)), 0.0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Apply fog.\n\t\t\treturn mix(color, fog_color, 1.0 - exp(-distance(pos, camera_pos) * fog_scaling));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 raymarch(vec3 start_pos)\n\t\t{\n\t\t\t//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.\n\t\t\tvec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\n\t\t\tvec3 final_color = fog_color;\n\t\t\t\n\t\t\tfloat epsilon = .0000001;\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < max_marches; iteration++)\n\t\t\t{\n\t\t\t\tvec3 pos = start_pos + t * ray_direction_vec;\n\t\t\t\t\n\t\t\t\tfloat distance = distance_estimator(pos);\n\t\t\t\t\n\t\t\t\t//This lowers the detail far away, which makes everything run nice and fast.\n\t\t\t\tepsilon = max(.0000006, 3.0 * t / float(image_size));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (distance < epsilon)\n\t\t\t\t{\n\t\t\t\t\tfinal_color = compute_shading(pos, iteration);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (t > clip_distance)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt += distance;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn final_color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\t//Uncomment to use 2x antialiasing.\n\t\t\t//vec3 final_color = (raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio + .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y + .5 / float(image_size))) + raymarch(image_plane_center_pos + right_vec * (uv.x * aspect_ratio - .5 / float(image_size)) + up_vec * (uv.y - .5 / float(image_size)))) / 4.0;\n\t\t\t\t\n\t\t\tvec3 final_color = raymarch(image_plane_center_pos + right_vec * uv.x * aspect_ratio_x + up_vec * uv.y / aspect_ratio_y);\n\t\t\t\n\t\t\tgl_FragColor = vec4(final_color.xyz, 1.0);\n\t\t}\n\t",canvas_width:500,canvas_height:500,use_fullscreen:!0,true_fullscreen:!0,use_fullscreen_button:!0,enter_fullscreen_button_icon_path:"/graphics/general-icons/enter-fullscreen.png",exit_fullscreen_button_icon_path:"/graphics/general-icons/exit-fullscreen.png",switch_fullscreen_callback:It,mousedown_callback:bt,touchstart_callback:bt,mousedrag_callback:kt,touchmove_callback:kt,mouseup_callback:Pt,touchend_callback:Pt},n=new Wilson(Page.element.querySelector("#output-canvas"),t);n.render.init_uniforms(["aspect_ratio_x","aspect_ratio_y","image_size","camera_pos","image_plane_center_pos","forward_vec","right_vec","up_vec","focal_length","light_pos","scale_center","n1","n2","n3","n4","num_ns","rotation_matrix_1","rotation_matrix_2"]);let e=!1,o=!1,a=!1,r=!1,i=!1,s=!1,c=!1,l=!1,u=0,m=[0,0,0],_=[0,0,0];const f=.94,h=5e-4;let p=1,v=-1,g=3.2954,d=1.9657,y=0,M=0,x=0,w=0;const b=.94,k=.005,P=5e-4;let z=500,q=500,I=500,F=24;const C=2;let S=[],L=[],E=[],A=[],T=[2.1089,.41345,.95325],N=0,W=2,U=[[0,0,5],[5,5,5],[0,0,5]],j=[[-.57735,0,.816496],[1,0,0],[.707107,0,.707107]],B=[[.288675,-.5,.816496],[0,1,0],[0,.707107,.707107]],D=[[.288675,.5,.816496],[0,0,1],[-.707107,0,.707107]],G=[[],[],[0,-.707107,.707107]],H=[3,3,4],J=[[0,0,1],[.57735,.57735,.57735],[0,0,1]],K=0,O=0,Q=0,R=0,V=0,X=0,Y=0,Z=0,$=0,tt=0,nt=0,et=0,ot=0,at=0,rt=0,it=0,st=0,ct=0,lt=0,ut=Page.element.querySelector("#resolution-input");ut.addEventListener("input",It),Page.element.querySelector("#download-button").addEventListener("click",()=>{n.download_frame("a-kaleidoscopic-ifs-fractal.png")});let mt=Page.element.querySelector("#polyhedron-selector-dropdown");mt.addEventListener("input",()=>{"tetrahedron"===mt.value?St(0):"cube"===mt.value?St(1):St(2)});let _t=Page.element.querySelector("#rotation-angle-x-1-input"),ft=Page.element.querySelector("#rotation-angle-y-1-input"),ht=Page.element.querySelector("#rotation-angle-z-1-input"),pt=Page.element.querySelector("#rotation-angle-x-2-input"),vt=Page.element.querySelector("#rotation-angle-y-2-input"),gt=Page.element.querySelector("#rotation-angle-z-2-input"),dt=[_t,ft,ht,pt,vt,gt];for(let t=0;t<6;t++)dt[t].addEventListener("input",Ft);function yt(t){let l=t-v;if(v=t,0===l)return;n.render.draw_frame();let k=!1;e&&(!function(){let t=.5*Math.sin(Math.PI*lt/120-Math.PI/2)+.5;K=Y+ot*t,O=Z+at*t,Q=$+rt*t,R=tt+it*t,V=nt+st*t,X=et+ct*t;let o=[[Math.cos(Q),-Math.sin(Q),0],[Math.sin(Q),Math.cos(Q),0],[0,0,1]],a=[[Math.cos(O),0,-Math.sin(O)],[0,1,0],[Math.sin(O),0,Math.cos(O)]],r=[[1,0,0],[0,Math.cos(K),-Math.sin(K)],[0,Math.sin(K),Math.cos(K)]],i=wt(wt(o,a),r);n.gl.uniformMatrix3fv(n.uniforms.rotation_matrix_1,!1,[i[0][0],i[1][0],i[2][0],i[0][1],i[1][1],i[2][1],i[0][2],i[1][2],i[2][2]]),o=[[Math.cos(X),-Math.sin(X),0],[Math.sin(X),Math.cos(X),0],[0,0,1]],a=[[Math.cos(V),0,-Math.sin(V)],[0,1,0],[Math.sin(V),0,Math.cos(V)]],r=[[1,0,0],[0,Math.cos(R),-Math.sin(R)],[0,Math.sin(R),Math.cos(R)]],i=wt(wt(o,a),r),n.gl.uniformMatrix3fv(n.uniforms.rotation_matrix_2,!1,[i[0][0],i[1][0],i[2][0],i[0][1],i[1][1],i[2][1],i[0][2],i[1][2],i[2][2]]),121==++lt&&(e=!1)}(),k=!0),o||a||r||i||s||c?(!function(){u=Math.min(Math.max(1e-6,p/20),.02);let t=[...T];o||s?(T[0]+=u*L[0],T[1]+=u*L[1],T[2]+=u*L[2]):(a||c)&&(T[0]-=u*L[0],T[1]-=u*L[1],T[2]-=u*L[2]);r?(T[0]+=u*E[0]/W,T[1]+=u*E[1]/W,T[2]+=u*E[2]/W):i&&(T[0]-=u*E[0]/W,T[1]-=u*E[1]/W,T[2]-=u*E[2]/W);m[0]=T[0]-t[0],m[1]=T[1]-t[1],m[2]=T[2]-t[2],Mt()}(),k=!0):l>=50&&(y=0,M=0,x=0,w=0,s=!1,c=!1,_[0]=0,_[1]=0,_[2]=0,m[0]=0,m[1]=0,m[2]=0),0===x&&0===w||(d+=w,(g+=x)>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),d>Math.PI-.01?d=Math.PI-.01:d<.01&&(d=.01),x*=b,w*=b,Math.sqrt(x*x+w*w)<P&&(x=0,w=0),Mt(),k=!0),0===_[0]&&0===_[1]&&0===_[2]||(T[0]+=_[0],T[1]+=_[1],T[2]+=_[2],_[0]*=f,_[1]*=f,_[2]*=f,Math.sqrt(_[0]*_[0]+_[1]*_[1]+_[2]*_[2])<h*u&&(_[0]=0,_[1]=0,_[2]=0),Mt(),k=!0),k&&window.requestAnimationFrame(yt)}function Mt(){var t,e;L=[Math.cos(g)*Math.sin(d),Math.sin(g)*Math.sin(d),Math.cos(d)],E=function(t){let n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/n,t[1]/n,t[2]/n]}([L[1],-L[0],0]),e=L,A=[(t=E)[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]],p=function(t,n,e){for(let o=0;o<F;o++){let o=xt([t,n,e],j[N]);o<0&&(t-=2*o*j[N][0],n-=2*o*j[N][1],e-=2*o*j[N][2]);let a=xt([t,n,e],B[N]);a<0&&(t-=2*a*B[N][0],n-=2*a*B[N][1],e-=2*a*B[N][2]);let r=xt([t,n,e],D[N]);if(r<0&&(t-=2*r*D[N][0],n-=2*r*D[N][1],e-=2*r*D[N][2]),H[N]>=4){let o=xt([t,n,e],G[N]);o<0&&(t-=2*o*G[N][0],n-=2*o*G[N][1],e-=2*o*G[N][2])}let i=t,s=n,c=e,l=[[Math.cos(Q),-Math.sin(Q),0],[Math.sin(Q),Math.cos(Q),0],[0,0,1]],u=[[Math.cos(O),0,-Math.sin(O)],[0,1,0],[Math.sin(O),0,Math.cos(O)]],m=[[1,0,0],[0,Math.cos(K),-Math.sin(K)],[0,Math.sin(K),Math.cos(K)]],_=wt(wt(l,u),m);t=_[0][0]*i+_[0][1]*s+_[0][2]*c,n=_[1][0]*i+_[1][1]*s+_[1][2]*c,e=_[2][0]*i+_[2][1]*s+_[2][2]*c,t=C*t-(C-1)*J[N][0],n=C*n-(C-1)*J[N][1],e=C*e-(C-1)*J[N][2],i=t,s=n,c=e,l=[[Math.cos(X),-Math.sin(X),0],[Math.sin(X),Math.cos(X),0],[0,0,1]],u=[[Math.cos(V),0,-Math.sin(V)],[0,1,0],[Math.sin(V),0,Math.cos(V)]],m=[[1,0,0],[0,Math.cos(R),-Math.sin(R)],[0,Math.sin(R),Math.cos(R)]],_=wt(wt(l,u),m),t=_[0][0]*i+_[0][1]*s+_[0][2]*c,n=_[1][0]*i+_[1][1]*s+_[1][2]*c,e=_[2][0]*i+_[2][1]*s+_[2][2]*c}return Math.sqrt(t*t+n*n+e*e)*Math.pow(C,-F)}(T[0],T[1],T[2]),W=p/2,E[0]*=W/2,E[1]*=W/2,A[0]*=W/2,A[1]*=W/2,A[2]*=W/2,S=[T[0]+W*L[0],T[1]+W*L[1],T[2]+W*L[2]],n.gl.uniform3fv(n.uniforms.camera_pos,T),n.gl.uniform3fv(n.uniforms.image_plane_center_pos,S),n.gl.uniform3fv(n.uniforms.forward_vec,L),n.gl.uniform3fv(n.uniforms.right_vec,E),n.gl.uniform3fv(n.uniforms.up_vec,A),n.gl.uniform1f(n.uniforms.focal_length,W)}function xt(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function wt(t,n){return[[t[0][0]*n[0][0]+t[0][1]*n[1][0]+t[0][2]*n[2][0],t[0][0]*n[0][1]+t[0][1]*n[1][1]+t[0][2]*n[2][1],t[0][0]*n[0][2]+t[0][1]*n[1][2]+t[0][2]*n[2][2]],[t[1][0]*n[0][0]+t[1][1]*n[1][0]+t[1][2]*n[2][0],t[1][0]*n[0][1]+t[1][1]*n[1][1]+t[1][2]*n[2][1],t[1][0]*n[0][2]+t[1][1]*n[1][2]+t[1][2]*n[2][2]],[t[2][0]*n[0][0]+t[2][1]*n[1][0]+t[2][2]*n[2][0],t[2][0]*n[0][1]+t[2][1]*n[1][1]+t[2][2]*n[2][1],t[2][0]*n[0][2]+t[2][1]*n[1][2]+t[2][2]*n[2][2]]]}function bt(t,n,e){y=0,M=0,x=0,w=0,"touchstart"===e.type&&(2===e.touches.length?(s=!0,c=!1,_[0]=0,_[1]=0,_[2]=0,m[0]=0,m[1]=0,m[2]=0,window.requestAnimationFrame(yt)):3===e.touches.length?(s=!1,c=!0,_[0]=0,_[1]=0,_[2]=0,m[0]=0,m[1]=0,m[2]=0,window.requestAnimationFrame(yt)):(s=!1,c=!1),l=!1)}function kt(t,n,e,o,a){"touchmove"===a.type&&l?l=!1:(g+=e*Math.PI/2,y=e*Math.PI/2,g>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),d+=o*Math.PI/2,M=o*Math.PI/2,d>Math.PI-.01?d=Math.PI-.01:d<.01&&(d=.01),Mt(),window.requestAnimationFrame(yt))}function Pt(t,n,e){"touchend"===e.type&&(s=!1,c=!1,l=!0,0===_[0]&&0===_[1]&&0===_[2]&&(_[0]=m[0],_[1]=m[1],_[2]=m[2],m[0]=0,m[1]=0,m[2]=0)),"touchend"===e.type&&e.touches,(0===length||"mouseup"===e.type)&&Math.sqrt(y*y+M*M)>=k&&(x=y,w=M)}function zt(t){"INPUT"===document.activeElement.tagName||87!==t.keyCode&&83!==t.keyCode&&68!==t.keyCode&&65!==t.keyCode||(m=[0,0,0],_=[0,0,0],87===t.keyCode?o=!0:83===t.keyCode&&(a=!0),68===t.keyCode?r=!0:65===t.keyCode&&(i=!0),window.requestAnimationFrame(yt))}function qt(t){"INPUT"===document.activeElement.tagName||87!==t.keyCode&&83!==t.keyCode&&68!==t.keyCode&&65!==t.keyCode||(0===_[0]&&0===_[1]&&0===_[2]&&(_[0]=m[0],_[1]=m[1],_[2]=m[2],m[0]=0,m[1]=0,m[2]=0),87===t.keyCode?o=!1:83===t.keyCode&&(a=!1),68===t.keyCode?r=!1:65===t.keyCode&&(i=!1))}function It(){z=Math.max(100,parseInt(ut.value||500)),n.fullscreen.currently_fullscreen?Page.Layout.aspect_ratio>=1?(q=z,I=Math.floor(z/Page.Layout.aspect_ratio)):(q=Math.floor(z*Page.Layout.aspect_ratio),I=z):(q=z,I=z),n.change_canvas_size(q,I),q>=I?(n.gl.uniform1f(n.uniforms.aspect_ratio_x,q/I),n.gl.uniform1f(n.uniforms.aspect_ratio_y,1)):(n.gl.uniform1f(n.uniforms.aspect_ratio_x,1),n.gl.uniform1f(n.uniforms.aspect_ratio_y,q/I)),n.gl.uniform1i(n.uniforms.image_size,z),window.requestAnimationFrame(yt)}function Ft(){Y=K,Z=O,$=Q,tt=R,nt=V,et=X,ot=(parseFloat(_t.value||0)||0)-Y,at=(parseFloat(ft.value||0)||0)-Z,rt=(parseFloat(ht.value||0)||0)-$,it=(parseFloat(pt.value||0)||0)-tt,st=(parseFloat(vt.value||0)||0)-nt,ct=(parseFloat(gt.value||0)||0)-et,Ct()}function Ct(){e||(e=!0,lt=0,window.requestAnimationFrame(yt))}function St(t){n.canvas.classList.add("animated-opacity"),n.canvas.style.opacity=0,setTimeout(()=>{N=t,n.gl.uniform3fv(n.uniforms.light_pos,U[N]),n.gl.uniform3fv(n.uniforms.scale_center,J[N]),n.gl.uniform3fv(n.uniforms.n1,j[N]),n.gl.uniform3fv(n.uniforms.n2,B[N]),n.gl.uniform3fv(n.uniforms.n3,D[N]),n.gl.uniform3fv(n.uniforms.n4,G[N]),n.gl.uniform1i(n.uniforms.num_ns,H[N]),window.requestAnimationFrame(yt),n.canvas.style.opacity=1,setTimeout(()=>{n.canvas.classList.remove("animated-opacity")})},Site.opacity_animation_time)}Page.element.querySelector("#randomize-parameters-button").addEventListener("click",function(t=!0){if(e)return;Y=K,Z=O,$=Q,tt=R,nt=V,et=X,ot=.375*Math.random()-.1875-Y,at=.375*Math.random()-.1875-Z,rt=.75*Math.random()-.375-$,it=.375*Math.random()-.1875-tt,st=.375*Math.random()-.1875-nt,ct=.75*Math.random()-.375-et,_t.value=Math.round(1e6*(Y+ot))/1e6,ft.value=Math.round(1e6*(Z+at))/1e6,ht.value=Math.round(1e6*($+rt))/1e6,pt.value=Math.round(1e6*(tt+it))/1e6,vt.value=Math.round(1e6*(nt+st))/1e6,gt.value=Math.round(1e6*(et+ct))/1e6,t?Ct():(K=Y+ot,O=Z+at,Q=$+rt,R=tt+it,V=nt+st,X=et+ct)}),Mt(),q>=I?(n.gl.uniform1f(n.uniforms.aspect_ratio_x,q/I),n.gl.uniform1f(n.uniforms.aspect_ratio_y,1)):(n.gl.uniform1f(n.uniforms.aspect_ratio_x,1),n.gl.uniform1f(n.uniforms.aspect_ratio_y,q/I)),n.gl.uniform1i(n.uniforms.image_size,z),n.gl.uniform3fv(n.uniforms.camera_pos,T),n.gl.uniform3fv(n.uniforms.image_plane_center_pos,S),n.gl.uniform3fv(n.uniforms.light_pos,U[N]),n.gl.uniform3fv(n.uniforms.scale_center,J[N]),n.gl.uniform3fv(n.uniforms.forward_vec,L),n.gl.uniform3fv(n.uniforms.right_vec,E),n.gl.uniform3fv(n.uniforms.up_vec,A),n.gl.uniform1f(n.uniforms.focal_length,W),n.gl.uniform3fv(n.uniforms.n1,j[N]),n.gl.uniform3fv(n.uniforms.n2,B[N]),n.gl.uniform3fv(n.uniforms.n3,D[N]),n.gl.uniform3fv(n.uniforms.n4,G[N]),n.gl.uniform1i(n.uniforms.num_ns,H[N]),n.gl.uniformMatrix3fv(n.uniforms.rotation_matrix_1,!1,[1,0,0,0,1,0,0,0,1]),n.gl.uniformMatrix3fv(n.uniforms.rotation_matrix_2,!1,[1,0,0,0,1,0,0,0,1]),window.requestAnimationFrame(yt),Page.show(),document.documentElement.addEventListener("keydown",zt),Page.temporary_handlers.keydown.push(zt),document.documentElement.addEventListener("keyup",qt),Page.temporary_handlers.keydown.push(qt)}();