!function(){"use strict";let t=document.querySelector("#output-canvas").getContext("webgl"),n=document.querySelector("#output-canvas").offsetWidth,e=!1,o=!1,a=!1,i=0,r=0,c=!1,u=!1,l=!1,s=!1,_=!1,m=!1,f=0,d=1,g=3.2954,h=1.9657,p=500,v=16,y=[],M=[],w=[],S=[],b=[2.1089,.41345,.95325],q=0,z=2,L=[[0,0,5],[5,5,5],[0,0,5]],x=[[-.57735,0,.816496],[1,0,0],[.707107,0,.707107]],A=[[.288675,-.5,.816496],[0,1,0],[0,.707107,.707107]],E=[[.288675,.5,.816496],[0,0,1],[-.707107,0,.707107]],P=[[],[],[0,-.707107,.707107]],U=[1.333,1.333,1.333],F=[3,3,4],k=[[0,0,1],[.57735,.57735,.57735],[0,0,1]],I=2,T=2,C=0,R=0,D=0,Y=0,W=0,X=0,B=0,N=0,j=0,G=0,H=0,O=0,V=0,$=0,K=0,J=0,Q=0,Z=0,tt=0,nt=0;lt(),document.querySelector("#tetrahedron-radio-button").checked=!0,document.querySelector("#output-canvas").setAttribute("width",p),document.querySelector("#output-canvas").setAttribute("height",p),document.querySelector("#dim-input").addEventListener("input",function(){(p=parseInt(document.querySelector("#dim-input").value||500))<200&&(p=200);p>2e3&&(p=2e3);t.uniform1i(it.small_image_size_uniform,p),document.querySelector("#output-canvas").setAttribute("width",p),document.querySelector("#output-canvas").setAttribute("height",p),t.viewport(0,0,p,p),window.requestAnimationFrame(ut)}),document.querySelector("#generate-high-res-image-button").addEventListener("click",function(){let n=p;p=parseInt(document.querySelector("#high-res-dim-input").value||2e3),document.querySelector("#output-canvas").setAttribute("width",p),document.querySelector("#output-canvas").setAttribute("height",p),t.viewport(0,0,p,p),window.requestAnimationFrame(ut);let e=document.createElement("a");e.download="a-kaleidoscopic-ifs-fractal.png",e.href=document.querySelector("#output-canvas").toDataURL(),e.click(),e.remove(),p=n,document.querySelector("#output-canvas").setAttribute("width",p),document.querySelector("#output-canvas").setAttribute("height",p),t.viewport(0,0,p,p),window.requestAnimationFrame(ut)}),document.querySelector("#tetrahedron-radio-button").addEventListener("input",function(){0!==q&&gt(0)}),document.querySelector("#cube-radio-button").addEventListener("input",function(){1!==q&&gt(1)}),document.querySelector("#octahedron-radio-button").addEventListener("input",function(){2!==q&&gt(2)});let et=document.querySelectorAll("#scale-input, #rotation-angle-x-1-input, #rotation-angle-y-1-input, #rotation-angle-z-1-input, #rotation-angle-x-2-input, #rotation-angle-y-2-input, #rotation-angle-z-2-input");for(let t=0;t<et.length;t++)et[t].addEventListener("input",ft);document.querySelector("#randomize-parameters-button").addEventListener("click",function(t=!0){N=R,j=D,G=Y,H=W,O=X,V=B,$=.75*Math.random()-.375-N,K=.75*Math.random()-.375-j,J=1.5*Math.random()-.75-G,Q=.75*Math.random()-.375-H,Z=.75*Math.random()-.375-O,tt=1.5*Math.random()-.75-V,document.querySelector("#rotation-angle-x-1-input").value=Math.round(1e6*(N+$))/1e6,document.querySelector("#rotation-angle-y-1-input").value=Math.round(1e6*(j+K))/1e6,document.querySelector("#rotation-angle-z-1-input").value=Math.round(1e6*(G+J))/1e6,document.querySelector("#rotation-angle-x-2-input").value=Math.round(1e6*(H+Q))/1e6,document.querySelector("#rotation-angle-y-2-input").value=Math.round(1e6*(O+Z))/1e6,document.querySelector("#rotation-angle-z-2-input").value=Math.round(1e6*(V+tt))/1e6,T=I,C=0,t?dt():(R=N+$,D=j+K,Y=G+J,W=H+Q,X=O+Z,B=V+tt)}),window.addEventListener("resize",mt),setTimeout(mt,500),document.querySelector("#output-canvas").addEventListener("mousedown",function(t){a=!0,i=t.clientX,r=t.clientY,e||(e=!0,window.requestAnimationFrame(ut))}),document.querySelector("#output-canvas").addEventListener("mousemove",function(t){if(a){t.preventDefault();let e=t.clientX,o=t.clientY,a=e-i,c=o-r;(g+=a/n*Math.PI)>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),(h-=c/n*Math.PI)>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),i=e,r=o,lt()}}),document.documentElement.addEventListener("mouseup",function(t){e=(a=!1)||c||u||l||s||_||m}),document.querySelector("#output-canvas").addEventListener("touchstart",function(t){a=!0,i=t.touches[0].clientX,r=t.touches[0].clientY,2===t.touches.length?(_=!0,m=!1):3===t.touches.length&&(m=!0,_=!1),e||(e=!0,window.requestAnimationFrame(ut))}),document.querySelector("#output-canvas").addEventListener("touchmove",function(t){t.preventDefault();let e=t.touches[0].clientX,o=t.touches[0].clientY,a=e-i,c=o-r;Math.abs(a)>20||Math.abs(c)>20||((g+=a/n*Math.PI)>=2*Math.PI?g-=2*Math.PI:g<0&&(g+=2*Math.PI),(h-=c/n*Math.PI)>Math.PI-.01?h=Math.PI-.01:h<.01&&(h=.01),i=e,r=o,lt())}),document.querySelector("#output-canvas").addEventListener("touchend",function(t){2===t.touches.length?(_=!0,m=!1):3===t.touches.length?(m=!0,_=!1):(_=!1,m=!1,0===t.touches.length&&(a=!1)),e=a||c||u||l||s||_||m}),document.documentElement.addEventListener("keydown",function(t){87===t.keyCode?c=!0:83===t.keyCode&&(u=!0),68===t.keyCode?l=!0:65===t.keyCode&&(s=!0),e||(e=!0,window.requestAnimationFrame(ut))}),document.documentElement.addEventListener("keyup",function(t){87===t.keyCode?c=!1:83===t.keyCode&&(u=!1),68===t.keyCode?l=!1:65===t.keyCode&&(s=!1),e=a||c||u||l||s||_||m});const ot="\n\t\tattribute vec3 position;\n\t\tvarying vec2 uv;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tgl_Position = vec4(position, 1.0);\n\n\t\t\t//Interpolate quad coordinates in the fragment shader.\n\t\t\tuv = position.xy;\n\t\t}\n\t",at="\n\t\tprecision highp float;\n\t\t\n\t\tvarying vec2 uv;\n\t\t\n\t\tuniform vec3 camera_pos;\n\t\tuniform vec3 image_plane_center_pos;\n\t\tuniform vec3 forward_vec;\n\t\tuniform vec3 right_vec;\n\t\tuniform vec3 up_vec;\n\t\t\n\t\tuniform float focal_length;\n\t\t\n\t\tuniform vec3 light_pos;\n\t\tconst float light_brightness = 2.0;\n\t\t\n\t\tuniform int image_size;\n\t\tuniform int small_image_size;\n\t\t\n\t\t\n\t\t\n\t\tconst float clip_distance = 1000.0;\n\t\tconst int max_marches = 32;\n\t\tconst vec3 fog_color = vec3(0.0, 0.0, 0.0);\n\t\tconst float fog_scaling = .2;\n\t\tconst int num_sierpinski_iterations = 16;\n\t\t\n\t\t\n\t\tvec3 color;\n\t\t\n\t\tconst vec3 color_1 = vec3(1.0, 0.0, 0.0);\n\t\tconst vec3 color_2 = vec3(0.0, 1.0, 0.0);\n\t\tconst vec3 color_3 = vec3(0.0, 0.0, 1.0);\n\t\tconst vec3 color_4 = vec3(1.0, 1.0, 0.0);\n\t\t\n\t\t\n\t\t\n\t\tuniform vec3 scale_center;\n\t\t\n\t\tuniform int num_ns;\n\t\t\n\t\tuniform vec3 n1;\n\t\tuniform vec3 n2;\n\t\tuniform vec3 n3;\n\t\tuniform vec3 n4;\n\t\t\n\t\tuniform float min_scale_factor;\n\t\t\n\t\t\n\t\t\n\t\tuniform float rotation_angle_x_1;\n\t\tuniform float rotation_angle_y_1;\n\t\tuniform float rotation_angle_z_1;\n\t\tuniform float rotation_angle_x_2;\n\t\tuniform float rotation_angle_y_2;\n\t\tuniform float rotation_angle_z_2;\n\t\t\n\t\tuniform float scale;\n\t\t\n\t\t\n\t\t\n\t\tmat3 rotation_matrix_1 = mat3(\n\t\t\tcos(rotation_angle_z_1), sin(rotation_angle_z_1), 0.0,\n\t\t\t-sin(rotation_angle_z_1), cos(rotation_angle_z_1), 0.0,\n\t\t\t0.0, 0.0, 1.0\n\t\t) * mat3(\n\t\t\tcos(rotation_angle_y_1), 0.0, sin(rotation_angle_y_1),\n\t\t\t0.0, 1.0, 0.0,\n\t\t\t-sin(rotation_angle_y_1), 0.0, cos(rotation_angle_y_1)\n\t\t) * mat3(\n\t\t\t1.0, 0.0, 0.0,\n\t\t\t0.0, cos(rotation_angle_x_1), sin(rotation_angle_x_1),\n\t\t\t0.0, -sin(rotation_angle_x_1), cos(rotation_angle_x_1)\n\t\t);\n\t\t\n\t\tmat3 rotation_matrix_2 = mat3(\n\t\t\tcos(rotation_angle_z_2), sin(rotation_angle_z_2), 0.0,\n\t\t\t-sin(rotation_angle_z_2), cos(rotation_angle_z_2), 0.0,\n\t\t\t0.0, 0.0, 1.0\n\t\t) * mat3(\n\t\t\tcos(rotation_angle_y_2), 0.0, sin(rotation_angle_y_2),\n\t\t\t0.0, 1.0, 0.0,\n\t\t\t-sin(rotation_angle_y_2), 0.0, cos(rotation_angle_y_2)\n\t\t) * mat3(\n\t\t\t1.0, 0.0, 0.0,\n\t\t\t0.0, cos(rotation_angle_x_2), sin(rotation_angle_x_2),\n\t\t\t0.0, -sin(rotation_angle_x_2), cos(rotation_angle_x_2)\n\t\t);\n\t\t\n\t\t\n\t\t\n\t\tfloat distance_estimator(vec3 pos)\n\t\t{\n\t\t\tvec3 mutable_pos = pos;\n\t\t\t\n\t\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\t\tfloat color_scale = .5;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.\n\t\t\tfor (int iteration = 0; iteration < num_sierpinski_iterations; iteration++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t//Fold space over on itself so that we can reference only the top vertex.\n\t\t\t\tfloat t1 = dot(mutable_pos, n1);\n\t\t\t\t\n\t\t\t\tif (t1 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t1 * n1;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t2 = dot(mutable_pos, n2);\n\t\t\t\t\n\t\t\t\tif (t2 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t2 * n2;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t3 = dot(mutable_pos, n3);\n\t\t\t\t\n\t\t\t\tif (t3 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t3 * n3;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (num_ns >= 4)\n\t\t\t\t{\n\t\t\t\t\tfloat t4 = dot(mutable_pos, n4);\n\t\t\t\t\t\n\t\t\t\t\tif (t4 < 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tmutable_pos -= 2.0 * t4 * n4;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_1 * mutable_pos;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//Scale the system -- this one takes me a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.\n\t\t\t\tmutable_pos = scale*mutable_pos - (scale - 1.0)*scale_center;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmutable_pos = rotation_matrix_2 * mutable_pos;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcolor_scale *= .5;\n\t\t\t}\n\t\t\t\n\t\t\treturn length(mutable_pos) * pow(1.0/scale, float(num_sierpinski_iterations));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_surface_normal(vec3 pos)\n\t\t{\n\t\t\tfloat e = .00001;\n\t\t\t\n\t\t\tfloat base = distance_estimator(pos);\n\t\t\t\n\t\t\tfloat x_step = distance_estimator(pos + vec3(e, 0.0, 0.0));\n\t\t\tfloat y_step = distance_estimator(pos + vec3(0.0, e, 0.0));\n\t\t\tfloat z_step = distance_estimator(pos + vec3(0.0, 0.0, e));\n\t\t\t\n\t\t\treturn normalize(vec3(x_step - base, y_step - base, z_step - base));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 compute_shading(vec3 pos, int iteration)\n\t\t{\n\t\t\tvec3 surface_normal = get_surface_normal(pos);\n\t\t\t\n\t\t\tvec3 light_direction = normalize(light_pos - pos);\n\t\t\t\n\t\t\tfloat light_intensity = light_brightness * max(dot(surface_normal, light_direction), .25 * dot(surface_normal, -light_direction));\n\t\t\t\n\t\t\t//The last factor adds ambient occlusion.\n\t\t\tcolor = color * light_intensity * max((1.0 - float(iteration) / float(max_marches)), 0.0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Apply fog.\n\t\t\tfloat distance_from_camera = length(pos - camera_pos);\n\t\t\t\n\t\t\tfloat fog_amount = 1.0 - exp(-distance_from_camera * fog_scaling);\n\t\t\t\n\t\t\treturn (1.0 - fog_amount) * color + fog_amount * fog_color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\tvec3 start_pos = image_plane_center_pos + right_vec * uv.x + up_vec * uv.y;\n\t\t\t\n\t\t\t//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.\n\t\t\tvec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\n\t\t\tvec3 final_color = fog_color;\n\t\t\t\n\t\t\tfloat normalized_scale = scale - min_scale_factor;\n\t\t\t\n\t\t\tfloat epsilon = 1.0 / (normalized_scale * normalized_scale * normalized_scale) * .00001;\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < max_marches; iteration++)\n\t\t\t{\n\t\t\t\tvec3 pos = start_pos + t * ray_direction_vec;\n\t\t\t\t\n\t\t\t\tfloat distance = distance_estimator(pos);\n\t\t\t\t\n\t\t\t\t//This lowers the detail far away, which makes everything run nice and fast.\n\t\t\t\tif (image_size == small_image_size && distance / 150.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 150.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (image_size != small_image_size && distance / 500.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 500.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (distance < epsilon)\n\t\t\t\t{\n\t\t\t\t\tfinal_color = compute_shading(pos, iteration);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (t > clip_distance)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt += distance;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tgl_FragColor = vec4(final_color.xyz, 1.0);\n\t\t}\n\t";let it=null;function rt(){let n=ct(t,t.VERTEX_SHADER,ot),e=ct(t,t.FRAGMENT_SHADER,at);it=t.createProgram(),t.attachShader(it,n),t.attachShader(it,e),t.linkProgram(it),t.getProgramParameter(it,t.LINK_STATUS)||(console.log(`Couldn't link shader program: ${t.getShaderInfoLog(shader)}`),t.deleteProgram(it)),t.useProgram(it);let o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,-1,1,0,1,-1,0,1,1,0]),t.STATIC_DRAW),it.position_attribute=t.getAttribLocation(it,"position"),t.enableVertexAttribArray(it.position_attribute),t.vertexAttribPointer(it.position_attribute,3,t.FLOAT,!1,0,0),it.image_size_uniform=t.getUniformLocation(it,"image_size"),it.small_image_size_uniform=t.getUniformLocation(it,"small_image_size"),it.camera_pos_uniform=t.getUniformLocation(it,"camera_pos"),it.image_plane_center_pos_uniform=t.getUniformLocation(it,"image_plane_center_pos"),it.forward_vec_uniform=t.getUniformLocation(it,"forward_vec"),it.right_vec_uniform=t.getUniformLocation(it,"right_vec"),it.up_vec_uniform=t.getUniformLocation(it,"up_vec"),it.focal_length_uniform=t.getUniformLocation(it,"focal_length"),it.light_pos_uniform=t.getUniformLocation(it,"light_pos"),it.scale_center_uniform=t.getUniformLocation(it,"scale_center"),it.n1_uniform=t.getUniformLocation(it,"n1"),it.n2_uniform=t.getUniformLocation(it,"n2"),it.n3_uniform=t.getUniformLocation(it,"n3"),it.n4_uniform=t.getUniformLocation(it,"n4"),it.min_scale_factor_uniform=t.getUniformLocation(it,"min_scale_factor"),it.num_ns_uniform=t.getUniformLocation(it,"num_ns"),it.scale_uniform=t.getUniformLocation(it,"scale"),it.rotation_angle_x_1_uniform=t.getUniformLocation(it,"rotation_angle_x_1"),it.rotation_angle_y_1_uniform=t.getUniformLocation(it,"rotation_angle_y_1"),it.rotation_angle_z_1_uniform=t.getUniformLocation(it,"rotation_angle_z_1"),it.rotation_angle_x_2_uniform=t.getUniformLocation(it,"rotation_angle_x_2"),it.rotation_angle_y_2_uniform=t.getUniformLocation(it,"rotation_angle_y_2"),it.rotation_angle_z_2_uniform=t.getUniformLocation(it,"rotation_angle_z_2"),t.viewport(0,0,p,p),t.uniform1i(it.small_image_size_uniform,p),window.requestAnimationFrame(ut)}function ct(t,n,e){let o=t.createShader(n);return t.shaderSource(o,e),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)||(console.log(`Couldn't load shader: ${t.getProgramInfoLog(shaderProgram)}`),t.deleteShader(o)),o}function ut(){t.uniform1i(it.image_size_uniform,p),t.uniform3fv(it.camera_pos_uniform,b),t.uniform3fv(it.image_plane_center_pos_uniform,y),t.uniform3fv(it.forward_vec_uniform,M),t.uniform3fv(it.right_vec_uniform,w),t.uniform3fv(it.up_vec_uniform,S),t.uniform1f(it.focal_length_uniform,z),t.uniform3fv(it.light_pos_uniform,L[q]),t.uniform3fv(it.scale_center_uniform,k[q]),t.uniform3fv(it.n1_uniform,x[q]),t.uniform3fv(it.n2_uniform,A[q]),t.uniform3fv(it.n3_uniform,E[q]),t.uniform3fv(it.n4_uniform,P[q]),t.uniform1f(it.min_scale_factor_uniform,U[q]),t.uniform1i(it.num_ns_uniform,F[q]),t.uniform1f(it.scale_uniform,I),t.uniform1f(it.rotation_angle_x_1_uniform,R),t.uniform1f(it.rotation_angle_y_1_uniform,D),t.uniform1f(it.rotation_angle_z_1_uniform,Y),t.uniform1f(it.rotation_angle_x_2_uniform,W),t.uniform1f(it.rotation_angle_y_2_uniform,X),t.uniform1f(it.rotation_angle_z_2_uniform,B),t.drawArrays(t.TRIANGLE_STRIP,0,4),o?(!function(){let t=.5*Math.sin(Math.PI*nt/120-Math.PI/2)+.5;I=T+C*t,R=N+$*t,D=j+K*t,Y=G+J*t,W=H+Q*t,X=O+Z*t,B=V+tt*t,121==++nt&&(o=!1)}(),window.requestAnimationFrame(ut)):e&&((c||u||l||s||_||m)&&((f=d/20)<25e-6&&(f=25e-6),f>.02&&(f=.02),c||_?(b[0]+=f*M[0],b[1]+=f*M[1],b[2]+=f*M[2]):(u||m)&&(b[0]-=f*M[0],b[1]-=f*M[1],b[2]-=f*M[2]),l?(b[0]+=f*w[0]/z,b[1]+=f*w[1]/z,b[2]+=f*w[2]/z):s&&(b[0]-=f*w[0]/z,b[1]-=f*w[1]/z,b[2]-=f*w[2]/z),lt()),window.requestAnimationFrame(ut))}function lt(){var t,n;M=[Math.cos(g)*Math.sin(h),Math.sin(g)*Math.sin(h),Math.cos(h)],w=function(t){let n=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/n,t[1]/n,t[2]/n]}([M[1],-M[0],0]),n=M,S=[(t=w)[1]*n[2]-t[2]*n[1],t[2]*n[0]-t[0]*n[2],t[0]*n[1]-t[1]*n[0]],d=function(t,n,e){for(let o=0;o<v;o++){let o=st([t,n,e],x[q]);o<0&&(t-=2*o*x[q][0],n-=2*o*x[q][1],e-=2*o*x[q][2]);let a=st([t,n,e],A[q]);a<0&&(t-=2*a*A[q][0],n-=2*a*A[q][1],e-=2*a*A[q][2]);let i=st([t,n,e],E[q]);if(i<0&&(t-=2*i*E[q][0],n-=2*i*E[q][1],e-=2*i*E[q][2]),F[q]>=4){let o=st([t,n,e],P[q]);o<0&&(t-=2*o*P[q][0],n-=2*o*P[q][1],e-=2*o*P[q][2])}let r=t,c=n,u=e,l=[[Math.cos(Y),-Math.sin(Y),0],[Math.sin(Y),Math.cos(Y),0],[0,0,1]],s=[[Math.cos(D),0,-Math.sin(D)],[0,1,0],[Math.sin(D),0,Math.cos(D)]],_=[[1,0,0],[0,Math.cos(R),-Math.sin(R)],[0,Math.sin(R),Math.cos(R)]],m=_t(_t(l,s),_);t=m[0][0]*r+m[0][1]*c+m[0][2]*u,n=m[1][0]*r+m[1][1]*c+m[1][2]*u,e=m[2][0]*r+m[2][1]*c+m[2][2]*u,t=I*t-(I-1)*k[q][0],n=I*n-(I-1)*k[q][1],e=I*e-(I-1)*k[q][2],r=t,c=n,u=e,l=[[Math.cos(B),-Math.sin(B),0],[Math.sin(B),Math.cos(B),0],[0,0,1]],s=[[Math.cos(X),0,-Math.sin(X)],[0,1,0],[Math.sin(X),0,Math.cos(X)]],_=[[1,0,0],[0,Math.cos(W),-Math.sin(W)],[0,Math.sin(W),Math.cos(W)]],m=_t(_t(l,s),_),t=m[0][0]*r+m[0][1]*c+m[0][2]*u,n=m[1][0]*r+m[1][1]*c+m[1][2]*u,e=m[2][0]*r+m[2][1]*c+m[2][2]*u}return Math.sqrt(t*t+n*n+e*e)*Math.pow(I,-v)}(b[0],b[1],b[2]),z=d/2,w[0]*=z/2,w[1]*=z/2,S[0]*=z/2,S[1]*=z/2,S[2]*=z/2,y=[b[0]+z*M[0],b[1]+z*M[1],b[2]+z*M[2]]}function st(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}function _t(t,n){return[[t[0][0]*n[0][0]+t[0][1]*n[1][0]+t[0][2]*n[2][0],t[0][0]*n[0][1]+t[0][1]*n[1][1]+t[0][2]*n[2][1],t[0][0]*n[0][2]+t[0][1]*n[1][2]+t[0][2]*n[2][2]],[t[1][0]*n[0][0]+t[1][1]*n[1][0]+t[1][2]*n[2][0],t[1][0]*n[0][1]+t[1][1]*n[1][1]+t[1][2]*n[2][1],t[1][0]*n[0][2]+t[1][1]*n[1][2]+t[1][2]*n[2][2]],[t[2][0]*n[0][0]+t[2][1]*n[1][0]+t[2][2]*n[2][0],t[2][0]*n[0][1]+t[2][1]*n[1][1]+t[2][2]*n[2][1],t[2][0]*n[0][2]+t[2][1]*n[1][2]+t[2][2]*n[2][2]]]}function mt(){n=document.querySelector("#output-canvas").offsetWidth}function ft(){T=I,N=R,j=D,G=Y,H=W,O=X,V=B,C=parseFloat(document.querySelector("#scale-input").value||2)-T,$=(parseFloat(document.querySelector("#rotation-angle-x-1-input").value)||0)-N,K=(parseFloat(document.querySelector("#rotation-angle-y-1-input").value)||0)-j,J=(parseFloat(document.querySelector("#rotation-angle-z-1-input").value)||0)-G,Q=(parseFloat(document.querySelector("#rotation-angle-x-2-input").value)||0)-H,Z=(parseFloat(document.querySelector("#rotation-angle-y-2-input").value)||0)-O,tt=(parseFloat(document.querySelector("#rotation-angle-z-2-input").value)||0)-V,T+C<U[q]+.1&&(C=U[q]+.1-T),dt()}function dt(){o=!0,nt=0,window.requestAnimationFrame(ut)}function gt(t){document.querySelector("#output-canvas").classList.add("animated-opacity"),document.querySelector("#output-canvas").style.opacity=0,setTimeout(function(){q=t,window.requestAnimationFrame(ut),document.querySelector("#output-canvas").style.opacity=1,setTimeout(function(){document.querySelector("#output-canvas").classList.remove("animated-opacity")})},300)}load_script("/scripts/gl-matrix.min.js").then(function(){setTimeout(rt,500)})}();