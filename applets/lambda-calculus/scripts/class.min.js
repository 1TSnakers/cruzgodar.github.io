import anime from"/scripts/anime.min.js";import{AnimationFrameApplet}from"/scripts/applets/animationFrameApplet.min.js";import{hsvToRgb}from"/scripts/applets/applet.min.js";import{siteSettings}from"/scripts/src/settings.min.js";import{WilsonCPU}from"/scripts/wilson.min.js";const LITERAL=0,LAMBDA=1,APPLICATION=2,CONNECTOR=3;class LambdaCalculus extends AnimationFrameApplet{outerExpressionSize;resolution=2e3;lambdaIndex=0;numLambdas=0;animationTime=2e3;nextId=0;constructor({canvas}){super(canvas);var e={canvasWidth:this.resolution,fullscreenOptions:{useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}};this.wilson=new WilsonCPU(this.canvas,e)}run({resolution=2e3,expression:expressionString,betaReduce=!1}){this.resolution=resolution,expressionString=expressionString.replaceAll(/[\n\t\s.]/g,""),this.numLambdas=expressionString.split("λ").length-1,this.lambdaIndex=0;var e=this.parseExpression(expressionString),s=(this.validateExpression(e),this.setupExpression(e),this.drawExpression(e),this.expressionToString(e));return betaReduce&&this.animateIteratedBetaReduction(e),s}parseExpression(expressionString){if(0===expressionString.length)throw new Error("Empty expression.");for(var i=[];0<expressionString.length;)if("λ"===expressionString[0]){if(expressionString.length<3)throw new Error("Expression too short.");var o=expressionString[1],e=expressionString.slice(2);i.push({type:LAMBDA,argument:o,body:this.parseExpression(e),literalColor:{h:this.lambdaIndex/this.numLambdas,s:.8,v:1}}),this.lambdaIndex++,expressionString=""}else if("("===expressionString[0]){let e=1,s=1;for(;0<s;)"("===expressionString[e]?s++:")"===expressionString[e]&&s--,e++;o=this.parseExpression(expressionString.slice(1,e-1));o.startText="("+(o.startText??""),o.endText=(o.endText??"")+")",i.push(o),expressionString=expressionString.slice(e)}else i.push({type:LITERAL,value:expressionString[0]}),expressionString=expressionString.slice(1);if(1===i.length)return i[0];let s=i[0];for(let t=1;t<i.length;t++)s={type:APPLICATION,function:s,input:i[t]};return s}validateExpression(expression,scopedVariables=[]){if(expression.type!==LITERAL)return expression.type===LAMBDA?this.validateExpression(expression.body,[...scopedVariables,expression.argument]):this.validateExpression(expression.function,scopedVariables)&&this.validateExpression(expression.input,scopedVariables);if(scopedVariables.includes(expression.value))return!0;throw new Error(`Undefined variable ${expression.value}.`)}checkIfExpressionContainsApplication(expression){return expression.type!==LITERAL&&(expression.type!==LAMBDA||this.checkIfExpressionContainsApplication(expression.body))}setupExpression(expression,isBetaReduction=!1){this.addExpressionSize(expression),this.checkIfExpressionContainsApplication(expression)&&expression.height--,this.outerExpressionSize=Math.max(expression.width,expression.height),expression.row=Math.max((this.outerExpressionSize-expression.height)/2,0),expression.col=Math.max((this.outerExpressionSize-expression.width)/2,0),this.addExpressionLocation(expression),this.addExpressionBindings(expression),this.addExpressionColors(expression),this.addExpressionRects(expression,isBetaReduction),expression.type===APPLICATION&&(expression.rects[0].row++,expression.rects[1].height++,expression.rects[2].height++),expression.rectIndex={},this.addExpressionRectIndices(expression,expression.rectIndex)}addExpressionSize(expression){expression.type===LAMBDA?(this.addExpressionSize(expression.body),expression.width=expression.body.width,expression.height=expression.body.height+2):expression.type===APPLICATION?(this.addExpressionSize(expression.function),this.addExpressionSize(expression.input),expression.width=expression.function.width+expression.input.width+1,expression.height=Math.max(expression.function.height,expression.input.height)+2):(expression.width=3,expression.height=0)}addExpressionLocation(expression){expression.type===LAMBDA?(expression.body.row=expression.row+2,expression.body.col=expression.col,this.addExpressionLocation(expression.body)):expression.type===APPLICATION&&(expression.function.row=expression.row,expression.function.col=expression.col,expression.input.row=expression.row,expression.input.col=expression.col+expression.function.width+1,this.addExpressionLocation(expression.function),this.addExpressionLocation(expression.input))}addExpressionBindings(expression,bindings={}){expression.type===LITERAL?expression.bindingLambda=bindings[expression.value]:expression.type===LAMBDA?this.addExpressionBindings(expression.body,{...bindings,[expression.argument]:expression}):(this.addExpressionBindings(expression.function,bindings),this.addExpressionBindings(expression.input,bindings))}addExpressionColors(expression){var e,s,i,o;expression.type===LITERAL?expression.color=expression.bindingLambda.literalColor:expression.type===LAMBDA?(this.addExpressionColors(expression.body),expression.color=expression.body.color):(this.addExpressionColors(expression.function),this.addExpressionColors(expression.input),e=expression.function.color.h,s=expression.input.color.h,i=expression.function.color.s,o=expression.input.color.s,expression.color={h:Math.abs(e-s)<=.5?(e+s)/2:(e+s+1)/2%1,s:Math.max((i+o)/2-.1,.1),v:1})}addExpressionRects(expression,isBetaReduction){if(expression.type===LAMBDA){var e=hsvToRgb(expression.literalColor.h,expression.literalColor.s,expression.literalColor.v),e=[{type:LAMBDA,color:`rgb(${e[0]}, ${e[1]}, ${e[2]})`,row:expression.row,col:expression.col,width:expression.width,height:1}];isBetaReduction?(expression.rects[0].row=e[0].row,expression.rects[0].col=e[0].col,expression.rects[0].width=e[0].width,expression.rects[0].height=e[0].height,expression.rects[0].color=e[0].color):expression.rects=e,this.addExpressionRects(expression.body,isBetaReduction)}else if(expression.type===APPLICATION){var e=hsvToRgb(expression.function.color.h,expression.function.color.s,expression.function.color.v),e={type:CONNECTOR,color:`rgb(${e[0]}, ${e[1]}, ${e[2]})`,col:expression.col+1,width:1},s=(expression.function.type!==LAMBDA&&expression.function.type===LITERAL?e.row=expression.function.bindingLambda.row+1:e.row=expression.function.row+expression.function.height-1,e.height=expression.row+expression.height-3-e.row+1,hsvToRgb(expression.input.color.h,expression.input.color.s,expression.input.color.v)),s={type:CONNECTOR,color:`rgb(${s[0]}, ${s[1]}, ${s[2]})`,col:expression.col+expression.function.width+2,width:1},i=(expression.input.type!==LAMBDA&&expression.input.type===LITERAL?s.row=expression.input.bindingLambda.row+1:s.row=expression.input.row+expression.input.height-1,s.height=expression.row+expression.height-3-s.row+1,hsvToRgb(expression.color.h,expression.color.s,expression.color.v)),o=[{type:APPLICATION,color:`rgb(${i[0]}, ${i[1]}, ${i[2]})`,row:expression.row+expression.height-2,col:expression.col+1,width:expression.function.width+2,height:1},e,s];if(isBetaReduction)for(let e=0;e<3;e++)expression.rects[e].row=o[e].row,expression.rects[e].col=o[e].col,expression.rects[e].width=o[e].width,expression.rects[e].height=o[e].height,expression.rects[e].color=o[e].color;else expression.rects=o;this.addExpressionRects(expression.function,isBetaReduction),this.addExpressionRects(expression.input,isBetaReduction)}else{i=hsvToRgb(expression.color.h,expression.color.s,expression.color.v),e=[{type:LITERAL,color:`rgb(${i[0]}, ${i[1]}, ${i[2]})`,row:expression.bindingLambda.row+1,col:expression.col+1,width:1,height:expression.row-1-(expression.bindingLambda.row+1)+1}];isBetaReduction?(expression.rects[0].row=e[0].row,expression.rects[0].col=e[0].col,expression.rects[0].width=e[0].width,expression.rects[0].height=e[0].height):expression.rects=e}}addExpressionRectIndices(expression,rectIndex){if(expression.type===LAMBDA)void 0===expression.rects[0].id&&(expression.rects[0].id=this.nextId,this.nextId++),rectIndex[expression.rects[0].id]=expression.rects[0],this.addExpressionRectIndices(expression.body,rectIndex);else if(expression.type===APPLICATION){for(let e=0;e<3;e++)void 0===expression.rects[e].id&&(expression.rects[e].id=this.nextId,this.nextId++),rectIndex[expression.rects[e].id]=expression.rects[e];this.addExpressionRectIndices(expression.function,rectIndex),this.addExpressionRectIndices(expression.input,rectIndex)}else void 0===expression.rects[0].id&&(expression.rects[0].id=this.nextId,this.nextId++),rectIndex[expression.rects[0].id]=expression.rects[0]}removeExpressionRectIndices(expression){if(expression.type===LAMBDA)expression.rects[0].id=void 0,this.removeExpressionRectIndices(expression.body);else if(expression.type===APPLICATION){for(let e=0;e<3;e++)expression.rects[e].id=void 0;this.removeExpressionRectIndices(expression.function),this.removeExpressionRectIndices(expression.input)}else expression.rects[0].id=void 0}drawExpression(expression){this.outerExpressionSize=Math.max(expression.width,expression.height),this.resolution=Math.round(this.resolution/(this.outerExpressionSize+2))*(this.outerExpressionSize+2),this.wilson.resizeCanvas({width:this.resolution}),this.wilson.ctx.fillStyle="rgb(0, 0, 0)",this.wilson.ctx.fillRect(0,0,this.resolution,this.resolution),this.drawExpressionStep(expression)}drawExpressionStep(expression){for(const s of expression.rects){this.wilson.ctx.fillStyle=s.color;var e=this.resolution/(this.outerExpressionSize+2);this.wilson.ctx.fillRect(e*(s.col+1),e*(s.row+1),e*s.width,e*s.height)}expression.type===LAMBDA?this.drawExpressionStep(expression.body):expression.type===APPLICATION&&(this.drawExpressionStep(expression.function),this.drawExpressionStep(expression.input))}expressionToString(expression){var e=expression.startText??"",s=expression.endText??"",i=siteSettings.darkTheme?1:.7;if(expression.type===LITERAL){const r=expression.bindingLambda.literalColor,n=hsvToRgb(r.h,r.s,r.v*i),p=`rgb(${n[0]}, ${n[1]}, ${n[2]})`;return`<span style="color: ${p}">${e}${expression.value}${s}</span>`}if(expression.type===LAMBDA){var o=expression.literalColor,o=hsvToRgb(o.h,o.s,o.v*i),o=`rgb(${o[0]}, ${o[1]}, ${o[2]})`;const r=expression.color,n=hsvToRgb(r.h,r.s,r.v*i),p=`rgb(${n[0]}, ${n[1]}, ${n[2]})`;return`<span style="color: ${p}">${e}</span><span style="color: ${o}">λ${expression.argument}.</span>${this.expressionToString(expression.body)}<span style="color: ${p}">${s}</span>`}var o=this.expressionToString(expression.function),t=this.expressionToString(expression.input);const r=expression.color,n=hsvToRgb(r.h,r.s,r.v*i),p=`rgb(${n[0]}, ${n[1]}, ${n[2]})`;return`<span style="color: ${p}">${e}</span>${o}${t}<span style="color: ${p}">${s}</span>`}listAllBetaReductions(expression){var e,s,i,o,t;return expression.type===APPLICATION?(e=this.listAllBetaReductions(expression.function).map(reduction=>{var e=structuredClone(expression);return e.function=reduction,e}),s=this.listAllBetaReductions(expression.input).map(reduction=>{var e=structuredClone(expression);return e.input=reduction,e}),expression.function.type===LAMBDA?(t=(o=structuredClone(expression)).function.body,i=o.function,o=o.input,this.removeExpressionRectIndices(o),t=this.computeBetaReduction(t,i,o),[...e,...s,t]):[...e,...s]):expression.type===LAMBDA?this.listAllBetaReductions(expression.body).map(reduction=>{var e=structuredClone(expression);return e.body=reduction,e}):[]}computeBetaReduction(expression,bindingLambdaToReplace,replacementValue){if(expression.type===LITERAL){if(expression.bindingLambda===bindingLambdaToReplace)return structuredClone(replacementValue)}else expression.type===LAMBDA?expression.body=this.computeBetaReduction(expression.body,bindingLambdaToReplace,replacementValue):(expression.function=this.computeBetaReduction(expression.function,bindingLambdaToReplace,replacementValue),expression.input=this.computeBetaReduction(expression.input,bindingLambdaToReplace,replacementValue));return expression}async animateBetaReduction(expression,betaReducedExpression){const r=structuredClone(expression.rectIndex),o=structuredClone(betaReducedExpression.rectIndex),n=Object.keys(expression.rectIndex).filter(rectId=>rectId in betaReducedExpression.rectIndex);var e=Object.keys(expression.rectIndex).filter(rectId=>!(rectId in betaReducedExpression.rectIndex)).sort((a,b)=>r[a].row+r[a].height!==r[b].row+r[b].height?r[a].row+r[a].height-(r[b].row+r[b].height):r[a].col-r[b].col),s=Object.keys(betaReducedExpression.rectIndex).filter(rectId=>!(rectId in expression.rectIndex)).sort((a,b)=>parseInt(a)-parseInt(b));const t=e.slice(-3),i=e.find(key=>r[key].type===LAMBDA),p=[i].concat(e.filter(key=>r[key].type===LITERAL&&r[key].row===r[i].row+1&&r[key].col>=r[i].col&&r[key].col<r[i].col+r[i].width)),x=e.filter(key=>!(t.includes(key)||p.includes(key)));var c=[];for(let P=0;P<s.length;P+=x.length)c.push(s.slice(P,P+x.length).sort((a,b)=>o[a].row+o[a].height!==o[b].row+o[b].height?o[a].row+o[a].height-(o[b].row+o[b].height):o[a].col-o[b].col));const d=c.flat(),l=(console.log(e,d,x),console.log(d.map(key=>o[key])),console.log(x.map(key=>r[key])),x.every(key=>r[key].type===LITERAL));let h=1/0,u=1/0,g=0,w=0;for(const M of x){var E=r[M];h=Math.min(h,E.row),u=Math.min(u,E.col),g=Math.max(g,E.row+E.height),w=Math.max(w,E.col+E.width)}var e=w-u,I=g-h;const f=Math.max(expression.width,expression.height),m=Math.max(betaReducedExpression.width,betaReducedExpression.height),R=0===d.length||l?m:Math.max(Math.max(betaReducedExpression.width,e),betaReducedExpression.height+2*(6+I));I=betaReducedExpression.row-3-I,e=(m-e)/2;const y=I-h,A=e-u,v=l?0:(R-betaReducedExpression.height)/2-betaReducedExpression.row,L=l?0:(R-betaReducedExpression.width)/2-betaReducedExpression.col;for(const M of n)betaReducedExpression.rectIndex[M].row+=v,betaReducedExpression.rectIndex[M].col+=L;const T=Object.fromEntries(Object.entries(expression.rectIndex).map(([key,value])=>[key,value.color.slice(4,-1).split(",").map(Number)])),S=Object.fromEntries(Object.entries(betaReducedExpression.rectIndex).map(([key,value])=>[key,value.color.slice(4,-1).split(",").map(Number)]));var $=d.length/x.length;if(d.length%x.length!=0&&!l)throw new Error("Chunking failed.");const B={t:0};if(await anime({targets:B,t:1,duration:.5*this.animationTime,easing:"easeInOutQuad",update:()=>{this.outerExpressionSize=f;for(const e of t)expression.rectIndex[e].row=r[e].row+B.t,expression.rectIndex[e].color=`rgba(${r[e].color.slice(4,-1)}, ${1-B.t})`;for(const s of p)expression.rectIndex[s].row=r[s].row-B.t,expression.rectIndex[s].color=`rgba(${r[s].color.slice(4,-1)}, ${1-B.t})`;if(0===d.length||l)for(const i of x)expression.rectIndex[i].color=`rgba(${r[i].color.slice(4,-1)}, ${1-B.t})`;this.wilson.ctx.fillStyle="rgb(0, 0, 0)",this.wilson.ctx.fillRect(0,0,this.resolution,this.resolution),this.drawExpressionStep(expression)}}).finished,await new Promise(resolve=>setTimeout(resolve,this.animationTime/3)),B.t=0,await anime({targets:B,t:1,duration:this.animationTime,easing:"easeInOutQuad",update:()=>{this.outerExpressionSize=(1-B.t)*f+B.t*R;for(const o of n){expression.rectIndex[o].row=(1-B.t)*r[o].row+B.t*betaReducedExpression.rectIndex[o].row,expression.rectIndex[o].col=(1-B.t)*r[o].col+B.t*betaReducedExpression.rectIndex[o].col,expression.rectIndex[o].width=(1-B.t)*r[o].width+B.t*betaReducedExpression.rectIndex[o].width,expression.rectIndex[o].height=(1-B.t)*r[o].height+B.t*betaReducedExpression.rectIndex[o].height;var e=(1-B.t)*T[o][0]+B.t*S[o][0],s=(1-B.t)*T[o][1]+B.t*S[o][1],i=(1-B.t)*T[o][2]+B.t*S[o][2];expression.rectIndex[o].color=`rgb(${e}, ${s}, ${i})`}for(const t of x)expression.rectIndex[t].row=r[t].row+B.t*(y+v),expression.rectIndex[t].col=r[t].col+B.t*(A+L);this.wilson.ctx.fillStyle="rgb(0, 0, 0)",this.wilson.ctx.fillRect(0,0,this.resolution,this.resolution),this.drawExpressionStep(expression)}}).finished,await new Promise(resolve=>setTimeout(resolve,this.animationTime/3)),l)this.drawExpression(betaReducedExpression),await new Promise(resolve=>setTimeout(resolve,this.animationTime/3));else{for(let s=0;s<$;s++)for(let e=x.length*s;e<x.length*(s+1);e++){var C=x[e%x.length],M=d[e];betaReducedExpression.rectIndex[M].row=expression.rectIndex[C].row,betaReducedExpression.rectIndex[M].col=expression.rectIndex[C].col,betaReducedExpression.rectIndex[M].width=expression.rectIndex[C].width,betaReducedExpression.rectIndex[M].height=expression.rectIndex[C].height}const k=structuredClone(betaReducedExpression.rectIndex);for(let i=0;i<$-1;i++)B.t=0,await anime({targets:B,t:1,duration:1.5*this.animationTime/$,easing:"easeInOutQuad",update:()=>{this.outerExpressionSize=R;for(let s=x.length*i;s<x.length*(i+1);s++){var e=d[s];betaReducedExpression.rectIndex[e].row=(1-B.t)*k[e].row+B.t*(o[e].row+v),betaReducedExpression.rectIndex[e].col=(1-B.t)*k[e].col+B.t*(o[e].col+L),betaReducedExpression.rectIndex[e].width=(1-B.t)*k[e].width+B.t*o[e].width,betaReducedExpression.rectIndex[e].height=(1-B.t)*k[e].height+B.t*o[e].height}this.wilson.ctx.fillStyle="rgb(0, 0, 0)",this.wilson.ctx.fillRect(0,0,this.resolution,this.resolution),this.drawExpressionStep(betaReducedExpression)}}).finished;for(let e=B.t=0;e<x.length*($-1);e++){const M=d[e];k[M].row=betaReducedExpression.rectIndex[M].row,k[M].col=betaReducedExpression.rectIndex[M].col,k[M].width=betaReducedExpression.rectIndex[M].width,k[M].height=betaReducedExpression.rectIndex[M].height}0!==d.length&&await anime({targets:B,t:1,duration:1.5*this.animationTime/$,easing:"easeInOutQuad",update:()=>{this.outerExpressionSize=(1-B.t)*R+B.t*m;for(const e in o)betaReducedExpression.rectIndex[e].row=(1-B.t)*k[e].row+B.t*o[e].row,betaReducedExpression.rectIndex[e].col=(1-B.t)*k[e].col+B.t*o[e].col,betaReducedExpression.rectIndex[e].width=(1-B.t)*k[e].width+B.t*o[e].width,betaReducedExpression.rectIndex[e].height=(1-B.t)*k[e].height+B.t*o[e].height;this.wilson.ctx.fillStyle="rgb(0, 0, 0)",this.wilson.ctx.fillRect(0,0,this.resolution,this.resolution),this.drawExpressionStep(betaReducedExpression)}}).finished,this.drawExpression(betaReducedExpression),await new Promise(resolve=>setTimeout(resolve,this.animationTime/3))}}async animateIteratedBetaReduction(expression){for(;;){var o=this.listAllBetaReductions(expression);if(0===o.length)break;let e=1/0,s=0;for(let i=0;i<o.length;i++){this.setupExpression(o[i],!0);var t=o[i].width*o[i].height;t<e&&(e=t,s=i)}this.setupExpression(o[s],!0),await this.animateBetaReduction(expression,o[s]),expression=o[s]}}}export{LambdaCalculus};