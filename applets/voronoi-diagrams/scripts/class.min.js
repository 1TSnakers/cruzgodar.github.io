import{Applet,getMinGlslString,getVectorGlsl}from"/scripts/src/applets.min.js";import{Wilson}from"/scripts/wilson.min.js";class VoronoiDiagram extends Applet{lastTimestamp=-1;numPoints=20;metric=2;resolution=1e3;pointRadius;points;constructor({canvas}){super(canvas);var i={renderer:"gpu",shader:`
			precision highp float;
			
			varying vec2 uv;
			
			void main(void)
			{
				gl_FragColor = vec4(0, 0, 0, 1);
			}
		`,canvasWidth:this.resolution,canvasHeight:this.resolution,useFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"};this.wilson=new Wilson(this.canvas,i)}run({resolution=500,numPoints=20,metric=2}){this.resolution=resolution,this.numPoints=numPoints,this.metric=metric,this.wilson.changeCanvasSize(this.resolution,this.resolution),this.generatePoints();var i=1===this.metric?`
					abs(p.x - q.x) + abs(p.y - q.y)
				`:2===this.metric?`
					distance(p, q)
				`:`
					max(abs(p.x - q.x), abs(p.y - q.y))
				`,i=`
			precision highp float;
			
			varying vec2 uv;

			const float pointRadius = 0.01;
			const float blurRatio = 0.5;

	${this.points.map((point,index)=>`
			const vec2 point${index} = ${getVectorGlsl(point)};
		`).join("")}
			
			float metricDistance(vec2 p, vec2 q)
			{
				return ${i};
			}

			float getMinDistanceToPoints(vec2 p)
			{
	${this.points.map((point,index)=>`
			float distance${index+1} = metricDistance(p, point${index});
		`).join("")}

				return ${getMinGlslString("distance",this.numPoints)};
			}

			void main(void)
			{
				float minDistance = getMinDistanceToPoints(uv);

				if (minDistance < pointRadius)
				{
					gl_FragColor = vec4(1, 1, 1, 1);
					return;
				}

				if (minDistance < (1.0 + blurRatio) * pointRadius)
				{
					float t = 1.0 - (minDistance - pointRadius) / (blurRatio * pointRadius);

					gl_FragColor = vec4(t, t, t, 1);
					return;
				}

				gl_FragColor = vec4(0, 0, 0, 1);
			}
		`;this.wilson.render.shaderPrograms=[],this.wilson.render.loadNewShader(i),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0]),window.requestAnimationFrame(this.drawFrame.bind(this))}generatePoints(){this.points=new Array(this.numPoints);for(let n=0;n<this.numPoints;n++)this.points[n]=[.8*(Math.random()-.5)*this.wilson.worldWidth,.8*(Math.random()-.5)*this.wilson.worldHeight];var t,s=new Array(this.numPoints),i=.1/this.numPoints;for(let o=0;o<this.numPoints;o++){s[o]=[0,0];for(let i=0;i<this.numPoints;i++)i!==o&&(t=(this.points[i][0]-this.points[o][0])**2+(this.points[i][1]-this.points[o][1])**2,s[o][0]+=(this.points[o][0]-this.points[i][0])/t,s[o][1]+=(this.points[o][1]-this.points[i][1])/t)}for(let e=0;e<this.numPoints;e++)this.points[e][0]+=i*s[e][0],this.points[e][1]+=i*s[e][1],this.points[e][0]=Math.min(Math.max(this.points[e][0],-this.wilson.worldWidth/2),this.wilson.worldWidth/2),this.points[e][1]=Math.min(Math.max(this.points[e][1],-this.wilson.worldHeight/2),this.wilson.worldHeight/2)}drawFrame(timestamp){var i=timestamp-this.lastTimestamp;this.lastTimestamp=timestamp,0==i||(this.wilson.render.drawFrame(),this.animationPaused)||window.requestAnimationFrame(this.drawFrame.bind(this))}}export{VoronoiDiagram};