import anime from"/scripts/anime.min.js";import{Applet,getMinGlslString,getVectorGlsl}from"/scripts/src/applets.min.js";import{Wilson}from"/scripts/wilson.min.js";class VoronoiDiagram extends Applet{wilsonHidden;lastTimestamp=-1;currentlyAnimating=!1;numPoints=20;metric=2;resolution=1e3;resolutionHidden=100;t;radius;maxRadius;pointRadius;pointOpacity;points;colors;cancelAnimaton=()=>{};constructor({canvas}){super(canvas);var i=`
			precision highp float;
			
			varying vec2 uv;
			
			void main(void)
			{
				gl_FragColor = vec4(0, 0, 0, 1);
			}
		`,t={renderer:"gpu",shader:i,canvasWidth:this.resolution,canvasHeight:this.resolution,useFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"},t=(this.wilson=new Wilson(this.canvas,t),{renderer:"gpu",shader:i,canvasWidth:this.resolutionHidden,canvasHeight:this.resolutionHidden});this.wilsonHidden=new Wilson(this.createHiddenCanvas(),t)}run({resolution=500,numPoints=20,metric=2}){if(!this.currentlyAnimating){this.resolution=resolution,this.numPoints=numPoints,this.metric=metric,this.t=-.1,this.radius=-.1,this.pointOpacity=1,this.lastTimestamp=-1,this.wilson.changeCanvasSize(this.resolution,this.resolution),this.generatePoints(),this.wilsonHidden.render.shaderPrograms=[],this.wilsonHidden.render.loadNewShader(this.getFragShaderSource(!0)),this.wilsonHidden.gl.useProgram(this.wilsonHidden.render.shaderPrograms[0]),this.wilsonHidden.render.initUniforms(["radius","pointOpacity","metric"]),this.wilsonHidden.gl.uniform1f(this.wilsonHidden.uniforms.radius,this.radius),this.wilsonHidden.gl.uniform1f(this.wilsonHidden.uniforms.pointOpacity,1),this.wilsonHidden.gl.uniform1f(this.wilsonHidden.uniforms.metric,this.metric),this.maxRadius=this.findMaxRadius(),this.wilson.render.shaderPrograms=[],this.wilson.render.loadNewShader(this.getFragShaderSource()),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0]),this.wilson.render.initUniforms(["radius","pointOpacity","metric"]),this.wilson.gl.uniform1f(this.wilson.uniforms.radius,this.radius),this.wilson.gl.uniform1f(this.wilson.uniforms.pointOpacity,1),this.wilson.gl.uniform1f(this.wilson.uniforms.metric,this.metric);const t={t:-.1,pointOpacity:1};let i=!(this.currentlyAnimating=!0);this.cancelAnimaton(),this.cancelAnimaton=()=>{this.currentlyAnimating=!1,i=!0},anime({targets:t,t:1,pointOpacity:-.5,duration:3e3,delay:100,easing:"easeOutQuad",update:()=>{i||(this.t=t.t,this.pointOpacity=Math.max(t.pointOpacity,0),this.drawFrame())},complete:()=>{i||(this.currentlyAnimating=!1)}})}}getFragShaderSource(forHiddenCanvas=!1){var i=forHiddenCanvas?`
				if (minDistance < radius)
				{
					gl_FragColor = vec4(color, 1);
					return;
				}
			`:`
			if (minDistance < pointRadius)
			{
				gl_FragColor = mix(
					vec4(color, 1),
					vec4(1, 1, 1, 1),
					pointOpacity
				);
				return;
			}

			if (minDistance < (1.0 + blurRatio) * pointRadius)
			{
				float t = 1.0 - (minDistance - pointRadius) / (blurRatio * pointRadius);

				gl_FragColor = mix(
					vec4(color, 1),
					vec4(t, t, t, 1),
					pointOpacity
				);
				return;
			}

			if (minDistance < radius)
			{
				gl_FragColor = vec4(color, 1);
				return;
			}

			if (minDistance < radius + boundaryWidth)
			{
				gl_FragColor = vec4(color * 0.5, 1);
				return;
			}
		`;return`
			precision highp float;
			
			varying vec2 uv;

			uniform float radius;
			uniform float pointOpacity;
			uniform float metric;

			const float pointRadius = 0.01;
			const float blurRatio = 0.5;
			const float boundaryWidth = 0.02;

	${this.points.map((point,index)=>`
			const vec2 point${index} = ${getVectorGlsl(point)};
		`).join("")}

	${this.colors.map((color,index)=>`
			const vec3 color${index} = ${getVectorGlsl(color)};
		`).join("")}
			
			float metricDistance(vec2 p, vec2 q)
			{
				return pow(
					pow(abs(p.x - q.x), metric)
					+ pow(abs(p.y - q.y), metric),
					1.0 / metric
				);
			}

			float getMinDistanceToPoints(vec2 p, out vec3 color)
			{
	${this.points.map((point,index)=>`
			float distance${index+1} = metricDistance(p, point${index});
		`).join("")}

				float minDistance = ${getMinGlslString("distance",this.numPoints)};

	${this.colors.map((color,index)=>`
			if (minDistance == distance${index+1})
			{
				color = color${index};
				return minDistance;
			}
		`).join("")}
			}

			void main(void)
			{
				vec3 color;
				float minDistance = getMinDistanceToPoints(uv, color);

				${i}

				gl_FragColor = vec4(0, 0, 0, 1);
			}
		`}generatePoints(){this.points=new Array(this.numPoints);for(let n=0;n<this.numPoints;n++)this.points[n]=[.9*(Math.random()-.5)*this.wilson.worldWidth,.9*(Math.random()-.5)*this.wilson.worldHeight];var t,s=new Array(this.numPoints),i=.1/this.numPoints;for(let o=0;o<this.numPoints;o++){s[o]=[0,0];for(let i=0;i<this.numPoints;i++)i!==o&&(t=(this.points[i][0]-this.points[o][0])**2+(this.points[i][1]-this.points[o][1])**2,s[o][0]+=(this.points[o][0]-this.points[i][0])/t,s[o][1]+=(this.points[o][1]-this.points[i][1])/t)}for(let r=0;r<this.numPoints;r++)this.points[r][0]+=i*s[r][0],this.points[r][1]+=i*s[r][1],this.points[r][0]=Math.min(Math.max(this.points[r][0],-this.wilson.worldWidth/2),this.wilson.worldWidth/2),this.points[r][1]=Math.min(Math.max(this.points[r][1],-this.wilson.worldHeight/2),this.wilson.worldHeight/2);this.colors=new Array(this.numPoints);for(let e=0;e<this.numPoints;e++)this.colors[e]=this.wilson.utils.hsvToRgb(Math.random(),.5+.25*Math.random(),.5+.5*Math.random()),this.colors[e][0]/=255,this.colors[e][1]/=255,this.colors[e][2]/=255}findMaxRadius(){let i=.5;let t=.25;for(let n=0;n<10;n++){var s=2*i;this.testRadius(s)?9!==n&&(i-=t):i+=t,t/=2}return 2*i+.025}testRadius(radius){this.wilsonHidden.gl.uniform1f(this.wilsonHidden.uniforms.radius,radius),this.wilsonHidden.render.drawFrame();var i=this.wilsonHidden.render.getPixelData();for(let t=0;t<i.length;t+=4)if(0===i[t]&&0===i[t+1]&&0===i[t+2])return!1;return!0}drawFrame(){this.radius=this.t*this.maxRadius,this.wilson.gl.uniform1f(this.wilson.uniforms.radius,this.radius),this.wilson.gl.uniform1f(this.wilson.uniforms.pointOpacity,this.pointOpacity),this.wilson.render.drawFrame()}updateMetric(){this.cancelAnimaton(),this.t=2,this.wilson.gl.uniform1f(this.wilson.uniforms.metric,this.metric),this.drawFrame()}}export{VoronoiDiagram};