!function(){"use strict";let t=document.querySelector("#output-canvas").getContext("webgl"),e=document.querySelector("#output-canvas").offsetWidth,n=!1,o=0,r=0,a=!1,i=!1,c=!1,s=!1,l=!1,u=!1,m=0,_=!1,f=1,d=3.2954,v=1.9657,h=parseInt(document.querySelector("#dim-input").value||500),p=16,g=[],y=[],b=[],w=[],S=[4.2178,.8269,1.9065],x=2,A=.01,L=[[0,0,1],[.942809,0,-.333333],[-.471405,.816497,-.333333],[-.471405,-.816497,-.333333]],M=F([L[0][0]-L[1][0],L[0][1]-L[1][1],L[0][2]-L[1][2]]),P=F([L[0][0]-L[2][0],L[0][1]-L[2][1],L[0][2]-L[2][2]]),k=F([L[0][0]-L[3][0],L[0][1]-L[3][1],L[0][2]-L[3][2]]);R(),document.querySelector("#output-canvas").setAttribute("width",h),document.querySelector("#output-canvas").setAttribute("height",h),document.querySelector("#dim-input").addEventListener("input",function(){(h=parseInt(document.querySelector("#dim-input").value||500))<200&&(h=200);h>2e3&&(h=2e3);t.uniform1i(z.small_image_size_uniform,h),document.querySelector("#output-canvas").setAttribute("width",h),document.querySelector("#output-canvas").setAttribute("height",h),t.viewport(0,0,h,h),T()}),document.querySelector("#generate-high-res-image-button").addEventListener("click",function(){let e=h;h=parseInt(document.querySelector("#high-res-dim-input").value||2e3),document.querySelector("#output-canvas").setAttribute("width",h),document.querySelector("#output-canvas").setAttribute("height",h),t.viewport(0,0,h,h),T();let n=document.createElement("a");n.download="the-sierpinski-tetrahedron.png",n.href=document.querySelector("#output-canvas").toDataURL(),n.click(),n.remove(),h=e,document.querySelector("#output-canvas").setAttribute("width",h),document.querySelector("#output-canvas").setAttribute("height",h),t.viewport(0,0,h,h),T()}),window.addEventListener("resize",D),setTimeout(D,500),document.querySelector("#output-canvas").addEventListener("mousedown",function(t){n=!0,o=t.clientX,r=t.clientY}),document.querySelector("#output-canvas").addEventListener("mousemove",function(t){if(n){t.preventDefault();let n=t.clientX,a=t.clientY,i=n-o,c=a-r;if(Math.abs(i)>20||Math.abs(c)>20)return;(d+=i/e*Math.PI)>=2*Math.PI?d-=2*Math.PI:d<0&&(d+=2*Math.PI),(v-=c/e*Math.PI)>Math.PI-.01?v=Math.PI-.01:v<.01&&(v=.01),o=n,r=a,R(),T()}}),document.documentElement.addEventListener("mouseup",function(t){n=!1}),document.querySelector("#output-canvas").addEventListener("touchstart",function(t){o=t.touches[0].clientX,r=t.touches[0].clientY,2===t.touches.length?(l=!0,u=!1):3===t.touches.length&&(u=!0,l=!1)}),document.querySelector("#output-canvas").addEventListener("touchmove",function(t){t.preventDefault();let n=t.touches[0].clientX,a=t.touches[0].clientY,i=n-o,c=a-r;Math.abs(i)>20||Math.abs(c)>20||((d+=i/e*Math.PI)>=2*Math.PI?d-=2*Math.PI:d<0&&(d+=2*Math.PI),(v-=c/e*Math.PI)>Math.PI-.01?v=Math.PI-.01:v<.01&&(v=.01),o=n,r=a,R(),T())}),document.querySelector("#output-canvas").addEventListener("touchend",function(t){2===t.touches.length?(l=!0,u=!1):3===t.touches.length?(u=!0,l=!1):(l=!1,u=!1)}),document.documentElement.addEventListener("keydown",function(t){87===t.keyCode?a=!0:83===t.keyCode&&(i=!0),68===t.keyCode?c=!0:65===t.keyCode&&(s=!0),16===t.keyCode&&(_=!0)}),document.documentElement.addEventListener("keyup",function(t){87===t.keyCode?a=!1:83===t.keyCode&&(i=!1),68===t.keyCode?c=!1:65===t.keyCode&&(s=!1),16===t.keyCode&&(_=!1)}),setInterval(function(){(a||i||c||s||l||u)&&((m=f/60)<0&&(m=0),m>.02&&(m=.02),_&&(m*=3),a||l?(S[0]+=m*y[0],S[1]+=m*y[1],S[2]+=m*y[2]):(i||u)&&(S[0]-=m*y[0],S[1]-=m*y[1],S[2]-=m*y[2]),c?(S[0]+=m*b[0]/x,S[1]+=m*b[1]/x,S[2]+=m*b[2]/x):s&&(S[0]-=m*b[0]/x,S[1]-=m*b[1]/x,S[2]-=m*b[2]/x),R(),T())},8);const I="\n\t\tattribute vec3 position;\n\t\tvarying vec2 uv;\n\n\t\tvoid main(void)\n\t\t{\n\t\t\tgl_Position = vec4(position, 1.0);\n\n\t\t\t//Interpolate quad coordinates in the fragment shader.\n\t\t\tuv = position.xy;\n\t\t}\n\t",q="\n\t\tprecision highp float;\n\t\t\n\t\tvarying vec2 uv;\n\t\t\n\t\tuniform vec3 camera_pos;\n\t\tuniform vec3 image_plane_center_pos;\n\t\tuniform vec3 forward_vec;\n\t\tuniform vec3 right_vec;\n\t\tuniform vec3 up_vec;\n\t\t\n\t\tuniform float focal_length;\n\t\t\n\t\tconst vec3 light_pos = vec3(0.0, 0.0, 5.0);\n\t\tconst float light_brightness = 2.0;\n\t\t\n\t\tuniform int image_size;\n\t\tuniform int small_image_size;\n\t\t\n\t\t\n\t\t\n\t\tconst float clip_distance = 1000.0;\n\t\tconst int max_marches = 32;\n\t\tconst vec3 fog_color = vec3(0.0, 0.0, 0.0);\n\t\tconst float fog_scaling = .2;\n\t\tconst int num_sierpinski_iterations = 16;\n\t\t\n\t\t\n\t\tvec3 color;\n\t\t\n\t\tconst vec3 color_1 = vec3(1.0, 0.0, 0.0);\n\t\tconst vec3 color_2 = vec3(0.0, 1.0, 0.0);\n\t\tconst vec3 color_3 = vec3(0.0, 0.0, 1.0);\n\t\t\n\t\tconst vec3 vertex_0 = vec3(0.0, 0.0, 1.0);\n\t\tconst vec3 vertex_1 = vec3(.942809, 0.0, -.333333);\n\t\tconst vec3 vertex_2 = vec3(-.471405, .816497, -.333333);\n\t\tconst vec3 vertex_3 = vec3(-.471405, -.816497, -.333333);\n\t\t\n\t\tconst vec3 n1 = normalize(vertex_0 - vertex_1);\n\t\tconst vec3 n2 = normalize(vertex_0 - vertex_2);\n\t\tconst vec3 n3 = normalize(vertex_0 - vertex_3);\n\t\t\n\t\t\n\t\t\n\t\tfloat distance_estimator(vec3 pos)\n\t\t{\n\t\t\tvec3 mutable_pos = pos;\n\t\t\t\n\t\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t\t\tfloat color_scale = .5;\n\t\t\t\n\t\t\t\n\t\t\t//We'll find the closest vertex, scale everything by a factor of 2 centered on that vertex (so that we don't need to recalculate the vertices), and repeat.\n\t\t\tfor (int iteration = 0; iteration < num_sierpinski_iterations; iteration++)\n\t\t\t{\n\t\t\t\t//Fold space over on itself so that we can reference only the top vertex.\n\t\t\t\tfloat t1 = dot(mutable_pos, n1);\n\t\t\t\t\n\t\t\t\tif (t1 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t1 * n1;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t2 = dot(mutable_pos, n2);\n\t\t\t\t\n\t\t\t\tif (t2 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t2 * n2;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfloat t3 = dot(mutable_pos, n3);\n\t\t\t\t\n\t\t\t\tif (t3 < 0.0)\n\t\t\t\t{\n\t\t\t\t\tmutable_pos -= 2.0 * t3 * n3;\n\t\t\t\t\t\n\t\t\t\t\tcolor = (1.0 - color_scale) * color + color_scale * color_3;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//Scale the system -- this one takes a fair bit of thinking to get. What's happening here is that we're stretching from a vertex, but since we never scale the vertices, the four new ones are the four closest to the vertex we scaled from. Now (x, y, z) will get farther and farther away from the origin, but that makes sense -- we're really just zooming in on the tetrahedron.\n\t\t\t\tmutable_pos = 2.0 * mutable_pos - vec3(0.0, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcolor_scale *= .5;\n\t\t\t}\n\t\t\t\n\t\t\treturn length(mutable_pos) * pow(.5, float(num_sierpinski_iterations));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 get_surface_normal(vec3 pos)\n\t\t{\n\t\t\tfloat e = .00001;\n\t\t\t\n\t\t\tfloat base = distance_estimator(pos);\n\t\t\t\n\t\t\tfloat x_step = distance_estimator(pos + vec3(e, 0.0, 0.0));\n\t\t\tfloat y_step = distance_estimator(pos + vec3(0.0, e, 0.0));\n\t\t\tfloat z_step = distance_estimator(pos + vec3(0.0, 0.0, e));\n\t\t\t\n\t\t\treturn normalize(vec3(x_step - base, y_step - base, z_step - base));\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvec3 compute_shading(vec3 pos, int iteration)\n\t\t{\n\t\t\tvec3 surface_normal = get_surface_normal(pos);\n\t\t\t\n\t\t\tvec3 light_direction = normalize(light_pos - pos);\n\t\t\t\n\t\t\tfloat light_intensity = light_brightness * dot(surface_normal, light_direction);\n\t\t\t\n\t\t\t//The last factor adds ambient occlusion.\n\t\t\tcolor = color * light_intensity * max((1.0 - float(iteration) / float(max_marches)), 0.0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//Apply fog.\n\t\t\tfloat distance_from_camera = length(pos - camera_pos);\n\t\t\t\n\t\t\tfloat fog_amount = 1.0 - exp(-distance_from_camera * fog_scaling);\n\t\t\t\n\t\t\treturn (1.0 - fog_amount) * color + fog_amount * fog_color;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tvoid main(void)\n\t\t{\n\t\t\tvec3 start_pos = image_plane_center_pos + right_vec * uv.x + up_vec * uv.y;\n\t\t\t\n\t\t\t//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.\n\t\t\tvec3 ray_direction_vec = normalize(start_pos - camera_pos) * .9;\n\t\t\t\n\t\t\tvec3 final_color = fog_color;\n\t\t\t\n\t\t\tfloat t = 0.0;\n\t\t\t\n\t\t\tfloat epsilon = .00002;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor (int iteration = 0; iteration < max_marches; iteration++)\n\t\t\t{\n\t\t\t\tvec3 pos = start_pos + t * ray_direction_vec;\n\t\t\t\t\n\t\t\t\tfloat distance = distance_estimator(pos);\n\t\t\t\t\n\t\t\t\t//This lowers the detail far away, which makes everything run nice and fast.\n\t\t\t\tif (image_size == small_image_size && distance / 150.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 150.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (image_size != small_image_size && distance / 500.0 > epsilon)\n\t\t\t\t{\n\t\t\t\t\tepsilon = distance / 500.0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (distance < epsilon)\n\t\t\t\t{\n\t\t\t\t\tfinal_color = compute_shading(pos, iteration);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse if (t > clip_distance)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tt += distance;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tgl_FragColor = vec4(final_color.xyz, 1.0);\n\t\t}\n\t";let z=null;function E(){let e=C(t,t.VERTEX_SHADER,I),n=C(t,t.FRAGMENT_SHADER,q);z=t.createProgram(),t.attachShader(z,e),t.attachShader(z,n),t.linkProgram(z),t.getProgramParameter(z,t.LINK_STATUS)||(console.log(`Couldn't link shader program: ${t.getShaderInfoLog(shader)}`),t.deleteProgram(z)),t.useProgram(z);let o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,0,-1,1,0,1,-1,0,1,1,0]),t.STATIC_DRAW),z.position_attribute=t.getAttribLocation(z,"position"),t.enableVertexAttribArray(z.position_attribute),t.vertexAttribPointer(z.position_attribute,3,t.FLOAT,!1,0,0),z.image_size_uniform=t.getUniformLocation(z,"image_size"),z.small_image_size_uniform=t.getUniformLocation(z,"small_image_size"),z.camera_pos_uniform=t.getUniformLocation(z,"camera_pos"),z.image_plane_center_pos_uniform=t.getUniformLocation(z,"image_plane_center_pos"),z.forward_vec_uniform=t.getUniformLocation(z,"forward_vec"),z.right_vec_uniform=t.getUniformLocation(z,"right_vec"),z.up_vec_uniform=t.getUniformLocation(z,"up_vec"),z.focal_length_uniform=t.getUniformLocation(z,"focal_length"),z.epsilon_uniform=t.getUniformLocation(z,"epsilon"),t.viewport(0,0,h,h),t.uniform1i(z.small_image_size_uniform,h),T()}function C(t,e,n){let o=t.createShader(e);return t.shaderSource(o,n),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)||(console.log(`Couldn't load shader: ${t.getProgramInfoLog(shaderProgram)}`),t.deleteShader(o)),o}function T(){t.uniform1i(z.image_size_uniform,h),t.uniform3fv(z.camera_pos_uniform,S),t.uniform3fv(z.image_plane_center_pos_uniform,g),t.uniform3fv(z.forward_vec_uniform,y),t.uniform3fv(z.right_vec_uniform,b),t.uniform3fv(z.up_vec_uniform,w),t.uniform1f(z.focal_length_uniform,x),t.uniform1f(z.epsilon_uniform,A),t.drawArrays(t.TRIANGLE_STRIP,0,4)}function R(){var t,e;y=[Math.cos(d)*Math.sin(v),Math.sin(d)*Math.sin(v),Math.cos(v)],b=F([y[1],-y[0],0]),e=y,w=[(t=b)[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]],f=function(t,e,n){for(let o=0;o<p;o++){let o=U([t,e,n],M);o<0&&(t-=2*o*M[0],e-=2*o*M[1],n-=2*o*M[2]);let r=U([t,e,n],P);r<0&&(t-=2*r*P[0],e-=2*r*P[1],n-=2*r*P[2]);let a=U([t,e,n],k);a<0&&(t-=2*a*k[0],e-=2*a*k[1],n-=2*a*k[2]),t*=2,e*=2,n=2*n-1}return Math.sqrt(t*t+e*e+n*n)*Math.pow(2,-p)}(S[0],S[1],S[2]),x=f/2,b[0]*=x/2,b[1]*=x/2,w[0]*=x/2,w[1]*=x/2,w[2]*=x/2,g=[S[0]+x*y[0],S[1]+x*y[1],S[2]+x*y[2]]}function U(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function F(t){let e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/e,t[1]/e,t[2]/e]}function D(){e=document.querySelector("#output-canvas").offsetWidth}load_script("/scripts/gl-matrix.min.js").then(function(){setTimeout(E,500)})}();