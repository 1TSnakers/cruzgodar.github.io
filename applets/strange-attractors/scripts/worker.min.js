"use strict";let gridSize=null,sigma=null,rho=null,beta=null,maximumSpeed=null,pixels=[];const boxSize=50,dt=5e-4,minZ=0;let stepsPerColor=5e3,numColors=null,currentX=1,currentY=1,currentZ=25,currentRow=null,currentCol=null;async function drawLorenzAttractor(){let r=0,e=0;for(numColors=gridSize;0<stepsPerColor;){r===stepsPerColor&&(postMessage([pixels,HSVtoRGB(e/numColors/6.5,1,1)]),pixels=[],e++,r=0,stepsPerColor-=2*Math.floor(5e3/numColors),maximumSpeed||await new Promise(resolve=>setTimeout(resolve,8)));var t=currentZ-minZ-boxSize/2;currentCol=Math.floor((currentX+boxSize/2)/boxSize*gridSize),0<=(currentRow=Math.floor((1-(t+boxSize/2)/boxSize)*gridSize))&&0<=currentCol&&currentRow<gridSize&&currentCol<gridSize&&pixels.push([currentRow,currentCol]),currentX+=sigma*(currentY-currentX)*dt,currentY+=(currentX*(rho-currentZ)-currentY)*dt,currentZ+=(currentX*currentY-beta*currentZ)*dt,r++}}function HSVtoRGB(h,s,v){let r,e,t;var o=Math.floor(6*h),n=6*h-o,u=v*(1-s),a=v*(1-n*s),l=v*(1-(1-n)*s);switch(o%6){case 0:r=v,e=l,t=u;break;case 1:r=a,e=v,t=u;break;case 2:r=u,e=v,t=l;break;case 3:r=u,e=a,t=v;break;case 4:r=l,e=u,t=v;break;case 5:r=v,e=u,t=a}return[Math.round(255*r),Math.round(255*e),Math.round(255*t)]}onmessage=e=>{gridSize=e.data[0],sigma=e.data[1],rho=e.data[2],beta=e.data[3],maximumSpeed=e.data[4],drawLorenzAttractor()};