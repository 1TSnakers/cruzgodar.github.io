<!DOCTYPE html><html lang="en"><head><title>Part 5: Fullscreen</title><meta property="og:title" content="Part 5: Fullscreen"/><meta property="og:type" content="website"/><meta property="og:url" content="https://cruzgodar.com/projects/wilson/guide/5-fullscreen/"/><meta property="og:image" content="https://cruzgodar.com/projects/wilson/guide/5-fullscreen/cover.webp"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Cruz Godar"/><style>body {opacity: 0;}</style></head><body><noscript><p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p></noscript><header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.png" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Part 5: Fullscreen</h1></header><main><section><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div><p class="body-text">Next on the list is making better use of screen space. While JavaScript has a built-in fullscreen API, it&#x2019;s often problematic for use with applets &mdash; it streches the content to fill the screen whether we want it to or not, and it renders any interactivity effectively unusable on mobile, since swiping down always exits fullscreen. Wilson provides its own toolkit to help with this &mdash; let&#x2019;s have a look at how it works.</p><p class="body-text">As usual, we need to update the options. The bare minimum is adding <code>useFullscreen: true</code>, but on its own, we have to handle entering and exiting fullscreen on our own using <code>wilson.fullscreen.switchFullscreen()</code>. Instead, we can add the line <code>useFullscreenButton: true</code>, and Wilson will place a small button in the top-right of our canvas that enters or exits fullscreen when pressed. We also need to tell Wilson where the icons for that button are located &mdash; we can use our own icons, but let&#x2019;s stick with the deafults.</p><pre><code class="language-js">let options =
{
&#9;renderer: "gpu",
&#9;
&#9;shader: fragShaderSource,
&#9;
&#9;canvasWidth: 1000,
&#9;canvasHeight: 1000,
&#9;
&#9;worldWidth: 4,
&#9;worldHeight: 4,
&#9;worldCenterX: 0,
&#9;worldCenterY: 0,
&#9;
&#9;
&#9;
&#9;useDraggables: true,
&#9;
&#9;draggablesMousemoveCallback: onDrag,
&#9;draggablesTouchmoveCallback: onDrag,
&#9;
&#9;
&#9;
&#9;useFullscreen: true,
&#9;
&#9;useFullscreenButton: true,
&#9;
&#9;enterFullscreenButtonIconPath: "/path/to/enter-fullscreen.png",
&#9;exitFullscreenButtonIconPath: "/path/to/exit-fullscreen.png"
};
</code></pre><div class="text-boxes"><div class="text-box-container"><input id="resolution-1-input" class="text-box" type="text" value="1000" tabindex="1"><p class="body-text text-box-subtext">Resolution</p></div></div><div class="center-content"><div id="canvas-landscape-middle"><p class="body-text">&#9;<canvas id="output-canvas-1" class="output-canvas"></canvas></p><p class="body-text">&#9;<canvas id="hidden-canvas-1" class="hidden-canvas"></canvas></p></div></div><div class="text-buttons"><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-1-button" tabindex="-1">Download</button></div></div></section><h2 class="section-text"> True Fullscreen</h2><section><p class="body-text">This is definitely an improvement, but if you mess with it a little, you&#x2019;ll quickly realize it&#x2019;s not actually doing that much differently &mdash; the canvas is still a square, and we can&#x2019;t move the draggable outside of it. The output fits inside of that square nicely, but if it weren&#x2019;t dark around the edges, the border would be much more apparent. To actually take advantage of the all the screen space available, we&#x2019;ll need to modify our shader and Wilson&#x2019;s options.</p><pre><code class="language-glsl">let fragShaderSource = ;
</code></pre><pre><code class="language-js">let options =
{
&#9;...
&#9;
&#9;useFullscreen: true,
&#9;
&#9;trueFullscreen: true,
&#9;
&#9;useFullscreenButton: true,
&#9;
&#9;enterFullscreenButtonImagePath: "/path/to/enter-fullscreen.png",
&#9;exitFullscreenButtonImagePath: "/path/to/exit-fullscreen.png"
};
</code></pre><pre><code class="language-js">wilson.render.initUniforms(["aspectRatio", "a", "b", "brightnessScale"]);
wilsonHidden.render.initUniforms(["aspectRatio", "a", "b", "brightnessScale"]);
</code></pre><pre><code>let aspectRatio = 1;

//Render the first frame.
wilson.gl.uniform1f(wilson.uniforms["aspectRatio"], 1);
wilsonHidden.gl.uniform1f(wilsonHidden.uniforms["aspectRatio"], 1);

window.requestAnimationFrame(drawJuliaSet);
</code></pre><p class="body-text">Now we&#x2019;re prepared for a canvas that isn&#x2019;t square, but we need to actually resize the canvas whenever we enter or exit fullscreen. We can update the options once again to add a callback function that&#x2019;s called whenever this happens, and on our end, we can add a listener to resize the canvas whenever we get a resize event from the window. We&#x2019;ll increase either the world width or height, rather than decrease anything, to ensure that we don&#x2019;t have a smaller view in fullscreen than windowed mode, and we&#x2019;ll do the exact opposite when adjusting the canvas width and height, so that fullscreen never renders more pixels than windowed. This way, extremely narrow aspect ratios will still show the entire Julia set, but won&#x2019;t try to render massive resolutions. This is also the reasoning for the strange-looking calculation of <code>z</code> in the shader.</p><pre><code class="language-js">let options =
{
&#9;...
&#9;
&#9;useFullscreen: true,
&#9;
&#9;trueFullscreen: true,
&#9;
&#9;useFullscreenButton: true,
&#9;
&#9;enterFullscreenButtonImagePath: "/path/to/enter-fullscreen.png",
&#9;exitFullscreenButtonImagePath: "/path/to/exit-fullscreen.png",
&#9;
&#9;switchFullscreenCallback: changeAspectRatio
};
</code></pre><pre><code class="language-js">function drawJuliaSet(timestamp)
{
&#9;...
&#9;
&#9;wilson.gl.uniform1f(wilson.uniforms["aspectRatio"], aspectRatio);
&#9;
&#9;wilson.gl.uniform1f(wilson.uniforms["a"], a);
&#9;wilson.gl.uniform1f(wilson.uniforms["b"], b);
&#9;wilson.gl.uniform1f(wilson.uniforms["brightnessScale"], brightnessScale);
&#9;
&#9;wilson.render.drawFrame();
}
</code></pre><pre><code class="language-js">function changeAspectRatio()
{
&#9;if (wilson.fullscreen.currentlyFullscreen)
&#9;{
&#9;aspectRatio = window.innerWidth / window.innerHeight;
&#9;
&#9;if (aspectRatio >= 1)
&#9;{
&#9;&#9;wilson.changeCanvasSize(resolution, Math.floor(resolution / aspectRatio));
&#9;&#9;
&#9;&#9;wilson.worldWidth = 4 * aspectRatio;
&#9;&#9;wilson.worldHeight = 4;
&#9;}
&#9;
&#9;else
&#9;{
&#9;&#9;wilson.changeCanvasSize(Math.floor(resolution * aspectRatio), resolution);
&#9;&#9;
&#9;&#9;wilson.worldWidth = 4;
&#9;&#9;wilson.worldHeight = 4 / aspectRatio;
&#9;}
&#9;}
&#9;
&#9;else
&#9;{
&#9;wilson.changeCanvasSize(resolution, resolution);
&#9;
&#9;wilson.worldWidth = 4;
&#9;wilson.worldHeight = 4;
&#9;}
&#9;
&#9;window.requestAnimationFrame(drawJuliaSet);
}

window.addEventListener("resize", changeAspectRatio);
</code></pre><p class="body-text">Note that it would be a bad idea to resize the hidden canvas along with the visible one here &mdash; if we did that, we&#x2019;d get more dark pixels in narrow aspect ratios, so the brightness scale would jump up unnaturally when we entered fullscreen or narrowed the window.</p><div class="text-boxes"><div class="text-box-container"><input id="resolution-2-input" class="text-box" type="text" value="1000" tabindex="1"><p class="body-text text-box-subtext">Resolution</p></div></div><div class="center-content"><div id="canvas-landscape-middle"><canvas id="output-canvas-2" class="output-canvas"></canvas><canvas id="hidden-canvas-2" class="hidden-canvas"></canvas></div></div><div class="text-buttons"><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-2-button" tabindex="-1">Download</button></div></div><div style="height: 32px"></div><p class="body-text">Now <em>this</em> is a Julia set explorer! We could call this done this as-is, but there&#x2019;s one last improvement we can make: adding the ability to pan and zoom into the fractals. In the next section, we&#x2019;ll make the canvas itself interactive, so that we can zoom in with controls that feel as natural as native ones.</p><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/5-fullscreen/scripts/index.js">here</a>. </p><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div></section></main><script src="/scripts/init.min.js"></script></body></html>