<head><title>Wilson: A Guide</title></head>

<div style="height: 5vh"></div>

<noscript>
	<p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p>
</noscript>



!header Wilson: A Guide



!begin-text-block
	
	In this guide, we&#x2019;ll use Wilson to create the Julia set explorer featured on the main page. We&#x2019;ll do this one step at a time, starting with the simplest and most stripped-down version possible and gradually adding features. In every JS code block, properties and methods defined by Wilson are bolded &mdash; click on one to pull up its documentation.
	
	First, some background: a Julia set is a famous type of fractal closely related to the Mandelbrot set. Unlike the Mandelbrot, though, there are infinitely many Julia sets, each one corresponding to a different complex number. Because of this, Julia set applets often focus on generating different Julia sets rather than zooms of a single one, and this is where we&#x2019;ll start too. Right now, let&#x2019;s not worry about interactivity: we&#x2019;ll just have the user enter the complex number \(c\) and display the Julia set corresponding to it.
	
	Once we&#x2019;ve included wilson.js, we need to make a canvas and some input fields in the HTML.
	
!end-text-block



<pre><code class="language-html" data-aos="fade-up">&lt;input id="a-input" type="text" value="0"&gt;
&lt;label for="a-input"&gt;
&#9;&lt;p&gt;a&lt;/p&gt;
&lt;/label&gt;

&lt;input id="b-input" type="text" value="1"&gt;
&lt;label for="b-input"&gt;
&#9;&lt;p&gt;b&lt;/p&gt;
&lt;/label&gt;

&lt;input id="resolution-input" type="text" value="500"&gt;
&lt;label for="resolution-input"&gt;
&#9;&lt;p&gt;Resolution&lt;/p&gt;
&lt;/label&gt;

&lt;button id="generate-button" type="button"&gt;Generate&lt;/button&gt;

&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;</code></pre>



<br>



!begin-text-block
	
	This obviously doesn&#x2019;t look too great. The displayed canvases and input fields on this page will be styled, but the CSS will be omitted for brevity.
	
	On the JS side, we need to tell Wilson we want it to work with this canvas.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;renderer: "cpu"
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);

document.querySelector("#generate-button").addEventListener("click", () =>
{
&#9;let a = parseFloat(document.querySelector("#a-input").value || 0);
&#9;let b = parseFloat(document.querySelector("#b-input").value || 1);
&#9;let resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;
&#9;//Do something with a and b
});

</code></pre>



<br>



!begin-text-block
	
	Those initial values of 500 are just placeholders &mdash; we change them whenever the generate button is pressed. Now we just need to write a function that generates a Julia set given these parameters. For that function, we&#x2019;ll need to convert between pixel coordinates on the canvas and complex numbers in the plane. This is a common enough occurance in math applets that Wilson has built-in functions for handling it: we need to add information in the options about the &#x201C;world coordinates&#x201D;, as Wilson calls them, and then we can call <code>wilson.utils.interpolate.canvas_to_world</code> and <code>wilson.utils.interpolate.world_to_canvas</code>, which convert between pairs (row, col) of canvas coordinates and (x, y) of world coordinates. Note that <code>row</code> increases from top to bottom, while <code>y</code> does the opposite.
	
	The algorithm to color a single point \(z_0\) of the Julia set corresponding to \(c = a + bi\) is relatively simple: with \(f(z) = z^2 + c\), we let \(z_1 = f(z_0)\), \(z_2 = f(z_1)\), and so on. If the \(z_n\) grow without bound, then the point \(z_0\) is <em>not</em> in the Julia set, and we give it a color based on how quickly it grew. If the \(z_n\) stay bounded, then \(z_0\) is in the set, and we color it black. In practice, we pick a maximum value for \(n\), say 50, and see if the sequence is smaller than a certain bound after that many iterations. It can be shown that if the magnitude of any \(z_n\) is ever larger than 2, then the subsequent terms will grow without bound, so that&#x2019;s the typical threshhold to measure against.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;renderer: "cpu",
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0
};</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">function generate_julia_set(a, b, resolution)
{
&#9;let brightnesses = new Array(resolution * resolution);
&#9;let max_brightness = 0;
&#9;let brightness_scale = 1.5;
&#9;const num_iterations = 50;
&#9;
&#9;for (let i = 0; i &lt; resolution; i++)
&#9;{
&#9;&#9;for (let j = 0; j &lt; resolution; j++)
&#9;&#9;{
&#9;&#9;&#9;let world_coordinates = wilson.utils.interpolate.canvas_to_world(i, j);
&#9;&#9;&#9;let x = world_coordinates[0];
&#9;&#9;&#9;let y = world_coordinates[1];
&#9;&#9;&#9;
&#9;&#9;&#9;//This helps remove color banding.
&#9;&#9;&#9;let brightness = Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;&#9;
&#9;&#9;&#9;let k = 0;
&#9;&#9;&#9;
&#9;&#9;&#9;for (k = 0; k &lt; num_iterations; k++)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;//z = z^2 + c = (x^2 - y^2 + a) + (2xy + b)i
&#9;&#9;&#9;&#9;let temp = x*x - y*y + a;
&#9;&#9;&#9;&#9;y = 2*x*y + b;
&#9;&#9;&#9;&#9;x = temp;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;brightness += Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if (x*x + y*y > 4)
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;break;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;if (k === num_iterations)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;//Color this pixel black.
&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = 0;
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = brightness;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if (brightness > max_brightness)
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;max_brightness = brightness;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;}
&#9;&#9;}
&#9;}
&#9;
&#9;//Now we need to create the actual pixel data in a Uint8ClampedArray to pass to Wilson.
&#9;let image_data = new Uint8ClampedArray(resolution * resolution * 4);
&#9;for (let i = 0; i &lt; resolution * resolution; i++)
&#9;{
&#9;&#9;image_data[4 * i] = 0; //Red
&#9;&#9;image_data[4 * i + 1] = brightness_scale * brightnesses[i] / max_brightness * 255; //Green
&#9;&#9;image_data[4 * i + 2] = brightness_scale * brightnesses[i] / max_brightness * 255; //Blue
&#9;&#9;image_data[4 * i + 3] = 255; //Alpha
&#9;}
&#9;
&#9;return image_data;
}</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">document.querySelector("#generate-button").addEventListener("click", () =>
{
&#9;let a = parseFloat(document.querySelector("#a-input").value || 0);
&#9;let b = parseFloat(document.querySelector("#b-input").value || 1);
&#9;let resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;
&#9;wilson.render.draw_frame(generate_julia_set(a, b, resolution));
});</code></pre>



<br>



!begin-text-block
	
	The weirdness with the exponentials is a technique to reduce color banding &mdash; if we just used the raw iteration numbers for brightness values, we'd see stripes of different brightness wherever that number increased or decreased by one. Basing the color partly on the values of the \(z_n\) introduces dithering &mdash; just enough noise that the color bands are blurred out.
	
	The only other thing to explain is the brightness scale variable. When we make Julia set renders, there will typically be a handful of pixels that are significanly brighter than the rest, resulting in a much darker image overall. This is hard to exactly counteract without sorting the list of brightnesses and picking one a little bit down from the top, but that requires a massive sort every frame. Instead, we can get a good result by just finding a factor experimentally that gets the majority of the pixels in full range of 0&ndash;255.
	
	With that explanation out of the way, let&#x2019;s see how the applet turned out!
	
!end-text-block



<br>

!begin-text-boxes
	
	a-1 0 \(a\)
	
	b-1 1 \(b\)
	
	resolution-1 500 Resolution
	
!end-text-boxes



!begin-text-buttons
	
	generate-1 Generate
	
!end-text-buttons



<canvas id="output-canvas-1" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s A Different Renderer

<br>

!begin-text-block
	
	This is a great start, but we have a lot more to do. The first and easiest change to make is to modify the renderer. We currently have the line <code>renderer: "cpu"</code> in our options, which means that when we pass Wilson our pixel data, it gets copied into the canvas by JavaScript. A slightly better alternative is to render the canvas with WebGL and pass in the pixel data as a texture. This can marginally increase performance, and on some browers, it also increases the maximum possible canvas size. WebGL might sound a little daunting, and rightfully so, but we don&#x2019;t actually have to interface with it all right now. Just replacing that line in the options with <code>renderer: "hybrid"</code> is enough to change everything necessary on the backend.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;renderer: "hybrid",
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0
};</code></pre>



<br>

!begin-text-boxes
	
	a-2 0 \(a\)
	
	b-2 1 \(b\)
	
	resolution-2 500 Resolution
	
!end-text-boxes



!begin-text-buttons
	
	generate-2 Generate
	
!end-text-buttons



<canvas id="output-canvas-2" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s Draggables

<br>

!begin-text-block
	
	Since every Julia set corresponds to a unique complex number \(c\), we should be able to use the canvas for choosing \(c\) and displaying its Julia set at the same time. Wilson provides a type of element for this, called a &#x201C;draggable&#x201D;. We can add any number of them to a canvas, but right now, we only need one. To get these set up, we first need to modify our options once again. After that, we can add a draggable at any time.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;renderer: "hybrid",
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);

let draggable = wilson.draggables.add(0, 1);</code></pre>



<br>

!begin-text-block
	
	We now have a little while circle that can be freely dragged around the canvas. The style can be customized by modifying <code>.wilson-draggable</code>, but let&#x2019;s just stick with the default. The element is returned from <code>wilson.draggables.add</code> and also has a class of <code>wilson-draggable-0</code> if we want to reference it in the future. Note that <code>wilson.draggables.add</code> accepts world coordinates, not canvas ones.
	
	Now we have to actually do something with this draggable, which is accomplished by passing callback functions in the Wilson options. The index of the current draggable being moved is passed to the callback, as well as the world coordinates and the original event that was captured in case we need to do anything with that. Here, we&#s2019;d like to have callbacks for grabbing the draggable, moving it, and letting it go &mdash; we&#x2019;ll render low resolution frames while dragging so that the framerate stays high, then a single higher resolution frame when we let go.
	
	We&#x2019;ll no longer need the input fields for \(a\) and \(b\) &mdash; just the one for resolution. It&#x2019;d be a little awkward to have to press the generate button just to change the resolution, so instead we&#x2019;ll add a listener to that field and update the variables as needed.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;renderer: "hybrid",
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true,
&#9;
&#9;draggables_mousedown_callback: on_grab,
&#9;draggables_mousemove_callback: on_drag,
&#9;draggables_mouseup_callback: on_release,
&#9;
&#9;draggables_touchstart_callback: on_grab,
&#9;draggables_touchmove_callback: on_drag,
&#9;draggables_touchend_callback: on_release
};



let wilson = new Wilson(document.querySelector("#output-canvas"), options);
	
let draggable = wilson.draggables.add(0, 1);



let large_resolution = 500;
let small_resolution = 100;

document.querySelector("#resolution-input").addEventListener("input", () =>
{
&#9;large_resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;small_resolution = Math.floor(large_resolution / 5);
});

//Render the inital frame.
wilson.change_canvas_size(small_resolution, small_resolution);
wilson.render.draw_frame(generate_julia_set(0, 1, small_resolution));



function on_grab(active_draggable, x, y, event)
{
&#9;wilson.change_canvas_size(small_resolution, small_resolution);
}

function on_drag(active_draggable, x, y, event)
{
&#9;wilson.render.draw_frame(generate_julia_set(x, y, small_resolution));
}

function on_release_3(active_draggable, x, y, event)
{
&#9;wilson.change_canvas_size(large_resolution, large_resolution);
&#9;wilson.render.draw_frame(generate_julia_set(x, y, large_resolution));
}</code></pre>



<br>



!begin-text-boxes
	
	resolution-3 500 Resolution
	
!end-text-boxes



<canvas id="output-canvas-3" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s Parallelizing

<br>

!begin-text-block
	
	Now we&#x2019;re getting somewhere! There are a handful of features we could build in next, but we&#x2019;re overdue for one in particular: moving the math onto the GPU. This is called <em>parallelizing</em>, and it&#x2019;s not something that&#x2019;s possible for every applet: every pixel will be processed independently of every other, so information cannot be shared between them. For example, an applet that renders an iterated function system by tracking the orbit of a single point across millions of iterations will not lend itself well to parallelization. A Julia sets, on the other hand, is a perfect candidate.
	
	The technology for GPU-based applets on the web is called WebGL. Traditionally, it&#x2019;s used for 3D applets and games that use raster graphics. Wilson does <em>not</em> support any of that &mdash; if you need high-performance raster graphics, look to something like <a href="https://threejs.org" onclick="Page.Navigation.redirect('https://threejs.org', true)">three.js</a> instead. What Wilson provides is a stripped-down environment where getting WebGL working only requires a fragment shader, something that is normally not easy.
	
	Writing that fragment shader can be challenging, though &mdash; it&#x2019;s not written in JavaScript, but rather in a language called GLSL that&#x2019;s very unforgiving &mdash; writing a number as 3 instead of 3.0 or 3. will most likely cause the entire program to crash with a generic error message and no ability to debug. Writing GLSL is an exerise in extreme caution and frequent testing, but the upshot is massively improved performance &mdash; it&#x2019;s not at all uncommon to see a 10x jump in the number of pixels that can be rendered per frame, though this of course depends on the relative power of the CPU and the GPU. If your applet is parallelizable, you should at least try to get it working in GLSL.
	
	To get started, we&#x2019;ll change the renderer setting once again, this time to <code>renderer: "gpu"</code>. After that, we need to write our shader, tell Wilson what uniforms (i.e. parameters) the shader has, and then change some of our existing code to set those variables properly. Let&#x2019;s take this one step at a time, starting with the shader.
	
!end-text-block



<pre><code class="language-glsl" data-aos="fade-up">precision highp float;

varying vec2 uv;

uniform float box_size_halved;
uniform float a;
uniform float b;
uniform float brightness_scale;



void main(void)
{
	vec2 z = vec2(uv.x * 2.0, uv.y * 2.0);
	vec3 color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
	float brightness = exp(-length(z));
	
	
	
	vec2 c = vec2(a, b);
	
	for (int iteration = 0; iteration &lt; 50; iteration++)
	{
		if (iteration == 49)
		{
			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			return;
		}
		
		if (length(z) >= 2.0)
		{
			break;
		}
		
		z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
		
		brightness += exp(-length(z));
	}
	
	
	gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
}</code></pre>



!footer



<script>
	if (typeof Page === "undefined")
	{
		window.location.replace("/index-testing.html?page=" + encodeURIComponent(window.location.pathname));
	}
	
	
	
	Page.settings = 
	{
		"title": "Wilson: A Guide",
		
		"math_page": true,
		
		"small_margins_on_ultrawide": true
	};
	
	Page.load();
</script>