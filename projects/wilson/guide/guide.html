<head><title>Wilson: A Guide</title></head>

<div style="height: 5vh"></div>

<noscript>
	<p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p>
</noscript>



!header Wilson: A Guide



!begin-text-block
	
	Welcome! In this guide, we&#x2019;ll use Wilson to create the Julia set explorer featured on the main page. We&#x2019;ll do this one step at a time, starting with the simplest and most stripped-down version possible and gradually adding features. In every JS code block, properties and methods defined by Wilson are bolded &mdash; click on one to pull up its documentation.
	
	First, some background: a Julia set is a famous type of fractal closely related to the Mandelbrot set. Unlike the Mandelbrot, though, there are infinitely many Julia sets, each one corresponding to a different complex number. Because of this, Julia set applets often focus on generating different Julia sets rather than zooms of a single one, and this is where we&#x2019;ll start too. Right now, let&#x2019;s not worry about interactivity: we&#x2019;ll just have the user enter the complex number \(c\) and display the Julia set corresponding to it.
	
	Once we&#x2019;ve included wilson.js, we need to make a canvas and some input fields in the HTML.
	
!end-text-block



<pre><code class="language-html" data-aos="fade-up">&lt;input id="a-input" type="text" value="0"&gt;
&lt;label for="a-input"&gt;
&#9;&lt;p&gt;a&lt;/p&gt;
&lt;/label&gt;

&lt;input id="b-input" type="text" value="1"&gt;
&lt;label for="b-input"&gt;
&#9;&lt;p&gt;b&lt;/p&gt;
&lt;/label&gt;

&lt;input id="resolution-input" type="text" value="500"&gt;
&lt;label for="resolution-input"&gt;
&#9;&lt;p&gt;Resolution&lt;/p&gt;
&lt;/label&gt;

&lt;button id="generate-button" type="button"&gt;Generate&lt;/button&gt;

&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;</code></pre>



<br>



!begin-text-block
	
	This obviously doesn&#x2019;t look too great without any added CSS. The displayed canvases and input fields on this page will be styled, but the CSS will be omitted for brevity.
	
	On the JS side, we need to tell Wilson we want it to work with this canvas.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "cpu",
&#9;
&#9;canvas_width: 500,
&#9;canvas_height: 500
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);

document.querySelector("#generate-button").addEventListener("click", () =>
{
&#9;let a = parseFloat(document.querySelector("#a-input").value || 0);
&#9;let b = parseFloat(document.querySelector("#b-input").value || 1);
&#9;let resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;
&#9;//Do something with a and b
});</code></pre>



<br>



!begin-text-block
	
	Those initial values of 500 are just placeholders &mdash; we change them whenever the generate button is pressed. Now we just need to write a function that generates a Julia set given these parameters. For that function, we&#x2019;ll need to convert between pixel coordinates on the canvas and complex numbers in the plane. This is a common enough occurance in math applets that Wilson has built-in functions for handling it: we need to add information in the options about the &#x201C;world coordinates&#x201D;, as Wilson calls them, and then we can call <code>wilson.utils.interpolate.canvas_to_world</code> and <code>wilson.utils.interpolate.world_to_canvas</code>, which convert between pairs (row, col) of canvas coordinates and (x, y) of world coordinates. Note that <code>row</code> increases from top to bottom, while <code>y</code> does the opposite.
	
	The algorithm to color a single point \(z_0\) of the Julia set corresponding to \(c = a + bi\) is relatively simple: with \(f(z) = z^2 + c\), we let \(z_1 = f(z_0)\), \(z_2 = f(z_1)\), and so on. If the \(z_n\) grow without bound, then the point \(z_0\) is <em>not</em> in the Julia set, and we give it a color based on how quickly it grew. If the \(z_n\) stay bounded, then \(z_0\) is in the set, and we color it black. In practice, we pick a maximum value for \(n\), say 100, and see if the sequence is smaller than a certain bound after that many iterations. It can be shown that if the magnitude of any \(z_n\) is ever larger than 2, then the subsequent terms will grow without bound, so that&#x2019;s the typical threshhold to measure against.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "cpu",
&#9;
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0
};</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">function generate_julia_set(a, b, resolution)
{
&#9;let brightnesses = new Array(resolution * resolution);
&#9;let max_brightness = 0;
&#9;let brightness_scale = 1.5;
&#9;const num_iterations = 100;
&#9;
&#9;for (let i = 0; i &lt; resolution; i++)
&#9;{
&#9;&#9;for (let j = 0; j &lt; resolution; j++)
&#9;&#9;{
&#9;&#9;&#9;let world_coordinates = wilson.utils.interpolate.canvas_to_world(i, j);
&#9;&#9;&#9;let x = world_coordinates[0];
&#9;&#9;&#9;let y = world_coordinates[1];
&#9;&#9;&#9;
&#9;&#9;&#9;//This helps remove color banding.
&#9;&#9;&#9;let brightness = Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;&#9;
&#9;&#9;&#9;let k = 0;
&#9;&#9;&#9;
&#9;&#9;&#9;for (k = 0; k &lt; num_iterations; k++)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;//z = z^2 + c = (x^2 - y^2 + a) + (2xy + b)i
&#9;&#9;&#9;&#9;let temp = x*x - y*y + a;
&#9;&#9;&#9;&#9;y = 2*x*y + b;
&#9;&#9;&#9;&#9;x = temp;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;brightness += Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if (x*x + y*y > 4)
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;break;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;if (k === num_iterations)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;//Color this pixel black.
&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = 0;
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = brightness;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if (brightness > max_brightness)
&#9;&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;&#9;max_brightness = brightness;
&#9;&#9;&#9;&#9;}
&#9;&#9;&#9;}
&#9;&#9;}
&#9;}
&#9;
&#9;//Now we need to create the actual pixel data in a Uint8ClampedArray to pass to Wilson.
&#9;let image_data = new Uint8ClampedArray(resolution * resolution * 4);
&#9;
&#9;for (let i = 0; i &lt; resolution * resolution; i++)
&#9;{
&#9;&#9;image_data[4 * i] = 0; //Red
&#9;&#9;image_data[4 * i + 1] = brightness_scale * brightnesses[i] / max_brightness * 255; //Green
&#9;&#9;image_data[4 * i + 2] = brightness_scale * brightnesses[i] / max_brightness * 255; //Blue
&#9;&#9;image_data[4 * i + 3] = 255; //Alpha
&#9;}
&#9;
&#9;return image_data;
}</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">document.querySelector("#generate-button").addEventListener("click", () =>
{
&#9;let a = parseFloat(document.querySelector("#a-input").value || 0);
&#9;let b = parseFloat(document.querySelector("#b-input").value || 1);
&#9;let resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;
&#9;wilson.render.draw_frame(generate_julia_set(a, b, resolution));
});</code></pre>



<br>



!begin-text-block
	
	The weirdness with the exponentials is a technique to reduce color banding &mdash; if we just used the raw iteration numbers for brightness values, we&#x2019;d see stripes of different brightness wherever that number increased or decreased by one. Basing the color partly on the values of the \(z_n\) introduces dithering &mdash; just enough noise that the color bands are blurred out.
	
	The only other thing to explain is the brightness scale variable. When we make Julia set renders, there will typically be a handful of pixels that are significanly brighter than the rest, resulting in a much darker image overall. This is hard to exactly counteract without sorting the list of brightnesses and picking one a little bit down from the top, but that requires a massive sort every frame. Instead, we can get a good result by just finding a factor experimentally that gets the majority of the pixels in full range of 0&ndash;255.
	
	With that explanation out of the way, let&#x2019;s see how the applet turned out!
	
!end-text-block



<br>

!begin-text-boxes
	
	a-1 0 \(a\)
	
	b-1 1 \(b\)
	
	resolution-1 500 Resolution
	
!end-text-boxes



!begin-text-buttons
	
	generate-1 Generate
	
!end-text-buttons



<canvas id="output-canvas-1" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s A Different Renderer

<br>

!begin-text-block
	
	This is a great start, but we have a lot more to do. The first and easiest change to make is to modify the renderer. We currently have the line <code>renderer: "cpu"</code> in our options, which means that when we pass Wilson our pixel data, it gets copied into the canvas by JavaScript. A slightly better alternative is to render the canvas with WebGL and pass in the pixel data as a texture. This can marginally increase performance, and on some browers, it also increases the maximum possible canvas size. Hearing the word WebGL might make you a little nervous, and rightfully so, but we don&#x2019;t actually have to interface with it at all right now. Just replacing that line in the options with <code>renderer: "hybrid"</code> is enough to change everything necessary on the backend.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0
};</code></pre>



<br>

!begin-text-boxes
	
	a-2 0 \(a\)
	
	b-2 1 \(b\)
	
	resolution-2 500 Resolution
	
!end-text-boxes



!begin-text-buttons
	
	generate-2 Generate
	
!end-text-buttons



<canvas id="output-canvas-2" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s Draggables

<br>

!begin-text-block
	
	Since every Julia set corresponds to a unique complex number \(c\), we should be able to use the canvas for choosing \(c\) and displaying its Julia set at the same time. Wilson provides a type of element for this, called a draggable. We can add any number of them to a canvas, but right now, we only need one. To get this set up, we just need to modify our options once again &mdash; after that, we can add a draggable at any time.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);

let draggable = wilson.draggables.add(0, 1);</code></pre>



<br>

!begin-text-block
	
	We now have a little white circle that can be freely dragged around the canvas. The style can be customized by modifying <code>.wilson-draggable</code>, but let&#x2019;s just stick with the default. The element is returned from <code>wilson.draggables.add</code> and also has a class of <code>wilson-draggable-0</code> if we want to reference it in the future. Note that <code>wilson.draggables.add</code> accepts world coordinates, not canvas ones.
	
	Now we have to actually do something with this draggable, which is accomplished by passing callback functions in the Wilson options. The index of the current draggable being moved is passed to the callback, as well as the world coordinates and the original event that was captured in case we need to do anything with that. Here, we&#x2019;d like to have callbacks for grabbing the draggable, moving it, and letting it go &mdash; we&#x2019;ll render low resolution frames while moving so that the framerate stays high, then a single higher resolution frame when we let go.
	
	We&#x2019;ll no longer need the input fields for \(a\) and \(b\) &mdash; just the one for resolution. It&#x2019;d be a little awkward to have to press the generate button just to change the resolution, so instead we&#x2019;ll add a listener to that field and update the variables as needed.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvas_width: 500,
&#9;canvas_height: 500,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true,
&#9;
&#9;draggables_mousedown_callback: on_grab,
&#9;draggables_mousemove_callback: on_drag,
&#9;draggables_mouseup_callback: on_release,
&#9;
&#9;draggables_touchstart_callback: on_grab,
&#9;draggables_touchmove_callback: on_drag,
&#9;draggables_touchend_callback: on_release
};



let wilson = new Wilson(document.querySelector("#output-canvas"), options);
	
let draggable = wilson.draggables.add(0, 1);



let large_resolution = 500;
let small_resolution = 100;

document.querySelector("#resolution-input").addEventListener("input", () =>
{
&#9;large_resolution = parseInt(document.querySelector("#resolution-input").value || 500);
&#9;small_resolution = Math.floor(large_resolution / 5);
});

//Render the inital frame.
wilson.change_canvas_size(small_resolution, small_resolution);
wilson.render.draw_frame(generate_julia_set(0, 1, small_resolution));



function on_grab(active_draggable, x, y, event)
{
&#9;wilson.change_canvas_size(small_resolution, small_resolution);
&#9;wilson.render.draw_frame(generate_julia_set(x, y, small_resolution));
}

function on_drag(active_draggable, x, y, event)
{
&#9;wilson.render.draw_frame(generate_julia_set(x, y, small_resolution));
}

function on_release(active_draggable, x, y, event)
{
&#9;wilson.change_canvas_size(large_resolution, large_resolution);
&#9;wilson.render.draw_frame(generate_julia_set(x, y, large_resolution));
}</code></pre>



<br>



!begin-text-boxes
	
	resolution-3 500 Resolution
	
!end-text-boxes



<canvas id="output-canvas-3" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s Parallelizing

<br>

!begin-text-block
	
	Now we&#x2019;re getting somewhere! There are a handful of features we could build in next, but we&#x2019;re overdue for one in particular: moving the math onto the GPU. This is called <em>parallelizing</em>, and it&#x2019;s not something that&#x2019;s possible for every applet: every pixel will be processed independently of every other, so information cannot be shared between them. For example, an applet that renders an iterated function system by tracking the orbit of a single point across millions of iterations will not lend itself well to parallelization. A Julia sets, on the other hand, is a perfect candidate.
	
	The technology for GPU-based applets on the web is called WebGL. Traditionally, it&#x2019;s used for 3D applets and games that use raster graphics. Wilson does <em>not</em> support any of that &mdash; if you need high-performance raster graphics, look to something like <a href="https://threejs.org" onclick="Page.Navigation.redirect('https://threejs.org', true)">three.js</a> instead. What Wilson provides is a stripped-down environment where getting WebGL working only requires a fragment shader, something that is normally not easy.
	
	Writing that fragment shader can be challenging, though &mdash; it&#x2019;s not written in JavaScript, but rather in a language called GLSL that&#x2019;s very unforgiving &mdash; writing a number as 3 instead of 3.0 or 3. will most likely cause the entire program to crash with a generic error message and no ability to debug. Writing GLSL is an exercise in extreme caution and frequent testing, but the upshot is massively improved performance &mdash; it&#x2019;s not at all uncommon to see a 10x jump in the number of pixels that can be rendered per frame, though this of course depends on the relative power of the CPU and the GPU. If your applet is parallelizable, you should at least try to get it working in GLSL.
	
	To get started, we&#x2019;ll change the renderer setting once again, this time to <code>renderer: "gpu"</code>. After that, we need to write our shader, tell Wilson what uniforms (i.e. parameters) the shader has, and then change some of our existing code to set those variables properly. Let&#x2019;s take this one step at a time, starting with the shader.
	
!end-text-block



<pre><code class="language-glsl" data-aos="fade-up">let frag_shader_source = `
&#9;precision highp float;
&#9;
&#9;varying vec2 uv;
&#9;
&#9;uniform float a;
&#9;uniform float b;
&#9;uniform float brightness_scale;
&#9;
&#9;
&#9;
&#9;void main(void)
&#9;{
&#9;&#9;vec2 z = vec2(uv.x * 2.0, uv.y * 2.0);
&#9;&#9;vec3 color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
&#9;&#9;float brightness = exp(-length(z));
&#9;&#9;
&#9;&#9;
&#9;&#9;
&#9;&#9;vec2 c = vec2(a, b);
&#9;&#9;
&#9;&#9;for (int iteration = 0; iteration &lt; 200; iteration++)
&#9;&#9;{
&#9;&#9;&#9;if (iteration == 199)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
&#9;&#9;&#9;&#9;return;
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;if (length(z) >= 2.0)
&#9;&#9;&#9;{
&#9;&#9;&#9;&#9;break;
&#9;&#9;&#9;}
&#9;&#9;&#9;
&#9;&#9;&#9;z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
&#9;&#9;&#9;
&#9;&#9;&#9;brightness += exp(-length(z));
&#9;&#9;}
&#9;&#9;
&#9;&#9;
&#9;&#9;gl_FragColor = vec4(brightness / brightness_scale * color, 1.0);
&#9;}
`;</code></pre>



<br>

!begin-text-block
	
	While a full tutorial for GLSL is outside the scope of this guide, let&#x2019;s touch on some of the important points from this shader in particular.
	
	<code>precision highp float</code>: this should go at the start of every shader since it maximizes precision. <code>mediump</code> can also be used, but for a math applet, that tends to be a bad idea &mdash; WebGL doesn&#x2019;t even support doubles, so we need all the precision we can get.
	
	<code>varying vec2 uv</code>: here, <code>varying</code> means varying from pixel to pixel. This is the variable that gives the position of the current pixel, on a scale from -1 to 1 in both the x and y directions, and when using Wilson, the variable name <code>uv</code> must be used. Looking through the rest of the shader, we can see <code>int</code>, <code>float</code>, and other C-like variable declarations, along with <code>vec2</code> and <code>vec3</code>. These last two are effectively float arrays with multiplication and addition given componentwise. The maximum size is a <code>vec4</code>, and there are 2&ndash;4 dimensional matrices available, too. In general, math should be done with vectors whenever possible, though optimizing GLSL is its own topic.
	
	<code>uniform float a</code>: as opposed to a varying, a uniform is a value that is the same across all the pixels, but can be changed frame-to-frame without reloading the entire shader. Once we&#x2019;ve given Wilson this shader, we&#x2019;ll have to tell it where the uniforms are.
	
	<code>vec2 z = vec2(uv.x * 2.0, uv.y * 2.0)</code>: scales to world coordinates. Note that <code>vec2</code> is a constructor as well as a type, and that we can access the components of <code>uv</code> with <code>uv.x</code>. More complicated syntax is possible, called <em>swizzling</em>: <code>uv.xyyx</code> gets a <code>vec4</code> whose first and last elements are <code>uv.x</code> and whose middle two are <code>uv.y</code>.
	
	<code>length</code>, <code>normalize</code>, <code>abs</code>, etc.: GLSL has a large number of built-in functions for performing operations on vectors. Before writing some potentially inefficient code to handle a common operation, check if it&#2019;s natively implemented first.
	
	<code>gl_FragColor</code>: this is how we actually set the pixel color &mdash; the data is given as a <code>vec4</code> corresponding to the RGBA values on a scale of 0&ndash;1.
	
	The color choice at the start is just something I came up with through trial and error, and creates a palette I think looks nice &mdash; definitely better than the uniform cyan we had before.
	
	This should be enough to get started writing your own shaders. Remember &mdash; test your code every handful of lines, or you&#x2019;ll have a painful debugging process ahead of you!
	
	Now we need to add the shader in the options, and we also have to tell Wilson where the uniforms are so we can change them. This is done with a single function call.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "gpu",
&#9;
&#9;shader: frag_shader_source,
&#9;
&#9;canvas_width: 1000,
&#9;canvas_height: 1000,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true,
&#9;
&#9;draggables_mousemove_callback: on_drag,
&#9;draggables_touchmove_callback: on_drag
};



let wilson = new Wilson(document.querySelector("#output-canvas"), options);

wilson.render.init_uniforms(["a", "b", "brightness_scale"]);
	
let draggable = wilson.draggables.add(0, 1);</code></pre>



<br>

!begin-text-block
	
	A few other things need to change. We no longer need <code>generate_julia_set</code>, since that computation will be done on the GPU. Similarly, we also no longer pass anything to <code>wilson.render.draw_frame</code>. The performance increase will be large enough that 1000 is now a reasonable resolution for most users, and that&#x2019;s high enough that we won&#x2019;t bother with raising the resolution when we let the draggable go. Finally, we need to actually set those uniforms.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let resolution = 1000;

document.querySelector("#resolution-input").addEventListener("input", () =>
{
&#9;resolution = parseInt(document.querySelector("#resolution-input").value || 1000);
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;wilson.render.draw_frame();
});


wilson.gl.uniform1f(wilson.uniforms["a"], 0);
wilson.gl.uniform1f(wilson.uniforms["b"], 1);
wilson.gl.uniform1f(wilson.uniforms["brightness_scale"], 10);

wilson.change_canvas_size(resolution, resolution);

wilson.render.draw_frame();



function on_drag(active_draggable, x, y, event)
{
&#9;wilson.gl.uniform1f(wilson.uniforms["a"], x);
&#9;wilson.gl.uniform1f(wilson.uniforms["b"], y);
&#9;wilson.gl.uniform1f(wilson.uniforms["brightness_scale"], 10);
&#9;
&#9;wilson.render.draw_frame();
}</code></pre>



<br>

!begin-text-block
	
	The name of the function that sets the uniforms changes depending on the type of the variable: For a single <code>float</code>, it&#x2019;s <code>uniform1f</code>, but for an <code>int</code>, it would be <code>uniform1i</code>. Vectors can be set in two ways: to give a <code>vec2</code> a value of <code>a</code> in its first coordinate and <code>b</code> in its second, we can use <code>uniform2f(wilson.uniforms["var_name"], a, b)</code> or <code>uniform2fv(wilson.uniforms["var_name"], [a, b])</code>.
	
	Hopefully WebGL doesn&#x2019;t seem quite so scary anymore! If you haven&#x2019;t been copying the code into your own project so far, now is a great time to start &mdash; experimenting with the shader is a great way to get familiar with GLSL.
	
!end-text-block



<br>



!begin-text-boxes
	
	resolution-4 1000 Resolution
	
!end-text-boxes



<canvas id="output-canvas-4" class="output-canvas" data-aos="fade-up"></canvas>



!section

!text s Hidden Canvases

<br>

!begin-text-block
	
	Hopefully the performance increase is apparent! At the time of writing, my computer can only handle about a 300x300 CPU-driven canvas before it starts to drop below 60fps, but a 5000x5000 GPU-driven one is still silky smooth.
	
	One problem you probably noticed with the CPU canvas was a rapid fluctuation in brightness due to a high variation in the value of the brightest pixel. Here, we have a different problem &mdash; there&#x2019;s no way to automatically control the brightness at all. One option is to try a value, then see how many pixels are at max brightness and slightly adjust the brightness scale on the next frame. This is expensive, though, and if the brightness changes suddenly, it will take a while to catch up. A better solution is to render a second canvas with the same shader at a very low resolution &mdash; say 100x100 &mdash; and no brightness scale at all. Then we can read off the max brightness from that canvas and use it for the output one.
	
	This process is simple &mdash; all we have to do is register a second canvas with Wilson and give it a similar set of options.
	
!end-text-block



<pre><code class="language-html" data-aos="fade-up">&lt;input id="resolution-input" type="text" value="1000"&gt;
&lt;label for="resolution-input"&gt;
&#9;&lt;p&gt;Resolution&lt;/p&gt;
&lt;/label&gt;

&lt;canvas id="hidden-canvas"&gt&lt;/canvas&gt;

&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;</code></pre>

<br>

<pre><code class="language-css" data-aos="fade-up">#hidden-canvas
{
&#9;position: fixed;
&#9;left: -100px;
&#9;width: 10px;
&#9;height: 10px;
}</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">let options_hidden =
{
&#9;renderer: "gpu",
&#9;
&#9;shader: frag_shader_source,
&#9;
&#9;canvas_width: 100,
&#9;canvas_height: 100,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0
};



let wilson_hidden = new Wilson(document.querySelector("#hidden-canvas"), options_hidden);

wilson_hidden.render.init_uniforms(["a", "b", "brightness_scale"]);



let a = 0;
let b = 1;

let resolution = 1000;

let resolution_hidden = 100;

document.querySelector("#resolution-input").addEventListener("input", () =>
{
&#9;resolution = parseInt(document.querySelector("#resolution-input").value || 1000);
&#9;wilson.change_canvas_size(resolution, resolution);
&#9;
&#9;draw_julia_set();
});

function on_drag(active_draggable, x, y, event)
{
&#9;a = x;
&#9;b = y;
&#9;
&#9;draw_julia_set();
}

//Render the first frame.
draw_julia_set();



function draw_julia_set()
{
&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["a"], a);
&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["b"], b);
&#9;
&#9;/*
&#9;&#9;Like range in a photo, the brightness will get clipped if we let it go above 1.
&#9;&#9;Therefore, we divide by a large number to make sure that doesn&#x2019;t happen.
&#9;&#9;Too large and everything will get compressed into too few dark values instead,
&#9;&#9;so we need to pick a brightness scale in the middle.
&#9;*/
&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["brightness_scale"], 20);
&#9;
&#9;wilson_hidden.render.draw_frame();
&#9;
&#9;
&#9;
&#9;let pixel_data = wilson_hidden.render.get_pixel_data();
&#9;
&#9;let brightnesses = new Array(resolution_hidden * resolution_hidden);
&#9;
&#9;for (let i = 0; i &lt; resolution_hidden * resolution_hidden; i++)
&#9;{
&#9;&#9;brightnesses[i] = pixel_data[4 * i] + pixel_data[4 * i + 1] + pixel_data[4 * i + 2];
&#9;}
&#9;
&#9;brightnesses.sort((a, b) => a - b);
&#9;
&#9;let brightness_scale = brightnesses[Math.floor(resolution_hidden * resolution_hidden * .98)] / 255 * 18;
&#9;
&#9;wilson.gl.uniform1f(wilson.uniforms["a"], a);
&#9;wilson.gl.uniform1f(wilson.uniforms["b"], b);
&#9;wilson.gl.uniform1f(wilson.uniforms["brightness_scale"], brightness_scale);
&#9;
&#9;wilson.render.draw_frame();
}</code></pre>



<br>

!begin-text-block
	
	Notice that we&#x2019;re sorting the brightnesses and throwing out the top 1% &mdash; this effectively removes outlier pixels and keeps the brightness stable frame-to-frame. Since the hidden canvas is so small, this sorting isn&#x2019;t expensive.
	
	To illustrate what&#x2019;s going on, the hidden canvas is superimposed on the output canvas here, but it should obviously be hidden in all other cases.
	
!end-text-block



!begin-text-boxes
	
	resolution-5 1000 Resolution
	
!end-text-boxes



<div id="container" style="position: relative">
	<canvas id="output-canvas-5" class="output-canvas" data-aos="fade-up"></canvas>
	<canvas id="hidden-canvas-5" class="output-canvas hidden-canvas-superimposed" data-aos="fade-up" data-aos-delay-increase="0"></canvas>
</div>



!section

!text s Fullscreen

<br>

!begin-text-block
	
	Next on the list is making better use of screen space. While JavaScript has a built-in fullscreen API, it&#x2019;s often problematic for use with applets -- it streches the content to fill the screen whether we want it to or not, and it renders any interactivity effectively unusable on mobile, since swiping down always exits fullscreen. Wilson provides its own toolkit to help with this &mdash; let&#x2019;s have a look at how it works.
	
	As usual, we need to update the options. The bare minimum is adding <code>use_fullscreen: true</code>, but on its own, we have to handle entering and exiting fullscreen on our own using <code>wilson.fullscreen.switch_fullscreen()</code>. Instead, we can add the line <code>use_fullscreen_button: true</code>, and Wilson will place a small button in the top-right of our canvas that enters or exits fullscreen when pressed. We also need to tell Wilson where the icons for that button are located &mdash; we can use our own icons, but let&#x2019;s stick with the deafults.
	
!end-text-block

<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;renderer: "gpu",
&#9;
&#9;shader: frag_shader_source,
&#9;
&#9;canvas_width: 1000,
&#9;canvas_height: 1000,
&#9;
&#9;world_width: 4,
&#9;world_height: 4,
&#9;world_center_x: 0,
&#9;world_center_y: 0,
&#9;
&#9;
&#9;
&#9;use_draggables: true,
&#9;
&#9;draggables_mousemove_callback: on_drag,
&#9;draggables_touchmove_callback: on_drag,
&#9;
&#9;
&#9;
&#9;use_fullscreen: true,
&#9;
&#9;use_fullscreen_button: true,
&#9;
&#9;enter_fullscreen_button_image_path: "/path/to/enter-fullscreen.png",
&#9;exit_fullscreen_button_image_path: "/path/to/exit-fullscreen.png"
};</code></pre>



!begin-text-boxes
	
	resolution-6 1000 Resolution
	
!end-text-boxes



<canvas id="output-canvas-6" class="output-canvas" data-aos="fade-up"></canvas>
<canvas id="hidden-canvas-6" class="hidden-canvas"></canvas>



!section

!text s True Fullscreen

<br>

!begin-text-block
	
	This is definitely an improvement, but if you play with it a little, you&#x2019;ll quickly realize it&#x2019;s not actually doing that much differently &mdash; the canvas is still a square, and we can&#x2019;t move the draggable outside of it. The output fits inside of that square nicely, but if the applet wasn&#x2019;t dark around the edges, the border would be much more apparent. To actually take advantage of the all the screen space available, we&#x2019;ll need to modify our shader and Wilson&#x2019;s options.
	
!end-text-block



<pre><code class="language-glsl" data-aos="fade-up">let frag_shader_source = `
&#9;precision highp float;
&#9;
&#9;varying vec2 uv;
&#9;
&#9;uniform float aspect_ratio;
&#9;
&#9;uniform float a;
&#9;uniform float b;
&#9;uniform float brightness_scale;
&#9;
&#9;
&#9;
&#9;void main(void)
&#9;{
&#9;&#9;vec2 z;
&#9;&#9;
&#9;&#9;if (aspect_ratio > 1.0)
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * aspect_ratio * 2.0, uv.y * 2.0);
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * 2.0, uv.y / aspect_ratio * 2.0);
&#9;&#9;}
&#9;&#9;
&#9;&#9;...
&#9;}
`;</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;use_fullscreen: true,
&#9;
&#9;true_fullscreen: true,
&#9;
&#9;use_fullscreen_button: true,
&#9;
&#9;enter_fullscreen_button_image_path: "/path/to/enter-fullscreen.png",
&#9;exit_fullscreen_button_image_path: "/path/to/exit-fullscreen.png"
};

...

wilson.render.init_uniforms(["aspect_ratio", "a", "b", "brightness_scale"]);
wilson_hidden.render.init_uniforms(["aspect_ratio", "a", "b", "brightness_scale"]);

//Render the first frame.
wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], 1);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["aspect_ratio"], 1);
draw_julia_set();</code></pre>



<br>

!begin-text-block
	
	Now we&#x2019;re prepared for a canvas that isn&#x2019;t square, but we need to actually resize the canvas whenever we enter or exit fullscreen. We can update the options once again to add a callback function that&#x2019;s called whenever this happens, and on our end, we can add a listener to resize the canvas whenever the window is resized.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;use_fullscreen: true,
&#9;
&#9;true_fullscreen: true,
&#9;
&#9;use_fullscreen_button: true,
&#9;
&#9;enter_fullscreen_button_image_path: "/path/to/enter-fullscreen.png",
&#9;exit_fullscreen_button_image_path: "/path/to/exit-fullscreen.png",
&#9;
&#9;switch_fullscreen_callback: change_aspect_ratio
};

...

function change_aspect_ratio()
{
&#9;if (wilson.fullscreen.currently_fullscreen)
&#9;{
&#9;&#9;let aspect_ratio = window.innerWidth / window.innerHeight;
&#9;&#9;
&#9;&#9;if (aspect_ratio >= 1)
&#9;&#9;{
&#9;&#9;&#9;wilson.change_canvas_size(resolution, Math.floor(resolution / aspect_ratio));
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;&#9;wilson.change_canvas_size(Math.floor(resolution * aspect_ratio), resolution);
&#9;&#9;}
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], aspect_ratio);
&#9;}
&#9;
&#9;else
&#9;{
&#9;&#9;wilson.change_canvas_size(resolution, resolution);
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], 1);
&#9;}
&#9;
&#9;draw_julia_set();
}

window.addEventListener("resize", change_aspect_ratio);</code></pre>



<br>

!begin-text-block
	
	Note that it would be a bad idea to resize the hidden canvas along with the visible one here &mdash; if we did that, we&#2019;d get more dark pixels in narrow aspect ratios, so the brightness scale would jump up unnaturally when we entered fullscreen or narrowed the window.
	
!end-text-block



!begin-text-boxes
	
	resolution-7 1000 Resolution
	
!end-text-boxes



<canvas id="output-canvas-7" class="output-canvas" data-aos="fade-up"></canvas>
<canvas id="hidden-canvas-7" class="hidden-canvas"></canvas>



!section

!text s Interactivity

<br>

!begin-text-block
	
	Now <em>this</em> is a Julia set explorer! We could call this done this as-is, but there&#x2019;s one last improvement we can make: adding the ability to pan and zoom into the fractals. This is the only part of Wilson that we haven&#x2019;t discussed yet, and it will require slightly more work on our end than the others, since panning and zooming aren&#x2019;t the only possible effects we could want from interacting with the canvas.
	
	Panning is easier, so let&#x2019;s start with that. As you can probably predict by now, we attach callbacks in the options that fire when different kinds of interaction with the canvas take place, just like with draggables. The mouse movement callbacks are separated into <code>mousemove</code> and <code>mousedrag</code> &mdash; the first is called when the mouse is not being clicked, and the second when it is. We&#x2019;re going for something akin to Google Maps here, so we&#x2019;ll use <code>mousedrag</code>. For touchscreens, there&#x2019;s only one event for movement, since it&#x2019;s not possible to drag without touching the screen. The <code>touchmove</code> callback is used, but it shouldn#&x2019;t be used for pinch gestures &mdash; we&#x2019;ll handle those later.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;mousedrag_callback: on_drag_canvas,
&#9;touchmove_callback: on_drag_canvas
};

...

on_drag_canvas(x, y, x_delta, y_delta, event)
{
	wilson.world_center_x += x_delta;
	wilson.world_center_y += y_delta;
}</code></pre>



<br>

!begin-text-block
	
	We still need to change the shader, but we&#x2019;ll get to that in a moment. Right now, let&#x2019;s set up the zoom callbacks.
	
!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;mousedrag_callback: on_drag_canvas,
&#9;touchmove_callback: on_drag_canvas,
&#9;
&#9;pinch_callback: on_pinch_canvas,
&#9;wheel_callback: on_wheel_canvas
};

...

function on_drag_canvas(x, y, x_delta, y_delta, event)
{
&#9;wilson.world_center_x += x_delta;
&#9;wilson.world_center_y += y_delta;
}

function on_pinch_canvas
{

}</code></pre>



!begin-text-boxes
	
	resolution-8 1000 Resolution
	
!end-text-boxes



<canvas id="output-canvas-8" class="output-canvas" data-aos="fade-up"></canvas>
<canvas id="hidden-canvas-8" class="hidden-canvas"></canvas>



!footer



<script>
	if (typeof Page === "undefined")
	{
		window.location.replace("/index-testing.html?page=" + encodeURIComponent(window.location.pathname));
	}
	
	
	
	Page.settings = 
	{
		"title": "Wilson: A Guide",
		
		"math_page": true,
		
		"small_margins_on_ultrawide": true
	};
	
	Page.load();
</script>