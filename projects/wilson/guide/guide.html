<head><title>Wilson: A Guide</title></head>

<div style="height: 5vh"></div>

<noscript>
	<p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p>
</noscript>



!header Wilson: A Guide



!section

!text s Parallelizing

<br>



!section

!text s Hidden Canvases

<br>





!section





!section

!text s Interactivity

<br>

!begin-text-block
	
	Now <em>this</em> is a Julia set explorer! We could call this done this as-is, but there&#x2019;s one last improvement we can make: adding the ability to pan and zoom into the fractals. This is the only part of Wilson that we haven&#x2019;t discussed yet, and it will require slightly more work on our end than the others, since panning and zooming aren&#x2019;t the only possible effects we could want from interacting with the canvas.
	
	Panning is easier, so let&#x2019;s start with that. As you can probably predict by now, we attach callbacks in the options that fire when different kinds of interaction with the canvas take place, just like with draggables. The mouse movement callbacks are separated into <code>mousemove</code> and <code>mousedrag</code> &mdash; the first is called when the mouse is not being clicked, and the second when it is. We&#x2019;re going for something akin to Google Maps here, so we&#x2019;ll use <code>mousedrag</code>. For touchscreens, there&#x2019;s only one event for movement, since it&#x2019;s not possible to drag without touching the screen. The <code>touchmove</code> callback is used, but it shouldn#&x2019;t be used for pinch gestures &mdash; we&#x2019;ll handle those later.
	
!end-text-block



<pre><code class="language-glsl" data-aos="fade-up">let frag_shader_source = `
&#9;precision highp float;
&#9;
&#9;varying vec2 uv;
&#9;
&#9;uniform float aspect_ratio;
&#9;
&#9;uniform float center_x;
&#9;uniform float center_y;
&#9;
&#9;uniform float a;
&#9;uniform float b;
&#9;uniform float brightness_scale;
&#9;
&#9;
&#9;
&#9;void main(void)
&#9;{
&#9;&#9;vec2 z;
&#9;&#9;
&#9;&#9;if (aspect_ratio > 1.0)
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * aspect_ratio * 2.0 + center_x, uv.y * 2.0 + center_y);
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * 2.0 + center_x, uv.y / aspect_ratio * 2.0 + center_y);
&#9;&#9;}
&#9;&#9;
&#9;&#9;...
&#9;}
`;</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;mousedrag_callback: on_drag_canvas,
&#9;touchmove_callback: on_drag_canvas
};

...

wilson.render.init_uniforms(["aspect_ratio", "center_x", "center_y", "a", "b", "brightness_scale"]);
wilson_hidden.render.init_uniforms(["aspect_ratio", "center_x", "center_y", "a", "b", "brightness_scale"]);

...

//Render the first frame.
wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], 1);
wilson.gl.uniform1f(wilson.uniforms["center_x"], 0);
wilson.gl.uniform1f(wilson.uniforms["center_y"], 0);

wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["aspect_ratio"], 1);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_x"], 0);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_y"], 0);

draw_julia_set();

...

function on_drag_canvas(x, y, x_delta, y_delta, event)
{
&#9;wilson.world_center_x -= x_delta;
&#9;wilson.world_center_y -= y_delta;
&#9;
&#9;wilson.world_center_x = Math.min(Math.max(wilson.world_center_x, -2), 2);
&#9;wilson.world_center_y = Math.min(Math.max(wilson.world_center_y, -2), 2);
&#9;
&#9;wilson.gl.uniform1f(wilson.uniforms["center_x"], wilson.world_center_x);
&#9;wilson.gl.uniform1f(wilson.uniforms["center_y"], wilson.world_center_y);
&#9;
&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_x"], wilson.world_center_x);
&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_y"], wilson.world_center_y);
&#9;
&#9;draw_julia_set();
&#9;
&#9;wilson.draggables.recalculate_locations();
}</code></pre>



<br>

!begin-text-block
	
	All we&#x2019;re doing here is moving the center of the canvas however the callbacks tell us. Since all the parameters are given in world coordinates, we don&#x2019;t need to convert anything, and we also don&#x2019;t have to deal with the headache of calculating the deltas ourselves when we&#x2019;re changing the very parameters used to calculate them as we go. The only delicate part is remembering to subtract the deltas rather than add them. If we drag one unit to the right, then the want the scene to move one unit to the right, which means the x-coordinate of the center of the scene needs to move one unit to the <em>left</em>.
	
	A few other things to note: it&#x2019;s a good idea to clamp the center values here to prevent the brightness skyrocketing if we leave the Julia set. Less optionally, we need to tell Wilson to recalculate where the draggable should be. It does this automataically when the window is resized or we change fullscreen modes, but for more custom behavior like this, it needs to be called manually.
	
	Let&#2019;s talk about zooming. There are a few reasons it&#x2019;s trickier to implement: we typically want to support zooming with either a scroll wheel or a pinch gesture, so there&#x2019;s more code to write, but the real trouble is making it feel &#x201C;natural&#x201D; &mdash; specifically, we want the position of the mouse or the center of the pinch to be the fixed point of the zoom, so that everything else moves around it. This is a <em>very</em> annoying series of calculations, but thankfully Wilson will handle it all for us. Let&#x2019;s see how it works.

!end-text-block


	
<pre><code class="language-glsl" data-aos="fade-up">let frag_shader_source = `
&#9;precision highp float;
&#9;
&#9;varying vec2 uv;
&#9;
&#9;uniform float aspect_ratio;
&#9;
&#9;uniform float center_x;
&#9;uniform float center_y;
&#9;uniform float world_size;
&#9;
&#9;uniform float a;
&#9;uniform float b;
&#9;uniform float brightness_scale;
&#9;
&#9;
&#9;
&#9;void main(void)
&#9;{
&#9;&#9;vec2 z;
&#9;&#9;
&#9;&#9;if (aspect_ratio > 1.0)
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * aspect_ratio * world_size + center_x, uv.y * world_size + center_y);
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;&#9;z = vec2(uv.x * world_size + center_x, uv.y / aspect_ratio * world_size + center_y);
&#9;&#9;}
&#9;&#9;
&#9;&#9;...
&#9;}
`;</code></pre>

<br>

<pre><code class="language-js" data-aos="fade-up">wilson.render.init_uniforms(["aspect_ratio", "center_x", "center_y", "world_size", "a", "b", "brightness_scale"]);
wilson_hidden.render.init_uniforms(["aspect_ratio", "center_x", "center_y", "world_size", "a", "b", "brightness_scale"]);

...

//Render the first frame.
wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], 1);
wilson.gl.uniform1f(wilson.uniforms["center_x"], 0);
wilson.gl.uniform1f(wilson.uniforms["center_y"], 0);
wilson.gl.uniform1f(wilson.uniforms["world_size"], 2);

wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["aspect_ratio"], 1);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_x"], 0);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_y"], 0);
wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["world_size"], 2);

draw_julia_set();</code></pre>



<br>

!begin-text-block
	
	So far, this is just a fancier way of doing the same thing. The new uniform <code>world_size</code> replaces the constant <code>2.0</code> in the shader, so making <code>world_size</code> smaller will make the scene zoom in.

!end-text-block



<pre><code class="language-js" data-aos="fade-up">let options =
{
&#9;...
&#9;
&#9;mousedrag_callback: on_drag_canvas,
&#9;touchmove_callback: on_drag_canvas,
&#9;
&#9;wheel_callback: on_wheel_canvas,
&#9;pinch_callback: on_pinch_canvas
};

let zoom_level = 0;

...

function on_wheel_canvas_8(x, y, scroll_amount, event)
{
&#9;scroll_amount = Math.min(Math.max(scroll_amount, -.5), .5);
&#9;
&#9;zoom_level += scroll_amount;
&#9;
&#9;zoom_level = Math.min(zoom_level, 1);
&#9;
&#9;zoom_canvas(x, y);
}



function on_pinch_canvas(x, y, touch_distance_delta, event)
{
&#9;if (aspect_ratio >= 1)
&#9;{
&#9;&#9;zoom_level -= touch_distance_delta / wilson.world_width * 10;
&#9;}
&#9;
&#9;else
&#9;{
&#9;&#9;zoom_level -= touch_distance_delta / wilson.world_height * 10;
&#9;}
&#9;
&#9;zoom_level = Math.min(zoom_level, 1);
&#9;
&#9;zoom_canvas(x, y);
}</code></pre>



<br>

!begin-text-block
	
	We&#x2019;ll look at <code>zoom_canvas</code> in a second, but let&#x2019;s examine this first. Wheel events can vary wildly in reported scroll amount &mdash; just comparing my two computers, iOS Safari with a trackpad reports continuous scroll amounts that are typically between -1 and 1, while Firefox on Windows with a discrete scroll wheel reports exclusively 192 and -192. Clamping the scroll amounts seems is a good way to handle this discrepancy without writing different code for different browsers.
	
	On the touchscreen side, <code>touch_distance_delta</code> is the difference between two distances &mdash; the current pinch and the last one &mdash; as measured in world coordinates. As with the drag callbacks, there&#x2019;s some complicated stuff going on behind the scenes to ensure that this value is correct even if the last pinch distance was measured relative to different world coordinates. The multiplication by 10 is an experimental value that I found worked well &mdash; ideally, we want the world coordinates at the touch points to always remain the same, so that it feels as much as possible like pinching is actually moving the scene. That&#x2019;s not always possible in practice, but this comes pretty close.

!end-text-block



<pre><code class="language-js" data-aos="fade-up">function zoom_canvas(fixed_point_x, fixed_point_y)
{
&#9;if (aspect_ratio >= 1)
&#9;{
&#9;&#9;let new_world_center = wilson.input.get_zoomed_world_center(fixed_point_x, fixed_point_y, 4 * Math.pow(2, zoom_level), 4 * Math.pow(2, zoom_level) / aspect_ratio);
&#9;&#9;
&#9;&#9;wilson.world_width = 4 * Math.pow(2, zoom_level);
&#9;&#9;wilson.world_height = 4 * Math.pow(2, zoom_level) / aspect_ratio;
&#9;&#9;
&#9;&#9;wilson.world_center_x = new_world_center[0];
&#9;&#9;wilson.world_center_y = new_world_center[1];
&#9;&#9;
&#9;&#9;
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["center_x"], wilson.world_center_x);
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["center_y"], wilson.world_center_y);
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["world_size"], wilson.world_height / 2);
&#9;&#9;
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_x"], wilson.world_center_x);
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_y"], wilson.world_center_y);
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["world_size"], wilson.world_height / 2);
&#9;}
&#9;
&#9;
&#9;
&#9;else
&#9;{
&#9;&#9;let new_world_center = wilson.input.get_zoomed_world_center(fixed_point_x, fixed_point_y, 4 * Math.pow(2, zoom_level) * aspect_ratio, 4 * Math.pow(2, zoom_level));
&#9;&#9;
&#9;&#9;wilson.world_width = 4 * Math.pow(2, zoom_level) * aspect_ratio;
&#9;&#9;wilson.world_height = 4 * Math.pow(2, zoom_level);
&#9;&#9;
&#9;&#9;wilson.world_center_x = new_world_center[0];
&#9;&#9;wilson.world_center_y = new_world_center[1];
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["center_x"], wilson.world_center_x);
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["center_y"], wilson.world_center_y);
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["world_size"], wilson.world_width / 2);
&#9;&#9;
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_x"], wilson.world_center_x);
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["center_y"], wilson.world_center_y);
&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["world_size"], wilson.world_width / 2);
&#9;}
&#9;
&#9;draw_julia_set();
&#9;
&#9;wilson.draggables.recalculate_locations();
}</code></pre>



<br>

!begin-text-block
	
	It looks like there&#x2019;s a lot going on here, but it&#x2019;s really not that bad. <code>wilson.input.get_zoomed_world_center</code> tells us what the new world center values should be in order to fix a certain point. We pass it that fixed point, as well as what the world width and height will be after the zoom &mdash; this is why we have to handle the two cases separately. After that, it&#x2019;s just a bunch of variable setting. One important thing to note is that we use <code>wilson</code>&#x2019;s values of world width and height to set <code>wilson_hidden</code>&#x2019;s uniforms, since we&#x2019;re only keeping track of those values in the non-hidden canvas.
	
	We&#x2019;re almost done &mdash; all that&#x2019;s left is a small tweaks to the aspect ratio changer.

!end-text-block



<pre><code class="language-js" data-aos="fade-up">function change_aspect_ratio()
{
&#9;if (wilson.fullscreen.currently_fullscreen)
&#9;{
&#9;&#9;aspect_ratio = window.innerWidth / window.innerHeight;
&#9;&#9;
&#9;&#9;if (aspect_ratio >= 1)
&#9;&#9;{
&#9;&#9;&#9;wilson.change_canvas_size(resolution, Math.floor(resolution / aspect_ratio));
&#9;&#9;&#9;
&#9;&#9;&#9;wilson.world_width = 4 * Math.pow(2, zoom_level) * aspect_ratio;
&#9;&#9;&#9;wilson.world_height = 4 * Math.pow(2, zoom_level);
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;&#9;wilson.change_canvas_size(Math.floor(resolution * aspect_ratio), resolution);
&#9;&#9;&#9;
&#9;&#9;&#9;wilson.world_width = 4 * Math.pow(2, zoom_level);
&#9;&#9;&#9;wilson.world_height = 4 * Math.pow(2, zoom_level) / aspect_ratio;
&#9;&#9;}
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], aspect_ratio);
&#9;}
&#9;
&#9;else
&#9;{
&#9;&#9;wilson.change_canvas_size(resolution, resolution);
&#9;&#9;
&#9;&#9;wilson.world_width = 4 * Math.pow(2, zoom_level);
&#9;&#9;wilson.world_height = 4 * Math.pow(2, zoom_level);
&#9;&#9;
&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["aspect_ratio"], 1);
&#9;}
&#9;
&#9;draw_julia_set();
}

window.addEventListener("resize", change_aspect_ratio);</code></pre>



<br>

!begin-text-block
	
	As a final touch, let&#x2019;s add a button to download the current state of the canvas at a specified resolution.

!end-text-block



<pre><code class="language-html" data-aos="fade-up">&lt;input id="download-resolution-input" type="text" value="2000"&gt;
&lt;label for="download-resolution-input"&gt;
&#9;&lt;p&gt;Resolution&lt;/p&gt;
&lt;/label&gt;

&lt;button id="download-button" type="button"&gt;Download&lt;/button&gt;</code></pre>

<pre><code class="language-js" data-aos="fade-up">document.querySelector("#download-button").addEventListener("click", () =>
{
	let download_resolution = parseInt(document.querySelector("#download-resolution-input").value || 2000);
	wilson.download_frame("a-julia-set.png", download_resolution);
});</code></pre>

!begin-text-boxes
	
	resolution-8 1000 Resolution
	
!end-text-boxes



<canvas id="output-canvas-8" class="output-canvas" data-aos="fade-up"></canvas>
<canvas id="hidden-canvas-8" class="hidden-canvas"></canvas>

!text s High Resolution Capture

!begin-text-boxes
	
	download-resolution-8 2000 Resolution
	
!end-text-boxes

!begin-text-buttons
	
	download-8 Download
	
!end-text-buttons



!footer



<script>
	if (typeof Page === "undefined")
	{
		window.location.replace("/index-testing.html?page=" + encodeURIComponent(window.location.pathname));
	}
	
	
	
	Page.settings = 
	{
		"title": "Wilson: A Guide",
		
		"math_page": true,
		
		"small_margins_on_ultrawide": true
	};
	
	Page.load();
</script>