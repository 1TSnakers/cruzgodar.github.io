### nav-buttons

Direct interaction with the canvas is the only part of Wilson that we haven't discussed yet, and it will require slightly more work on our end than the others, since panning and zooming aren't the only possible effects we could want.

Panning is easier, so let's start with that. As you can probably guess by now, we attach callbacks in the options that fire when different kinds of interaction with the canvas take place, just like with draggables. The mouse movement callbacks are separated into `mousemove` and `mousedrag` --- the first is called when the mouse is not being clicked, and the second when it is. We're going for something akin to Google Maps here, so we'll use `mousedrag`. For touchscreens, there's only one event for movement --- `touchmove` --- since it's not possible to drag without touching the screen. This callback shouldn't be used for pinch gestures --- we'll handle those later.

```glsl
	let fragShaderSource = `
		precision highp float;
		
		varying vec2 uv;
		
		uniform float aspectRatio;
		
		uniform float worldCenterX;
		uniform float worldCenterY;
		
		uniform float a;
		uniform float b;
		uniform float brightnessScale;
		
		
		
		void main(void)
		{
			vec2 z;
			
			if (aspectRatio > 1.0)
			{
				z = vec2(uv.x * aspectRatio * 2.0 + worldCenterX, uv.y * 2.0 + worldCenterY);
			}
			
			else
			{
				z = vec2(uv.x * 2.0 + worldCenterX, uv.y / aspectRatio * 2.0 + worldCenterY);
			}
			
			...
		}
	`;
```

```js
	let options =
	{
		...
		
		mousedragCallback: onDragCanvas,
		touchmoveCallback: onDragCanvas
	};
```

```js
	wilson.render.initUniforms(["aspectRatio", "worldCenterX", "worldCenterY", "a", "b", "brightnessScale"]);
	wilsonHidden.render.initUniforms(["aspectRatio", "worldCenterX", "worldCenterY", "a", "b", "brightnessScale"]);
```

```js
	function onDragCanvas(x, y, xDelta, yDelta, event)
	{
		wilson.worldCenterX -= xDelta;
		wilson.worldCenterY -= yDelta;
		
		wilson.worldCenterX = Math.min(Math.max(wilson.worldCenterX, -2), 2);
		wilson.worldCenterY = Math.min(Math.max(wilson.worldCenterY, -2), 2);
		
		window.requestAnimationFrame(drawJuliaSet);
		
		wilson.draggables.recalculateLocations();
	}
```

All we're doing here is moving the center of the canvas however the callbacks tell us. Since all the parameters are given in world coordinates, we don't need to convert anything, and we also don't have to deal with the headache of calculating the deltas ourselves when we're changing the very parameters used to calculate them as we go. The only delicate part is remembering to subtract the deltas rather than add them --- if we drag one unit to the right, then the want the scene to move one unit to the right, which means the x-coordinate of the center of the scene needs to move one unit to the <em>left</em>.

A few other things to note: it's a good idea to clamp the center values here to prevent the brightness skyrocketing if we leave the Julia set. Less optionally, we need to tell Wilson to recalculate where the draggable should be. It does this automataically when the window is resized or we change fullscreen modes, but for more custom behavior like this, it needs to be called manually.



### text-boxes
	resolution-1 1000 "Resolution"
###

<div class="center-content">
	<div id="canvas-landscape-middle">
		<canvas id="output-canvas-1" class="output-canvas"></canvas>
		<canvas id="hidden-canvas-1" class="hidden-canvas"></canvas>
	</div>
</div>

### buttons
	download-1 "Download"
###



## Zooming

This is slightly trickier to implement for a few reasons: we typically want to support zooming with either a scroll wheel or a pinch gesture, so there's more code to write, but the real trouble is making it feel "natural" --- specifically, we want the position of the mouse or the center of the pinch to be the fixed point of the zoom, so that everything else moves around it. This is a <em>very</em> annoying series of calculations, but thankfully Wilson will handle it all for us. Let's see how it works.



```glsl
	let fragShaderSource = `
		precision highp float;
		
		varying vec2 uv;
		
		uniform float aspectRatio;
		
		uniform float worldCenterX;
		uniform float worldCenterY;
		uniform float worldSize;
		
		uniform float a;
		uniform float b;
		uniform float brightnessScale;
		
		
		
		void main(void)
		{
			vec2 z;
			
			if (aspectRatio > 1.0)
			{
				z = vec2(uv.x * aspectRatio * worldSize + worldCenterX, uv.y * worldSize + worldCenterY);
			}
			
			else
			{
				z = vec2(uv.x * worldSize + worldCenterX, uv.y / aspectRatio * worldSize + worldCenterY);
			}
			
			...
		}
	`;
```

```js
	wilson.render.initUniforms(["aspectRatio", "worldCenterX", "worldCenterY", "worldSize", "a", "b", "brightnessScale"]);
	wilsonHidden.render.initUniforms(["aspectRatio", "worldCenterX", "worldCenterY", "worldSize", "a", "b", "brightnessScale"]);
```



So far, this is just a fancier way of doing the same thing. The new uniform `worldSize` replaces the constant `2.0` in the shader, so making `worldSize` smaller will make the scene zoom in.



```js
	let options =
	{
		...
		
		mousedragCallback: onDragCanvas,
		touchmoveCallback: onDragCanvas,
		
		wheelCallback: onWheelCanvas,
		pinchCallback: onPinchCanvas
	};
```

```js
	let aspectRatio = 1;

	let zoomLevel = 0;

	let a = 0;
	let b = 1;

	let resolution = 1000;
	let resolutionHidden = 100;

	let lastTimestamp = -1;
```

```js
	function onWheelCanvas(x, y, scrollAmount, event)
	{
		zoomLevel += scrollAmount / 100;
		
		zoomLevel = Math.min(zoomLevel, 1);
		
		zoomCanvas(x, y);
	}



	function onPinchCanvas(x, y, touchDistanceDelta, event)
	{
		if (aspectRatio >= 1)
		{
			zoomLevel -= touchDistanceDelta / wilson.worldWidth * 10;
		}
		
		else
		{
			zoomLevel -= touchDistanceDelta / wilson.worldHeight * 10;
		}
		
		zoomLevel = Math.min(zoomLevel, 1);
		
		zoomCanvas(x, y);
	}
```



We haven't defined `zoomCanvas` yet, but the idea here is fairly straightforward. Wheel events can vary wildly in reported scroll amount --- just comparing two of my computers, iOS Safari with a trackpad reports continuous scroll amounts that are typically between -1 and 1, while Firefox on Windows with a discrete scroll wheel reports exclusively 192 and -192. Dividing the scroll amounts by 100 seemed to be a good way to handle this discrepancy without writing different code for different browsers.

On the touchscreen side, `touchDistanceDelta` is the difference between two distances --- the current pinch and the last one --- as measured in world coordinates. As with the drag callbacks, there's some complicated stuff going on behind the scenes to ensure that this value is correct even if the last pinch distance was measured relative to different world coordinates. The multiplication by 10 is an experimental value that I found worked well --- ideally, we want the world coordinates at the touch points to always remain the same, so that it feels as much as possible like pinching is physically moving the scene. That's not always possible in practice, but this comes pretty close.



```js
	function zoomCanvas(fixedPointX, fixedPointY)
	{
		if (aspectRatio >= 1)
		{
			let newWorldCenter = wilson.input.getZoomedWorldCenter(fixedPointX, fixedPointY, 4 * Math.pow(2, zoomLevel) * aspectRatio, 4 * Math.pow(2, zoomLevel));
			
			wilson.worldWidth = 4 * Math.pow(2, zoomLevel) * aspectRatio;
			wilson.worldHeight = 4 * Math.pow(2, zoomLevel);
			
			wilson.worldCenterX = newWorldCenter[0];
			wilson.worldCenterY = newWorldCenter[1];
		}
		
		else
		{
			let newWorldCenter = wilson.input.getZoomedWorldCenter(fixedPointX, fixedPointY, 4 * Math.pow(2, zoomLevel), 4 * Math.pow(2, zoomLevel) / aspectRatio);
			
			wilson.worldWidth = 4 * Math.pow(2, zoomLevel);
			wilson.worldHeight = 4 * Math.pow(2, zoomLevel) / aspectRatio;
			
			wilson.worldCenterX = newWorldCenter[0];
			wilson.worldCenterY = newWorldCenter[1];
		}
		
		window.requestAnimationFrame(drawJuliaSet);
		
		wilson.draggables.recalculateLocations();
	}
```



This isn't as bad as it looks. `wilson.input.getZoomedWorldCenter` tells us what the new world center values should be in order to fix a certain point, given that fixed point along with what the world width and height will be after the zoom --- this is why we have to handle the two aspect ratio cases separately. After that, we use `zoomLevel` as an exponent. To see why this is the case, remember that pinching or scrolling should zoom in a constant speed relative to the current world size, which means we need to scale to a proportion of the it, and repeated multiplication by that proportion gives us an exponential function. Another important thing to note is that we use `wilson`'s values of world width and height to set `wilsonHidden`'s uniforms, since we're only keeping track of those values in the non-hidden canvas.

We're almost done --- all that's left is a small tweak to the aspect ratio changer.



```js
	function changeAspectRatio()
	{
		if (wilson.fullscreen.currentlyFullscreen)
		{
			aspectRatio = window.innerWidth / window.innerHeight;
			
			if (aspectRatio >= 1)
			{
				wilson.changeCanvasSize(resolution, Math.floor(resolution / aspectRatio));
				
				wilson.worldWidth = 4 * Math.pow(2, zoomLevel) * aspectRatio;
				wilson.worldHeight = 4 * Math.pow(2, zoomLevel);
			}
			
			else
			{
				wilson.changeCanvasSize(Math.floor(resolution * aspectRatio), resolution);
				
				wilson.worldWidth = 4 * Math.pow(2, zoomLevel);
				wilson.worldHeight = 4 * Math.pow(2, zoomLevel) / aspectRatio;
			}
		}
		
		else
		{
			aspectRatio = 1;
			
			wilson.changeCanvasSize(resolution, resolution);
			
			wilson.worldWidth = 4 * Math.pow(2, zoomLevel);
			wilson.worldHeight = 4 * Math.pow(2, zoomLevel);
		}
		
		window.requestAnimationFrame(drawJuliaSet);
	}
```



### text-boxes
	resolution-2 1000 "Resolution"
###

<div class="center-content">
	<div id="canvas-landscape-middle">
		<canvas id="output-canvas-2" class="output-canvas"></canvas>
		<canvas id="hidden-canvas-2" class="hidden-canvas"></canvas>
	</div>
</div>

### buttons
	download-2 "Download"
###



## Inertia

We talked about making the zoom gestures feel natural, but if panning and zooming don't carry inertia, they will never feel truly native. This takes just a bit more effort than what we've done already, and the result is well worth it.

When we stop dragging or pinching, we'll take the last adjustment we made to the world center or zoom level and repeat it over the next second or two, multiplying it by a constant between 0 and 1 every frame. When that velocity is below a certain threshhold, we'll stop it completely to avoid endlessly drawing the same frame. Similarly, we'll only start the process if the velocity is above a different threshhold in order to avoid the annoying situation where making precise adjustments is impossible and the whole applet feels slippery.



```js
	let options =
	{
		...
		
		mousedownCallback: onGrabCanvas,
		touchstartCallback: onGrabCanvas,
		
		mousedragCallback: onDragCanvas,
		touchmoveCallback: onDragCanvas,
		
		mouseupCallback: onReleaseCanvas,
		touchendCallback: onReleaseCanvas,
		
		wheelCallback: onWheelCanvas,
		pinchCallback: onPinchCanvas
	};
```

```js
	let aspectRatio = 1;

	let zoomLevel = 0;

	let a = 0;
	let b = 1;

	let resolution = 1000;
	let resolutionHidden = 100;

	let fixedPointX = 0;
	let fixedPointY = 0;

	let nextPanVelocityX = 0;
	let nextPanVelocityY = 0;
	let nextZoomVelocity = 0;

	let panVelocityX = 0;
	let panVelocityY = 0;
	let zoomVelocity = 0;

	const panFriction = .96;
	const panVelocityStartThreshhold = .005;
	const panVelocityStopThreshhold = .0005;

	const zoomFriction = .93;
	const zoomVelocityStartThreshhold = .01;
	const zoomVelocityStopThreshhold = .001;

	let lastTimestamp = -1;
```



All of the constant values here were found experimentally --- these seem to give a good balance between glide and control. The fixed point coordinates are globals now, since we need to remember them in order to continue a zoom after the pinch gesture ends.



```js
	function onGrabCanvas(x, y, event)
	{
		panVelocityX = 0;
		panVelocityY = 0;
		zoomVelocity = 0;
		
		nextPanVelocityX = 0;
		nextPanVelocityY = 0;
		nextZoomVelocity = 0;
	}



	function onDragCanvas(x, y, xDelta, yDelta, event)
	{
		wilson.worldCenterX -= xDelta;
		wilson.worldCenterY -= yDelta;
		
		nextPanVelocityX = -xDelta;
		nextPanVelocityY = -yDelta;
		
		wilson.worldCenterX = Math.min(Math.max(wilson.worldCenterX, -2), 2);
		wilson.worldCenterY = Math.min(Math.max(wilson.worldCenterY, -2), 2);
		
		window.requestAnimationFrame(drawJuliaSet);
		
		wilson.draggables.recalculateLocations();
	}



	function onReleaseCanvas(x, y, event)
	{
		if (Math.sqrt(nextPanVelocityX * nextPanVelocityX + nextPanVelocityY * nextPanVelocityY) >= panVelocityStartThreshhold * Math.min(wilson.worldWidth, wilson.worldHeight))
		{
				panVelocityX = nextPanVelocityX;
			panVelocityY = nextPanVelocityY;
		}
		
		if (Math.abs(nextZoomVelocity) >= zoomVelocityStartThreshhold)
		{
			zoomVelocity = nextZoomVelocity;
		}
		
		window.requestAnimationFrame(drawJuliaSet);
	}
```



While we're dragging, we store what the velocity would be if we released at that moment, and when we finally do release, we use that velocity as long as it's above the threshhold. Note that we divide by a factor involding the world size, since the velocities will shrink proportionally to the world as we zoom in.



```js
	function onWheelCanvas(x, y, scrollAmount, event)
	{
		fixedPointX = x;
		fixedPointY = y;
		
		if (Math.abs(scrollAmount / 100) &lt; .3)
		{
			zoomLevel += scrollAmount / 100;
			
			zoomLevel = Math.min(zoomLevel, 1);
		}
		
		else
		{
			zoomVelocity += Math.sign(scrollAmount) * .05;
		}
		
		zoomCanvas(x, y);
	}



	function onPinchCanvas(x, y, touchDistanceDelta, event)
	{
		if (aspectRatio >= 1)
		{
			zoomLevel -= touchDistanceDelta / wilson.worldWidth * 10;
			
			nextZoomVelocity = -touchDistanceDelta / wilson.worldWidth * 10;
		}
		
		else
		{
			zoomLevel -= touchDistanceDelta / wilson.worldHeight * 10;
			
			nextZoomVelocity = -touchDistanceDelta / wilson.worldHeight * 10;
		}
		
		zoomLevel = Math.min(zoomLevel, 1);
		
		fixedPointX = x;
		fixedPointY = y;
		
		zoomCanvas();
	}
```



We do the same thing for zooming. We don't have divide by a factor related to world size, since `zoomLevel` is unitless. The two scroll wheel cases are a way to differentiate continuous ones (like trackpads) from discrete ones. Here, continuous scrolling will directly translate to zooming, just like pinching, while discrete scrolling will only add velocity, giving it a bouncing effect.



```js
	function drawJuliaSet(timestamp)
	{
		...
		
		wilson.render.drawFrame();
		
		
		
		if (panVelocityX !== 0 || panVelocityY !== 0 || zoomVelocity !== 0)
		{
			wilson.worldCenterX += panVelocityX;
			wilson.worldCenterY += panVelocityY;
			
			wilson.worldCenterX = Math.min(Math.max(wilson.worldCenterX, -2), 2);
			wilson.worldCenterY = Math.min(Math.max(wilson.worldCenterY, -2), 2);
			
			
			
			panVelocityX *= panFriction;
			panVelocityY *= panFriction;
			
			if (Math.sqrt(panVelocityX * panVelocityX + panVelocityY * panVelocityY) &lt; panVelocityStopThreshhold * Math.min(wilson.worldWidth, wilson.worldHeight))
			{
				panVelocityX = 0;
				panVelocityY = 0;
			}
			
			
			
			zoomLevel += zoomVelocity;
			
			zoomLevel = Math.min(zoomLevel, 1);
			
			zoomCanvas(fixedPointX, fixedPointY);
			
			zoomVelocity *= zoomFriction;
			
			if (Math.abs(zoomVelocity) &lt; zoomVelocityStopThreshhold)
			{
				zoomVelocity = 0;
			}
			
			
			
			window.requestAnimationFrame(drawJuliaSet);
			
			wilson.draggables.recalculateLocations();
		}
	}
```



### text-boxes
	resolution-3 1000 "Resolution"
###

<div class="center-content">
	<div id="canvas-landscape-middle">
		<canvas id="output-canvas-3" class="output-canvas"></canvas>
		<canvas id="hidden-canvas-3" class="hidden-canvas"></canvas>
	</div>
</div>

### buttons
	download-3 "Download"
###



<div style="height: 32px"></div>

At last, we have a Julia set explorer with excellent performance, graphics, and controls. If it weren't for the url bar, this could be mistaken for a native application --- but in my opinion, the massive feature set of modern JavaScript combined with the universal use of the web make applets like these better in almost every respect than their native equivalents. And that's the design philosophy of Wilson --- to make that feature set simple to use, so you can create beautiful applets like this without getting stuck in boilerplate hell.
	
You can view the code for this page <a href="/projects/wilson/guide/6-interactivity/scripts/index.js">here</a>.



### nav-buttons