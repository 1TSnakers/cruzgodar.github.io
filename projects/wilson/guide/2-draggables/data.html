<header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.png" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Part 2: Draggables</h1></header><main><section><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div><p class="body-text">Since every Julia set corresponds to a unique complex number <span class="tex-holder inline-math" data-source-tex="c">$c$,</span> we should be able to use the canvas for choosing <span class="tex-holder inline-math" data-source-tex="c">$c$</span> and displaying its Julia set at the same time. Wilson provides a type of element for this, called a draggable. We can add any number of them to a canvas, but right now, we only need one. To get this set up, we just need to modify our options once again &mdash; after that, we can add a draggable at any time.</p><pre><code class="language-js">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvasWidth: 1000,
&#9;canvasHeight: 1000,
&#9;
&#9;worldWidth: 4,
&#9;worldHeight: 4,
&#9;worldCenterX: 0,
&#9;worldCenterY: 0,
&#9;
&#9;
&#9;
&#9;useDraggables: true
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);

let draggable = wilson.draggables.add(0, 1);
</code></pre><p class="body-text">We now have a little white circle that can be freely dragged around the canvas. The style can be customized by modifying <code>.wilson-draggable</code>, but let&#x2019;s just stick with the default. The element is returned from <code>wilson.draggables.add</code> and also has a class of <code>wilson-draggable-0</code> if we want to reference it in the future. Note that <code>wilson.draggables.add</code> accepts world coordinates, not canvas ones.</p><p class="body-text">Now we have to actually do something with this draggable, which is accomplished by passing callback functions in the Wilson options. The index of the current draggable being moved is passed to the callback, as well as the world coordinates and the original event that was captured in case we need to do anything with that. Here, we&#x2019;d like to have callbacks for grabbing the draggable, moving it, and letting it go &mdash; we&#x2019;ll render low resolution frames while moving so that the framerate stays high, then a single higher resolution frame when we let go. Since the resolution will be low while dragging, we can bump the default high resolution up to 1000.</p><p class="body-text">We&#x2019;ll no longer need the input fields <span class="tex-holder inline-math" data-source-tex="a">$a$</span> and <span class="tex-holder inline-math" data-source-tex="b">$b$</span> &mdash; just the one for resolution. It&#x2019;d be a little awkward to have to press the generate button just to change the resolution, so instead we&#x2019;ll add a listener to that field and update the variables as needed.</p><pre><code class="language-js">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvasWidth: 1000,
&#9;canvasHeight: 1000,
&#9;
&#9;worldWidth: 4,
&#9;worldHeight: 4,
&#9;worldCenterX: 0,
&#9;worldCenterY: 0,
&#9;
&#9;
&#9;
&#9;useDraggables: true,
&#9;
&#9;draggablesMousedownCallback: onGrab,
&#9;draggablesMousemoveCallback: onDrag,
&#9;draggablesMouseupCallback: onRelease,
&#9;
&#9;draggablesTouchstartCallback: onGrab,
&#9;draggablesTouchmoveCallback: onDrag,
&#9;draggablesTouchendCallback: onRelease
};



let wilson = new Wilson(document.querySelector("#output-canvas"), options);
&#9;
let draggable = wilson.draggables.add(0, 1);



let resolutionInputElement = document.querySelector("#resolution-input");

let largeResolution = 1000;
let smallResolution = 200;

resolutionInputElement.addEventListener("input", () =>
{
&#9;largeResolution = parseInt(resolutionInputElement.value || 1000);
&#9;smallResolution = Math.floor(largeResolution / 5);
});



let downloadButtonElement = document.querySelector("#download-button");

downloadButtonElement.addEventListener("click", () =>
{
&#9;wilson.downloadFrame("a-julia-set.png");
});
</code></pre><p class="body-text">Now that we&#x2019;re drawing frames so often, we need to be careful not to draw multiple within a single frame&#x2019;s time. This is why we introduced <code>window.requestAnimationFrame</code> in the previous part, but it&#x2019;s not quite enough on its own &mdash; instead, we&#x2019;ll make a new function <code>drawJuliaSet</code> that only calls <code>wilson.render.drawFrame</code> if either some time has passed since the previous frame or the resolution has changed. Note that <code>window.requestAnimationFrame</code> automatically passes the current timestamp to its argument.</p><pre><code class="language-js">let a = 0;
let b = 1;

let resolution = 200;
let lastResolution = 0;

let lastTimestamp = -1;



function drawJuliaSet(timestamp)
{
&#9;let timeElapsed = timestamp - lastTimestamp;
&#9;
&#9;lastTimestamp = timestamp;
&#9;
&#9;
&#9;
&#9;if (timeElapsed === 0 && lastResolution === resolution)
&#9;{
&#9;&#9;return;
&#9;}
&#9;
&#9;lastResolution = resolution;
&#9;
&#9;
&#9;
&#9;wilson.render.drawFrame(generateJuliaSet(a, b, resolution));
}



//Draw the initial frame.
wilson.changeCanvasSize(smallResolution, smallResolution);
window.requestAnimationFrame(drawJuliaSet);



function onGrab(activeDraggable, x, y, event)
{
&#9;wilson.changeCanvasSize(smallResolution, smallResolution);
&#9;
&#9;a = x;
&#9;b = y;
&#9;resolution = smallResolution;
&#9;
&#9;window.requestAnimationFrame(drawJuliaSet);
}

function onDrag(activeDraggable, x, y, event)
{
&#9;a = x;
&#9;b = y;
&#9;resolution = smallResolution;
&#9;
&#9;window.requestAnimationFrame(drawJuliaSet);
}

function onRelease(activeDraggable, x, y, event)
{
&#9;wilson.changeCanvasSize(largeResolution, largeResolution);
&#9;
&#9;a = x;
&#9;b = y;
&#9;resolution = largeResolution;
&#9;
&#9;window.requestAnimationFrame(drawJuliaSet);
}
</code></pre><div class='text-boxes'><div class="text-box-container"><input id="resolution-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div></div><div class="center-content"><div id="canvas-landscape-middle"><canvas id="output-canvas" class="output-canvas"></canvas></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-button" tabindex="-1"></button></div></div><div style="height: 32px"></div><p class="body-text">We&#x2019;re making progress! In the next section, we&#x2019;ll move the math for this applet onto the GPU, dramatically improving performance.</p><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/2-draggables/scripts/index.js">here</a>. </p><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div></section></main>