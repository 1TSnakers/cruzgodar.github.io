# Part 2: Draggables

### nav-buttons

Since every Julia set corresponds to a unique complex number $c$, we should be able to use the canvas for choosing $c$ and displaying its Julia set at the same time. Wilson provides a type of element for this, called a draggable. We can add any number of them to a canvas, but right now, we only need one. To get this set up, we just need to modify our options once again --- after that, we can add a draggable at any time.



```js
	let options =
	{
		renderer: "hybrid",
		
		canvas_width: 1000,
		canvas_height: 1000,
		
		world_width: 4,
		world_height: 4,
		world_center_x: 0,
		world_center_y: 0,
		
		
		
		use_draggables: true
	};

	let wilson = new Wilson(document.querySelector("#output-canvas"), options);

	let draggable = wilson.draggables.add(0, 1);
```



We now have a little white circle that can be freely dragged around the canvas. The style can be customized by modifying `.wilson-draggable`, but let's just stick with the default. The element is returned from `wilson.draggables.add` and also has a class of `wilson-draggable-0` if we want to reference it in the future. Note that `wilson.draggables.add` accepts world coordinates, not canvas ones.

Now we have to actually do something with this draggable, which is accomplished by passing callback functions in the Wilson options. The index of the current draggable being moved is passed to the callback, as well as the world coordinates and the original event that was captured in case we need to do anything with that. Here, we'd like to have callbacks for grabbing the draggable, moving it, and letting it go --- we'll render low resolution frames while moving so that the framerate stays high, then a single higher resolution frame when we let go. Since the resolution will be low while dragging, we can bump the default high resolution up to 1000.

We'll no longer need the input fields $a$ and $b$ --- just the one for resolution. It'd be a little awkward to have to press the generate button just to change the resolution, so instead we'll add a listener to that field and update the variables as needed.



```js
	let options =
	{
		renderer: "hybrid",
		
		canvas_width: 1000,
		canvas_height: 1000,
		
		world_width: 4,
		world_height: 4,
		world_center_x: 0,
		world_center_y: 0,
		
		
		
		use_draggables: true,
		
		draggables_mousedown_callback: on_grab,
		draggables_mousemove_callback: on_drag,
		draggables_mouseup_callback: on_release,
		
		draggables_touchstart_callback: on_grab,
		draggables_touchmove_callback: on_drag,
		draggables_touchend_callback: on_release
	};



	let wilson = new Wilson(document.querySelector("#output-canvas"), options);
		
	let draggable = wilson.draggables.add(0, 1);



	let resolution_input_element = document.querySelector("#resolution-input");

	let large_resolution = 1000;
	let small_resolution = 200;

	resolution_input_element.addEventListener("input", () =>
	{
		large_resolution = parseInt(resolution_input_element.value || 1000);
		small_resolution = Math.floor(large_resolution / 5);
	});



	let download_button_element = document.querySelector("#download-button");

	download_button_element.addEventListener("click", () =>
	{
		wilson.download_frame("a-julia-set.png");
	});
```



Now that we're drawing frames so often, we need to be careful not to draw multiple within a single frame's time. This is why we introduced `window.requestAnimationFrame` in the previous part, but it's not quite enough on its own --- instead, we'll make a new function `draw_julia_set` that only calls `wilson.render.draw_frame` if either some time has passed since the previous frame or the resolution has changed. Note that `window.requestAnimationFrame` automatically passes the current timestamp to its argument.



```js
	let a = 0;
	let b = 1;

	let resolution = 200;
	let last_resolution = 0;

	let last_timestamp = -1;



	function draw_julia_set(timestamp)
	{
		let time_elapsed = timestamp - last_timestamp;
		
		last_timestamp = timestamp;
		
		
		
		if (time_elapsed === 0 && last_resolution === resolution)
		{
				return;
		}
		
		last_resolution = resolution;
		
		
		
		wilson.render.draw_frame(generate_julia_set(a, b, resolution));
	}



	//Draw the initial frame.
	wilson.change_canvas_size(small_resolution, small_resolution);
	window.requestAnimationFrame(draw_julia_set);



	function on_grab(active_draggable, x, y, event)
	{
		wilson.change_canvas_size(small_resolution, small_resolution);
		
		a = x;
		b = y;
		resolution = small_resolution;
		
		window.requestAnimationFrame(draw_julia_set);
	}

	function on_drag(active_draggable, x, y, event)
	{
		a = x;
		b = y;
		resolution = small_resolution;
		
		window.requestAnimationFrame(draw_julia_set);
	}

	function on_release(active_draggable, x, y, event)
	{
		wilson.change_canvas_size(large_resolution, large_resolution);
		
		a = x;
		b = y;
		resolution = large_resolution;
		
		window.requestAnimationFrame(draw_julia_set);
	}
```



### text-boxes
	resolution 1000 Resolution
###

<div class="center-content">
	<div id="canvas-landscape-middle">
		<canvas id="output-canvas" class="output-canvas"></canvas>
	</div>
</div>

### buttons
	download Download
###



<div style="height: 32px"></div>

We're making progress! In the next section, we'll move the math for this applet onto the GPU, dramatically improving performance.

You can view the code for this page <a href="/projects/wilson/guide/2-draggables/scripts/index.js">here</a>. 



### nav-buttons



<script src="/scripts/init.js"></script>