<!DOCTYPE html><html lang="en"><head><title>Part 4: Hidden Canvases</title><meta property="og:title" content="Part 4: Hidden Canvases"/><meta property="og:type" content="website"/><meta property="og:url" content="https://cruzgodar.com/projects/wilson/guide/4-hidden-canvases/"/><meta property="og:image" content="https://cruzgodar.com/projects/wilson/guide/4-hidden-canvases/cover.jpg"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Cruz Godar"/><style>body {opacity: 0;}</style></head><noscript><p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p></noscript><header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.png" alt="Logo" tabindex="1"></img></a></div><div style="height: 2vh"></div><h1 class="heading-text">Part 4: Hidden Canvases</h1></header><main><section><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div><p class="body-text">One problem you probably noticed with the CPU canvas was a rapid fluctuation in brightness due to a high variation in the value of the brightest pixel. Now we have a different problem &mdash; there&#x2019;s not a clear way to automatically control the brightness at all. One option is to try a value, then see how many pixels are at max brightness and slightly adjust the brightness scale on the next frame. This is expensive, though, and if the brightness changes suddenly, it will take a while to catch up. A better solution is to render a second canvas with the same shader at a very low resolution &mdash; say 100x100 &mdash; and no brightness scale at all. Then we can read off the max brightness from that canvas and use it for the output one.</p><br><p class="body-text">This process is simple &mdash; all we have to do is register a second canvas with Wilson and give it a similar set of options.</p><br><pre><code class="language-html" data-aos="fade-up">&lt;input id="resolution-input" type="text" value="1000"&gt;&lt;label for="resolution-input"&gt;&#9;&lt;p&gt;Resolution&lt;/p&gt;&lt;/label&gt;&lt;canvas id="hidden-canvas"&gt&lt;/canvas&gt;&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;</code></pre><br><pre><code class="language-css" data-aos="fade-up">#hidden-canvas{&#9;position: fixed;&#9;left: -100px;&#9;width: 10px;&#9;height: 10px;}</code></pre><br><pre><code class="language-js" data-aos="fade-up">let options_hidden ={&#9;renderer: "gpu",&#9;&#9;shader: frag_shader_source,&#9;&#9;canvas_width: 100,&#9;canvas_height: 100};let wilson_hidden = new Wilson(document.querySelector("#hidden-canvas"), options_hidden);wilson_hidden.render.init_uniforms(["a", "b", "brightness_scale"]);</code></pre><br><pre><code class="language-js" data-aos="fade-up">function draw_julia_set(timestamp){&#9;let time_elapsed = timestamp - last_timestamp;&#9;&#9;last_timestamp = timestamp;&#9;&#9;&#9;&#9;if (time_elapsed === 0)&#9;{&#9;&#9;return;&#9;}&#9;&#9;&#9;&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["a"], a);&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["b"], b);&#9;&#9;/*&#9;&#9;Like range in a photo, the brightness will get clipped if we let it go above 1.&#9;&#9;Therefore, we divide by a large number to make sure that doesn&#x2019;t happen.&#9;&#9;Too large and everything will get compressed into too few dark values instead,&#9;&#9;so we need to pick a brightness scale in the middle.&#9;*/&#9;wilson_hidden.gl.uniform1f(wilson_hidden.uniforms["brightness_scale"], 20);&#9;&#9;wilson_hidden.render.draw_frame();&#9;&#9;&#9;&#9;let pixel_data = wilson_hidden.render.get_pixel_data();&#9;&#9;let brightnesses = new Array(resolution_hidden * resolution_hidden);&#9;&#9;for (let i = 0; i &lt; resolution_hidden * resolution_hidden; i++)&#9;{&#9;&#9;brightnesses[i] = pixel_data[4 * i] + pixel_data[4 * i + 1] + pixel_data[4 * i + 2];&#9;}&#9;&#9;brightnesses.sort((a, b) => a - b);&#9;&#9;//Both the .98 and 18 here were found experimentally.&#9;let brightness_scale = brightnesses[Math.floor(resolution_hidden * resolution_hidden * .98)] / 255 * 18;&#9;brightness_scale = Math.max(brightness_scale, .1);&#9;&#9;&#9;&#9;wilson.gl.uniform1f(wilson.uniforms["a"], a);&#9;wilson.gl.uniform1f(wilson.uniforms["b"], b);&#9;wilson.gl.uniform1f(wilson.uniforms["brightness_scale"], brightness_scale);&#9;&#9;wilson.render.draw_frame();}</code></pre><br><p class="body-text">Notice that we&#x2019;re sorting the brightnesses and throwing out the top 2% &mdash; this effectively removes outlier pixels and keeps the brightness stable frame-to-frame. Since the hidden canvas is so small, this sorting isn&#x2019;t expensive.</p><br><p class="body-text">To illustrate what&#x2019;s going on, the hidden canvas is superimposed on the output canvas here, but it should obviously be hidden in all other cases.</p><br><div class="text-boxes"><div class="text-box-container"><input id="resolution-input" class="text-box" type="text" value="1000" tabindex="1"><p class="body-text text-box-subtext">Resolution</p></div></div><div class="center-content" style="margin-bottom: 50px"><div id="container" style="position: relative; width: 70vmin; height: 70vmin" data-aos="fade-up"><div style="position: absolute; top: 0; left: 0; margin: 0"><canvas id="output-canvas" class="output-canvas"></canvas></div><div style="position: absolute; top: 0; left: 0; margin: 0; width: 15vmin; height: 15vmin"><canvas id="hidden-canvas" class="hidden-canvas-superimposed"></canvas></div></div></div><div class="text-buttons"><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-button" tabindex="-1">Download</button></div></div></section><section><p class="body-text">In the next section, we&#x2019;ll add the ability to run the applet in fullscreen, leveraging as much screen space as possible.</p><br><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/4-hidden-canvases/scripts/hidden-canvases.js">here</a>.</p><br><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div></section></main><script>if (typeof Page === "undefined"){if (window.location.search !== ""){window.location.replace("/index.html?page=" + encodeURIComponent(window.location.pathname) + "&" + window.location.search.slice(1));}else{window.location.replace("/index.html?page=" + encodeURIComponent(window.location.pathname));}}Page.settings = {"title": "Part 4: Hidden Canvases","math_page": true,"small_margins_on_ultrawide": true,"parent_list": "/projects/wilson/guide"};Page.load();</script></html>