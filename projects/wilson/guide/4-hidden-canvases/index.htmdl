### nav-buttons

One problem you probably noticed with the CPU canvas was a rapid fluctuation in brightness due to a high variation in the value of the brightest pixel. Now we have a different problem --- there's not a clear way to automatically control the brightness at all. One option is to try a value, then see how many pixels are at max brightness and slightly adjust the brightness scale on the next frame. This is expensive, though, and if the brightness changes suddenly, it will take a while to catch up. A better solution is to render a second canvas with the same shader at a very low resolution --- say 100x100 --- and no brightness scale at all. Then we can read off the max brightness from that canvas and use it for the output one.

This process is simple --- all we have to do is register a second canvas with Wilson and give it a similar set of options.



```html
	&lt;input id="resolution-input" type="text" value="1000"&gt;
	&lt;label for="resolution-input"&gt;
		&lt;p&gt;Resolution&lt;/p&gt;
	&lt;/label&gt;

	&lt;canvas id="hidden-canvas"&gt&lt;/canvas&gt;

	&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;
```

```css
	#hidden-canvas
	{
		position: fixed;
		left: -100px;
		width: 10px;
		height: 10px;
	}
```

```js
	let optionsHidden =
	{
		renderer: "gpu",
		
		shader: fragShaderSource,
		
		canvasWidth: 100,
		canvasHeight: 100
	};



	let wilsonHidden = new Wilson(document.querySelector("#hidden-canvas"), optionsHidden);

	wilsonHidden.render.initUniforms(["a", "b", "brightnessScale"]);
```

```js
	function drawJuliaSet(timestamp)
	{
		let timeElapsed = timestamp - lastTimestamp;
		
		lastTimestamp = timestamp;
		
		
		
		if (timeElapsed === 0)
		{
				return;
		}
		
		
		
		wilsonHidden.gl.uniform1f(wilsonHidden.uniforms["a"], a);
		wilsonHidden.gl.uniform1f(wilsonHidden.uniforms["b"], b);
		
		/*
			Like range in a photo, the brightness will get clipped if we let it go above 1.
			Therefore, we divide by a large number to make sure that doesn't happen.
			Too large and everything will get compressed into too few dark values instead,
			so we need to pick a brightness scale in the middle.
		*/
		wilsonHidden.gl.uniform1f(wilsonHidden.uniforms["brightnessScale"], 20);
		
		wilsonHidden.render.drawFrame();
		
		
		
		let pixelData = wilsonHidden.render.getPixelData();
		
		let brightnesses = new Array(resolutionHidden * resolutionHidden);
		
		for (let i = 0; i &lt; resolutionHidden * resolutionHidden; i++)
		{
			brightnesses[i] = pixelData[4 * i] + pixelData[4 * i + 1] + pixelData[4 * i + 2];
		}
		
		brightnesses.sort((a, b) => a - b);
		
		//Both the .98 and 18 here were found experimentally.
		let brightnessScale = brightnesses[Math.floor(resolutionHidden * resolutionHidden * .98)] / 255 * 18;
		
	brightnessScale = Math.max(brightnessScale, .1);
		
		
		
		wilson.gl.uniform1f(wilson.uniforms["a"], a);
		wilson.gl.uniform1f(wilson.uniforms["b"], b);
		wilson.gl.uniform1f(wilson.uniforms["brightnessScale"], brightnessScale);
		
		wilson.render.drawFrame();
	}
```



Notice that we're sorting the brightnesses and throwing out the top 2% --- this effectively removes outlier pixels and keeps the brightness stable frame-to-frame. Since the hidden canvas is so small, this sorting isn't expensive.



### text-boxes
	resolution 1000 "Resolution"
###

<div class="center-content">
	<div id="canvas-landscape-middle">
		<canvas id="output-canvas" class="output-canvas"></canvas>
		<canvas id="hidden-canvas" class="hidden-canvas"></canvas>
	</div>
</div>

### buttons
	download "Download"
###



<div style="height: 32px"></div>

In the next section, we'll add the ability to run the applet in fullscreen, leveraging as much screen space as possible.

You can view the code for this page <a href="/projects/wilson/guide/4-hidden-canvases/scripts/index.js">here</a>.



### nav-buttons