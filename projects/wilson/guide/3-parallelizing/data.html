<header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.png" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Part 3: Parallelizing</h1></header><main><section><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div><p class="body-text">There are a handful of features we could build in next, but we&#x2019;re overdue for one in particular: moving the math onto the GPU. This is called <em>parallelizing</em>, and it&#x2019;s not something that&#x2019;s possible for every applet: every pixel will be processed independently of every other, so information cannot be shared between them. For example, an applet that renders an iterated function system by tracking the orbit of a single point across millions of iterations will not lend itself well to parallelization. A Julia set, on the other hand, is a perfect candidate.</p><p class="body-text">The technology for GPU-based applets on the web is called WebGL &mdash; traditionally, it&#x2019;s used for 3D applets and games that use raster graphics. Wilson does <em>not</em> support any of that &mdash; if you need high-performance raster graphics, look to something like <a href="https://threejs.org">three.js</a> instead. What Wilson provides is a stripped-down environment where getting WebGL to work only requires a fragment shader, something that normally takes hundreds of lines of boilerplate.</p><p class="body-text">Although it&#x2019;s nice to only have to write that fragment shader, actually writing it can be challenging. It&#x2019;s not written in JavaScript, but rather in a language called GLSL that&#x2019;s very unforgiving &mdash; for example, writing a number as <code>3</code> instead of <code>3.0</code> or <code>3.</code> will most likely cause the entire program to crash with a generic error message and no ability to debug. Writing GLSL is an exercise in extreme caution and frequent testing, but the upshot is <em>massively</em> improved performance &mdash; it&#x2019;s not at all uncommon to see a 100x jump in the number of pixels that can be rendered per frame, though this of course depends on the relative power of the CPU and the GPU. If your applet is parallelizable, you owe it to yourself to get it working in GLSL.</p><p class="body-text">To get started, we&#x2019;ll change the renderer setting once again, this time to <code>renderer: "gpu"</code>. After that, we need to write our shader, tell Wilson what uniforms (i.e. parameters) the shader has, and then change some of our existing code to set those variables properly. Let&#x2019;s take this one step at a time, starting with the shader.</p><pre><code class="language-glsl">let fragShaderSource = `
&#9;precision highp float;
&#9;
&#9;varying vec2 uv;
&#9;
&#9;uniform float a;
&#9;uniform float b;
&#9;uniform float brightnessScale;
&#9;
&#9;
&#9;
&#9;void main(void)
&#9;{
&#9;vec2 z = vec2(uv.x * 2.0, uv.y * 2.0);
&#9;vec3 color = normalize(vec3(abs(z.x + z.y) / 2.0, abs(z.x) / 2.0, abs(z.y) / 2.0) + .1 / length(z) * vec3(1.0, 1.0, 1.0));
&#9;float brightness = exp(-length(z));
&#9;
&#9;
&#9;
&#9;vec2 c = vec2(a, b);
&#9;
&#9;for (int iteration = 0; iteration &lt; 100; iteration++)
&#9;{
&#9;&#9;if (iteration == 99)
&#9;&#9;{
&#9;&#9;gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
&#9;&#9;return;
&#9;&#9;}
&#9;&#9;
&#9;&#9;if (length(z) >= 2.0)
&#9;&#9;{
&#9;&#9;break;
&#9;&#9;}
&#9;&#9;
&#9;&#9;z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
&#9;&#9;
&#9;&#9;brightness += exp(-length(z));
&#9;}
&#9;
&#9;
&#9;gl_FragColor = vec4(brightness / brightnessScale * color, 1.0);
&#9;}
`;
</code></pre><p class="body-text">While a proper introduction to GLSL is well outside the scope of this guide, let&#x2019;s touch on some of the important points from this shader in particular.</p><p class="body-text"><code>precision highp float</code>: this should go at the start of every shader since it maximizes precision. <code>mediump</code> can also be used, but for a math applet, that tends to be a bad idea &mdash; WebGL doesn&#x2019;t even support doubles, so we need all the precision we can get.</p><p class="body-text"><code>varying vec2 uv</code>: here, <code>varying</code> means varying from pixel to pixel. This is the variable that gives the position of the current pixel, on a scale from -1 to 1 in both the x and y directions, and when using Wilson, the variable name <code>uv</code> must be used. Looking through the rest of the shader, we can see <code>int</code>, <code>float</code>, and other C-like variable declarations, along with <code>vec2</code> and <code>vec3</code>. These last two are effectively float arrays with multiplication and addition implemented componentwise. The maximum size is a <code>vec4</code>, and there are 2&ndash;4 dimensional matrices available, too. In general, math should be done with vectors whenever possible, though optimizing for the GPU is its own topic.</p><p class="body-text"><code>uniform float a</code>: as opposed to <code>varying</code>, <code>uniform</code> means a value that is the same across all the pixels, but can be changed frame-to-frame without reloading the entire shader. Once we&#x2019;ve given Wilson our shader, we&#x2019;ll have to tell it where the uniforms are in order to actually do that.</p><p class="body-text"><code>vec2 z = vec2(uv.x * 2.0, uv.y * 2.0)</code>: this scales <code>uv</code> to world coordinates. Note that <code>vec2</code> is a constructor as well as a type, and that we can access the first component of <code>uv</code> with <code>uv.x</code>. More complicated syntax is possible, called <em>swizzling</em>: <code>uv.xyyx</code> gets a <code>vec4</code> whose first and last elements are <code>uv.x</code> and whose middle two are <code>uv.y</code>.</p><p class="body-text"><code>length</code>, <code>normalize</code>, <code>abs</code>, etc.: GLSL has a large number of built-in functions for performing operations on vectors. Before writing some potentially inefficient code to handle a common operation, it&#x2019;s worth checking if it&#2019;s natively implemented first.</p><p class="body-text"><code>gl_FragColor</code>: this is how we actually set the pixel color &mdash; the data is given as a <code>vec4</code> corresponding to the RGBA values on a scale of 0&ndash;1.</p><p class="body-text">The color choice at the start is just something I came up with through trial and error, and creates a palette I think looks nice &mdash; definitely better than the uniform cyan we had before.</p><p class="body-text">This should be enough to get started writing your own shaders. Remember &mdash; test your code every handful of lines, or you&#x2019;ll have a painful debugging process ahead of you!</p><p class="body-text">Now we need to add the shader in the options, and we also have to tell Wilson where the uniforms are so we can change them. This is done with a single function call.</p><pre><code class="language-js">let options =
{
&#9;renderer: "gpu",
&#9;
&#9;shader: fragShaderSource,
&#9;
&#9;...
};



let wilson = new Wilson(document.querySelector("#output-canvas"), options);

wilson.render.initUniforms(["a", "b", "brightnessScale"]);
</code></pre><p class="body-text">A few other things need to change. We no longer need <code>generateJuliaSet</code>, since that computation will be done on the GPU. Similarly, we also no longer pass anything to <code>wilson.render.drawFrame</code>. The performance increase will be large enough that 1000 is now a reasonable resolution for most users, and that&#x2019;s high enough that we won&#x2019;t bother with raising the resolution when we let the draggable go. Finally, we need to actually set those uniforms.</p><pre><code class="language-js">let a = 0;
let b = 1;

let resolution = 1000;

let lastTimestamp = -1;



let resolutionInputElement = document.querySelector("#resolution-input");

resolutionInputElement.addEventListener("input", () =>
{
&#9;resolution = parseInt(resolutionInputElement.value || 1000);
&#9;
&#9;wilson.changeCanvasSize(resolution, resolution);
});



let downloadButtonElement = document.querySelector("#download-button");

downloadButtonElement.addEventListener("click", () =>
{
&#9;wilson.downloadFrame("a-julia-set.png");
});



//Render the inital frame.
window.requestAnimationFrame(drawJuliaSet);



function onDrag(activeDraggable, x, y, event)
{
&#9;a = x;
&#9;b = y;
&#9;
&#9;window.requestAnimationFrame(drawJuliaSet);
}



function drawJuliaSet(timestamp)
{
&#9;let timeElapsed = timestamp - lastTimestamp;
&#9;
&#9;lastTimestamp = timestamp;
&#9;
&#9;
&#9;
&#9;if (timeElapsed === 0)
&#9;{
&#9;&#9;return;
&#9;}
&#9;
&#9;
&#9;
&#9;wilson.gl.uniform1f(wilson.uniforms["a"], a);
&#9;wilson.gl.uniform1f(wilson.uniforms["b"], b);
&#9;wilson.gl.uniform1f(wilson.uniforms["brightnessScale"], 10);
&#9;
&#9;wilson.render.drawFrame();
}
</code></pre><p class="body-text">The name of the function that sets the uniforms changes depending on the type of the variable: For a single <code>float</code>, it&#x2019;s <code>uniform1f</code>, but for an <code>int</code>, it would be <code>uniform1i</code>. Vectors can be set in two ways: to give a <code>vec2</code> a value of <code>2</code> in its first coordinate and <code>4</code> in its second, we can use <code>uniform2f(wilson.uniforms["varName"], 2, 4)</code> or <code>uniform2fv(wilson.uniforms["varName"], [2, 4])</code>.</p><p class="body-text">Hopefully WebGL doesn&#x2019;t seem quite so scary anymore! If you haven&#x2019;t been copying the code into your own project so far, now is a great time to start &mdash; experimenting with the shader is a great way to get familiar with GLSL.</p><div class='text-boxes'><div class="text-box-container"><input id="resolution-input" class="text-box" type="text" value="1000" tabindex="1"><p class="body-text text-box-subtext">Resolution</p></div></div><div class="center-content"><div id="canvas-landscape-middle"><canvas id="output-canvas" class="output-canvas"></canvas></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-button" tabindex="-1"></button></div></div><div style="height: 32px"></div><p class="body-text">Hopefully the performance increase is apparent! At the time of writing, my computer can only handle about a 500x500 CPU-driven canvas before it starts to drop below 60fps, but a 5000x5000 GPU-driven one is still silky smooth. In the next section, we&#x2019;ll add a second, hidden canvas that we can leverage to efficiently find a good brightness scale.</p><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/3-parallelizing/scripts/index.js">here</a>.</p><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div></section></main>