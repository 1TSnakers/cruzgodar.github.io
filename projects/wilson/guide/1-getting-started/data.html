<header><div id="logo"><a href="/home/" tabindex="-1"><img src="/graphics/general-icons/logo.png" alt="Logo" tabindex="1"></img></a></div><div style="height: 20px"></div><h1 class="heading-text">Part 1: Getting Started</h1></header><main><section><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div><p class="body-text">Welcome! In this guide, we&#x2019;ll use Wilson to create the Julia set explorer featured on the main page. We&#x2019;ll do this one step at a time, starting with the simplest and most stripped-down version possible and gradually adding features. You might want to have the <a href="/projects/wilson/docs/">documentation</a> open while going through this.</p><p class="body-text">First, some background: a Julia set is a famous type of fractal closely related to the Mandelbrot set. Unlike the Mandelbrot, though, there are infinitely many Julia sets, each one corresponding to a different complex number. Because of this, Julia set applets often focus on generating different Julia sets rather than zooms of a single one, and this is where we&#x2019;ll start too. Right now, let&#x2019;s not worry about interactivity: we&#x2019;ll just have the user enter the complex number <span class="tex-holder inline-math" data-source-tex="c">$c$</span> and display the Julia set corresponding to it.</p><p class="body-text">Once we&#x2019;ve included <code>wilson.js</code>, we need to make a canvas and some input fields in the HTML.</p><pre><code class="language-html">&lt;input id="a-input" type="text" value="0"&gt;
&lt;label for="a-input"&gt;
&#9;&lt;p&gt;a&lt;/p&gt;
&lt;/label&gt;

&lt;input id="b-input" type="text" value="1"&gt;
&lt;label for="b-input"&gt;
&#9;&lt;p&gt;b&lt;/p&gt;
&lt;/label&gt;

&lt;input id="resolution-input" type="text" value="500"&gt;
&lt;label for="resolution-input"&gt;
&#9;&lt;p&gt;Resolution&lt;/p&gt;
&lt;/label&gt;

&lt;button id="generate-button" type="button"&gt;Generate&lt;/button&gt;

&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;
</code></pre><p class="body-text">This obviously doesn&#x2019;t look too great without any added CSS. The displayed canvases and input fields on this page will be styled, but the CSS will be omitted for brevity.</p><p class="body-text">On the JS side, we need to tell Wilson we want it to work with this canvas.</p><pre><code class="language-js">let options =
{
&#9;renderer: "cpu",
&#9;
&#9;canvasWidth: 500,
&#9;canvasHeight: 500
};

let wilson = new Wilson(document.querySelector("#output-canvas"), options);



let aInputElement = document.querySelector("#a-input");
let bInputElement = document.querySelector("#b-input");
let resolutionInputElement = document.querySelector("#resolution-input");

let generateButtonElement = document.querySelector("#generate-button");

generateButtonElement.addEventListener("click", () =>
{
&#9;let a = parseFloat(aInputElement.value || 0);
&#9;let b = parseFloat(bInputElement.value || 1);
&#9;let resolution = parseInt(resolutionInputElement.value || 500);
&#9;
&#9;wilson.changeCanvasSize(resolution, resolution);
&#9;
&#9;//Do something with a and b.
});
</code></pre><p class="body-text">Those initial values of 500 are just placeholders &mdash; they&#x2019;re changed whenever the generate button is pressed. Now we just need to write a function that generates a Julia set given these parameters. The first step for that function will be to convert between pixel coordinates on the canvas and complex numbers in the plane, and this is a common enough occurance in math applets that Wilson has built-in functions for handling it: we need to add information in the options about the &#x201C;world coordinates&#x201D;, as Wilson calls them, and then we can call <code>wilson.utils.interpolate.canvasToWorld</code> and <code>wilson.utils.interpolate.worldToCanvas</code>, which convert between pairs (row, col) of canvas coordinates and (x, y) of world coordinates. Note that <code>row</code> increases from top to bottom, while <code>y</code> does the opposite.</p><p class="body-text">The algorithm to color a single point <span class="tex-holder inline-math" data-source-tex="z_0">$z_0$</span> of the Julia set corresponding to <span class="tex-holder inline-math" data-source-tex="c = a + bi">$c = a + bi$</span> is relatively simple: with <span class="tex-holder inline-math" data-source-tex="f(z) = z^2 + c">$f(z) = z^2 + c$</span>, we let <span class="tex-holder inline-math" data-source-tex="z_1 = f(z_0)">$z_1 = f(z_0)$</span>, <span class="tex-holder inline-math" data-source-tex="z_2 = f(z_1)">$z_2 = f(z_1)$</span>, and so on. If the <span class="tex-holder inline-math" data-source-tex="z_n">$z_n$</span> grow without bound, then the point <span class="tex-holder inline-math" data-source-tex="z_0">$z_0$</span> is <em>not</em> in the Julia set, and we give it a color based on how quickly it grew. If the <span class="tex-holder inline-math" data-source-tex="z_n">$z_n$</span> stay bounded, then <span class="tex-holder inline-math" data-source-tex="z_0">$z_0$</span> is in the set, and we color it black. In practice, we pick a maximum value for <span class="tex-holder inline-math" data-source-tex="n">$n$</span>, say 100, and see if the sequence is smaller than a certain bound after that many iterations. It can be shown that if the magnitude of any <span class="tex-holder inline-math" data-source-tex="z_n">$z_n$</span> is ever larger than 2, then the subsequent terms will grow without bound, so that&#x2019;s the typical threshhold to measure against.</p><pre><code class="language-js">let options =
{
&#9;renderer: "cpu",
&#9;
&#9;canvasWidth: 500,
&#9;canvasHeight: 500,
&#9;
&#9;worldWidth: 4,
&#9;worldHeight: 4,
&#9;worldCenterX: 0,
&#9;worldCenterY: 0
};
</code></pre><pre><code class="language-js">function generateJuliaSet(a, b, resolution)
{
&#9;let brightnesses = new Array(resolution * resolution);
&#9;let maxBrightness = 0;
&#9;let brightnessScale = 1.5;
&#9;const numIterations = 100;
&#9;
&#9;for (let i = 0; i &lt; resolution; i++)
&#9;{
&#9;for (let j = 0; j &lt; resolution; j++)
&#9;{
&#9;&#9;let worldCoordinates = wilson.utils.interpolate.canvasToWorld(i, j);
&#9;&#9;let x = worldCoordinates[0];
&#9;&#9;let y = worldCoordinates[1];
&#9;&#9;
&#9;&#9;//This helps remove color banding.
&#9;&#9;let brightness = Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;
&#9;&#9;let k = 0;
&#9;&#9;
&#9;&#9;for (k = 0; k &lt; numIterations; k++)
&#9;&#9;{
&#9;&#9;//z = z^2 + c = (x^2 - y^2 + a) + (2xy + b)i
&#9;&#9;let temp = x*x - y*y + a;
&#9;&#9;y = 2*x*y + b;
&#9;&#9;x = temp;
&#9;&#9;
&#9;&#9;brightness += Math.exp(-Math.sqrt(x*x + y*y));
&#9;&#9;
&#9;&#9;if (x*x + y*y > 4)
&#9;&#9;{
&#9;&#9;&#9;break;
&#9;&#9;}
&#9;&#9;}
&#9;&#9;
&#9;&#9;if (k === numIterations)
&#9;&#9;{
&#9;&#9;//Color this pixel black.
&#9;&#9;brightnesses[resolution * i + j] = 0;
&#9;&#9;}
&#9;&#9;
&#9;&#9;else
&#9;&#9;{
&#9;&#9;brightnesses[resolution * i + j] = brightness;
&#9;&#9;
&#9;&#9;if (brightness > maxBrightness)
&#9;&#9;{
&#9;&#9;&#9;maxBrightness = brightness;
&#9;&#9;}
&#9;&#9;}
&#9;}
&#9;}
&#9;
&#9;//Now we need to create the actual pixel data in a Uint8ClampedArray to pass to Wilson.
&#9;let imageData = new Uint8ClampedArray(resolution * resolution * 4);
&#9;
&#9;for (let i = 0; i &lt; resolution * resolution; i++)
&#9;{
&#9;imageData[4 * i] = 0; //Red
&#9;imageData[4 * i + 1] = brightnessScale * brightnesses[i] / maxBrightness * 255; //Green
&#9;imageData[4 * i + 2] = brightnessScale * brightnesses[i] / maxBrightness * 255; //Blue
&#9;imageData[4 * i + 3] = 255; //Alpha
&#9;}
&#9;
&#9;return imageData;
}
</code></pre><pre><code class="language-js">let aInputElement = document.querySelector("#a-input");
let bInputElement = document.querySelector("#b-input");
let resolutionInputElement = document.querySelector("#resolution-input");

let generateButtonElement = document.querySelector("#generate-button");

generateButtonElement.addEventListener("click", () =>
{
&#9;let a = parseFloat(aInputElement.value || 0);
&#9;let b = parseFloat(bInputElement.value || 1);
&#9;let resolution = parseInt(resolutionInputElement.value || 500);
&#9;
&#9;wilson.changeCanvasSize(resolution, resolution);
&#9;
&#9;window.requestAnimationFrame(() => wilson.render.drawFrame(generateJuliaSet(a, b, resolution)));
});
</code></pre><p class="body-text">The weirdness with the exponentials is a technique to reduce color banding &mdash; if we just used the raw iteration numbers for brightness values, we&#x2019;d see stripes of different brightness wherever that number increased or decreased by one. Basing the color partly on the values of the <span class="tex-holder inline-math" data-source-tex="z_n">$z_n$</span> introduces dithering &mdash; just enough noise that the color bands are blurred out.</p><p class="body-text">The brightness scale variable is a value that I found experimentally. When we make Julia set renders, there will typically be a handful of pixels that are significanly brighter than the rest, resulting in a much darker image overall. This is hard to exactly counteract without sorting the list of brightnesses and picking one a little bit down from the top &mdash; and we&#x2019;ll get there eventually &mdash; but right now, that would require a massive sort every frame. Instead, we can get a good result by just finding a factor experimentally that gets the majority of the pixels in full range of 0&ndash;255.</p><p class="body-text">If you&#x2019;re not famaliar with <code>window.requestAnimationFrame</code>, it calls the function we pass it on the first frame when the page can handle it. Nothing else on this page is going to impact performance to make this important, but later on we&#x2019;ll need it to keep our code from rendering multiple frames within a one-frame interval, needlessly impacting performance. Because of that, it&#x2019;s good practice to always use <code>requestAnimationFrame</code>.</p><p class="body-text">With all that explanation out of the way, let&#x2019;s see how the applet turned out!</p><div class='text-boxes'><div class="text-box-container"><input id="a-1-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div><div class="text-box-container"><input id="b-1-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div><div class="text-box-container"><input id="resolution-1-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="generate-1-button" tabindex="-1"></button></div></div><div class="center-content"><div id="canvas-landscape-middle"><p class="body-text">&#9;<canvas id="output-canvas-1" class="output-canvas"></canvas></p></div></div></section><h2 class="section-text"> A Different Renderer</h2><section><p class="body-text">This is a great start, but we have a lot more to do, and the first and easiest change to make is to modify the renderer. We currently have the line <code>renderer: "cpu"</code> in our options, which means that when we pass Wilson our pixel data, it gets copied into the canvas by JavaScript. A slightly better alternative is to render the canvas with WebGL and pass in the pixel data as a texture. This can marginally increase performance, and on some browers, it also increases the maximum possible canvas size. Hearing the word WebGL might make you a little nervous, and maybe rightfully so, but we don&#x2019;t actually have to interface with it at all right now. Just replacing that line in the options with <code>renderer: "hybrid"</code> is enough to change everything necessary on the backend.</p><p class="body-text">As another improvement, let&#x2019;s add a button to download the current state of the canvas &mdash; we need a better way to get the applet&#x2019;s output than taking a screenshot.</p><pre><code class="language-js">let options =
{
&#9;renderer: "hybrid",
&#9;
&#9;canvasWidth: 500,
&#9;canvasHeight: 500,
&#9;
&#9;worldWidth: 4,
&#9;worldHeight: 4,
&#9;worldCenterX: 0,
&#9;worldCenterY: 0
};
</code></pre><pre><code class="language-js">let downloadButtonElement = document.querySelector("#download-button");

downloadButtonElement.addEventListener("click", () =>
{
&#9;wilson.downloadFrame("a-julia-set.png");
});
</code></pre><div class='text-boxes'><div class="text-box-container"><input id="a-2-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div><div class="text-box-container"><input id="b-2-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div><div class="text-box-container"><input id="resolution-2-input" class="text-box" type="text" value="" tabindex="1"><p class="body-text text-box-subtext"></p></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="generate-2-button" tabindex="-1"></button></div></div><div class="center-content"><div id="canvas-landscape-middle"><canvas id="output-canvas-2" class="output-canvas"></canvas></div></div><div class='text-buttons'><div class="focus-on-child" tabindex="1"><button class="text-button" type="button" id="download-2-button" tabindex="-1"></button></div></div><div style="height: 32px"></div><p class="body-text">We&#x2019;re getting somewhere! In the next section, we&#x2019;ll add the first bit of interactivity in the form of a draggable selector for <span class="tex-holder inline-math" data-source-tex="c">$c$</span>.</p><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/1-getting-started/scripts/index.js">here</a>.</p><div class="text-buttons nav-buttons"><div class="focus-on-child tabindex="1"><button class="text-button linked-text-button previous-nav-button" type="button" tabindex="-1">Previous</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button home-nav-button" type="button" tabindex="-1">Home</button></div><div class="focus-on-child" tabindex="1"><button class="text-button linked-text-button next-nav-button" type="button" tabindex="-1">Next</button></div></div></section></main>