<!DOCTYPE html><html lang="en"><head><title>Cruz Godar</title><meta property="og:title" content="Cruz Godar"/><meta property="og:type" content="website"/><meta property="og:url" content="https://cruzgodar.com/projects/wilson/guide/1-getting-started/"/><meta property="og:image" content="https://cruzgodar.com/projects/wilson/guide/1-getting-started/cover.jpg"/><meta property="og:locale" content="en_US"/><meta property="og:site_name" content="Cruz Godar"/><style>body {opacity: 0;}</style></head><body><noscript><p class="body-text" style="text-align: center">JavaScript is required to use this site and many others. Consider enabling it.</p></noscript><p class="body-text">header Part 1: Getting Started</p><p class="body-text">nav-buttons</p><p class="body-text">begin-text-block</p><p class="body-text">Welcome! In this guide, we&#x2019;ll use Wilson to create the Julia set explorer featured on the main page. We&#x2019;ll do this one step at a time, starting with the simplest and most stripped-down version possible and gradually adding features. You might want to have the <a href="/projects/wilson/docs/">documentation</a> open while going through this.</p><p class="body-text">First, some background: a Julia set is a famous type of fractal closely related to the Mandelbrot set. Unlike the Mandelbrot, though, there are infinitely many Julia sets, each one corresponding to a different complex number. Because of this, Julia set applets often focus on generating different Julia sets rather than zooms of a single one, and this is where we&#x2019;ll start too. Right now, let&#x2019;s not worry about interactivity: we&#x2019;ll just have the user enter the complex number \(c\) and display the Julia set corresponding to it.</p><p class="body-text">Once we&#x2019;ve included <code>wilson.js</code>, we need to make a canvas and some input fields in the HTML.</p><p class="body-text">end-text-block</p><pre><code class="language-html" data-aos="fade-up">&lt;input id="a-input" type="text" value="0"&gt;<p class="body-text">&lt;label for="a-input"&gt;</p><p class="body-text">&#9;&lt;p&gt;a&lt;/p&gt;</p><p class="body-text">&lt;/label&gt;</p><p class="body-text">&lt;input id="b-input" type="text" value="1"&gt;</p><p class="body-text">&lt;label for="b-input"&gt;</p><p class="body-text">&#9;&lt;p&gt;b&lt;/p&gt;</p><p class="body-text">&lt;/label&gt;</p><p class="body-text">&lt;input id="resolution-input" type="text" value="500"&gt;</p><p class="body-text">&lt;label for="resolution-input"&gt;</p><p class="body-text">&#9;&lt;p&gt;Resolution&lt;/p&gt;</p><p class="body-text">&lt;/label&gt;</p><p class="body-text">&lt;button id="generate-button" type="button"&gt;Generate&lt;/button&gt;</p><p class="body-text">&lt;canvas id="output-canvas"&gt&lt;/canvas&gt;</code></pre></p><br><p class="body-text">begin-text-block</p><p class="body-text">This obviously doesn&#x2019;t look too great without any added CSS. The displayed canvases and input fields on this page will be styled, but the CSS will be omitted for brevity.</p><p class="body-text">On the JS side, we need to tell Wilson we want it to work with this canvas.</p><p class="body-text">end-text-block</p><pre><code class="language-js" data-aos="fade-up">let options =<p class="body-text">{</p><p class="body-text">&#9;renderer: "cpu",</p><p class="body-text">&#9;</p><p class="body-text">&#9;canvas_width: 500,</p><p class="body-text">&#9;canvas_height: 500</p><p class="body-text">};</p><p class="body-text">let wilson = new Wilson(document.querySelector("#output-canvas"), options);</p><p class="body-text">let a_input_element = document.querySelector("#a-input");</p><p class="body-text">let b_input_element = document.querySelector("#b-input");</p><p class="body-text">let resolution_input_element = document.querySelector("#resolution-input");</p><p class="body-text">let generate_button_element = document.querySelector("#generate-button");</p><p class="body-text">generate_button_element.addEventListener("click", () =></p><p class="body-text">{</p><p class="body-text">&#9;let a = parseFloat(a_input_element.value || 0);</p><p class="body-text">&#9;let b = parseFloat(b_input_element.value || 1);</p><p class="body-text">&#9;let resolution = parseInt(resolution_input_element.value || 500);</p><p class="body-text">&#9;</p><p class="body-text">&#9;wilson.change_canvas_size(resolution, resolution);</p><p class="body-text">&#9;</p><p class="body-text">&#9;//Do something with a and b.</p><p class="body-text">});</code></pre></p><br><p class="body-text">begin-text-block</p><p class="body-text">Those initial values of 500 are just placeholders &mdash; they&#x2019;re changed whenever the generate button is pressed. Now we just need to write a function that generates a Julia set given these parameters. The first step for that function will be to convert between pixel coordinates on the canvas and complex numbers in the plane, and this is a common enough occurance in math applets that Wilson has built-in functions for handling it: we need to add information in the options about the &#x201C;world coordinates&#x201D;, as Wilson calls them, and then we can call <code>wilson.utils.interpolate.canvas_to_world</code> and <code>wilson.utils.interpolate.world_to_canvas</code>, which convert between pairs (row, col) of canvas coordinates and (x, y) of world coordinates. Note that <code>row</code> increases from top to bottom, while <code>y</code> does the opposite.</p><p class="body-text">The algorithm to color a single point \(z_0\) of the Julia set corresponding to \(c = a + bi\) is relatively simple: with \(f(z) = z^2 + c\), we let \(z_1 = f(z_0)\), \(z_2 = f(z_1)\), and so on. If the \(z_n\) grow without bound, then the point \(z_0\) is <em>not</em> in the Julia set, and we give it a color based on how quickly it grew. If the \(z_n\) stay bounded, then \(z_0\) is in the set, and we color it black. In practice, we pick a maximum value for \(n\), say 100, and see if the sequence is smaller than a certain bound after that many iterations. It can be shown that if the magnitude of any \(z_n\) is ever larger than 2, then the subsequent terms will grow without bound, so that&#x2019;s the typical threshhold to measure against.</p><p class="body-text">end-text-block</p><pre><code class="language-js" data-aos="fade-up">let options =<p class="body-text">{</p><p class="body-text">&#9;renderer: "cpu",</p><p class="body-text">&#9;</p><p class="body-text">&#9;canvas_width: 500,</p><p class="body-text">&#9;canvas_height: 500,</p><p class="body-text">&#9;</p><p class="body-text">&#9;world_width: 4,</p><p class="body-text">&#9;world_height: 4,</p><p class="body-text">&#9;world_center_x: 0,</p><p class="body-text">&#9;world_center_y: 0</p><p class="body-text">};</code></pre></p><br><pre><code class="language-js" data-aos="fade-up">function generate_julia_set(a, b, resolution)<p class="body-text">{</p><p class="body-text">&#9;let brightnesses = new Array(resolution * resolution);</p><p class="body-text">&#9;let max_brightness = 0;</p><p class="body-text">&#9;let brightness_scale = 1.5;</p><p class="body-text">&#9;const num_iterations = 100;</p><p class="body-text">&#9;</p><p class="body-text">&#9;for (let i = 0; i &lt; resolution; i++)</p><p class="body-text">&#9;{</p><p class="body-text">&#9;&#9;for (let j = 0; j &lt; resolution; j++)</p><p class="body-text">&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;let world_coordinates = wilson.utils.interpolate.canvas_to_world(i, j);</p><p class="body-text">&#9;&#9;&#9;let x = world_coordinates[0];</p><p class="body-text">&#9;&#9;&#9;let y = world_coordinates[1];</p><p class="body-text">&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;//This helps remove color banding.</p><p class="body-text">&#9;&#9;&#9;let brightness = Math.exp(-Math.sqrt(x<em>x + y</em>y));</p><p class="body-text">&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;let k = 0;</p><p class="body-text">&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;for (k = 0; k &lt; num_iterations; k++)</p><p class="body-text">&#9;&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;&#9;//z = z^2 + c = (x^2 - y^2 + a) + (2xy + b)i</p><p class="body-text">&#9;&#9;&#9;&#9;let temp = x<em>x - y</em>y + a;</p><p class="body-text">&#9;&#9;&#9;&#9;y = 2<em>x</em>y + b;</p><p class="body-text">&#9;&#9;&#9;&#9;x = temp;</p><p class="body-text">&#9;&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;&#9;brightness += Math.exp(-Math.sqrt(x<em>x + y</em>y));</p><p class="body-text">&#9;&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;&#9;if (x<em>x + y</em>y > 4)</p><p class="body-text">&#9;&#9;&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;&#9;&#9;break;</p><p class="body-text">&#9;&#9;&#9;&#9;}</p><p class="body-text">&#9;&#9;&#9;}</p><p class="body-text">&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;if (k === num_iterations)</p><p class="body-text">&#9;&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;&#9;//Color this pixel black.</p><p class="body-text">&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = 0;</p><p class="body-text">&#9;&#9;&#9;}</p><p class="body-text">&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;else</p><p class="body-text">&#9;&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;&#9;brightnesses[resolution * i + j] = brightness;</p><p class="body-text">&#9;&#9;&#9;&#9;</p><p class="body-text">&#9;&#9;&#9;&#9;if (brightness > max_brightness)</p><p class="body-text">&#9;&#9;&#9;&#9;{</p><p class="body-text">&#9;&#9;&#9;&#9;&#9;max_brightness = brightness;</p><p class="body-text">&#9;&#9;&#9;&#9;}</p><p class="body-text">&#9;&#9;&#9;}</p><p class="body-text">&#9;&#9;}</p><p class="body-text">&#9;}</p><p class="body-text">&#9;</p><p class="body-text">&#9;//Now we need to create the actual pixel data in a Uint8ClampedArray to pass to Wilson.</p><p class="body-text">&#9;let image_data = new Uint8ClampedArray(resolution <em> resolution </em> 4);</p><p class="body-text">&#9;</p><p class="body-text">&#9;for (let i = 0; i &lt; resolution * resolution; i++)</p><p class="body-text">&#9;{</p><p class="body-text">&#9;&#9;image_data[4 * i] = 0; //Red</p><p class="body-text">&#9;&#9;image_data[4 <em> i + 1] = brightness_scale </em> brightnesses[i] / max_brightness * 255; //Green</p><p class="body-text">&#9;&#9;image_data[4 <em> i + 2] = brightness_scale </em> brightnesses[i] / max_brightness * 255; //Blue</p><p class="body-text">&#9;&#9;image_data[4 * i + 3] = 255; //Alpha</p><p class="body-text">&#9;}</p><p class="body-text">&#9;</p><p class="body-text">&#9;return image_data;</p><p class="body-text">}</code></pre></p><br><pre><code class="language-js" data-aos="fade-up">let a_input_element = document.querySelector("#a-input");<p class="body-text">let b_input_element = document.querySelector("#b-input");</p><p class="body-text">let resolution_input_element = document.querySelector("#resolution-input");</p><p class="body-text">let generate_button_element = document.querySelector("#generate-button");</p><p class="body-text">generate_button_element.addEventListener("click", () =></p><p class="body-text">{</p><p class="body-text">&#9;let a = parseFloat(a_input_element.value || 0);</p><p class="body-text">&#9;let b = parseFloat(b_input_element.value || 1);</p><p class="body-text">&#9;let resolution = parseInt(resolution_input_element.value || 500);</p><p class="body-text">&#9;</p><p class="body-text">&#9;wilson.change_canvas_size(resolution, resolution);</p><p class="body-text">&#9;</p><p class="body-text">&#9;window.requestAnimationFrame(() => wilson.render.draw_frame(generate_julia_set(a, b, resolution)));</p><p class="body-text">});</code></pre></p><br><p class="body-text">begin-text-block</p><p class="body-text">The weirdness with the exponentials is a technique to reduce color banding &mdash; if we just used the raw iteration numbers for brightness values, we&#x2019;d see stripes of different brightness wherever that number increased or decreased by one. Basing the color partly on the values of the \(z_n\) introduces dithering &mdash; just enough noise that the color bands are blurred out.</p><p class="body-text">The brightness scale variable is a value that I found experimentally. When we make Julia set renders, there will typically be a handful of pixels that are significanly brighter than the rest, resulting in a much darker image overall. This is hard to exactly counteract without sorting the list of brightnesses and picking one a little bit down from the top &mdash; and we&#x2019;ll get there eventually &mdash; but right now, that would require a massive sort every frame. Instead, we can get a good result by just finding a factor experimentally that gets the majority of the pixels in full range of 0&ndash;255.</p><p class="body-text">If you&#x2019;re not famaliar with <code>window.requestAnimationFrame</code>, it calls the function we pass it on the first frame when the page can handle it. Nothing else on this page is going to impact performance to make this important, but later on we&#x2019;ll need it to keep our code from rendering multiple frames within a one-frame interval, needlessly impacting performance. Because of that, it&#x2019;s good practice to always use <code>requestAnimationFrame</code>.</p><p class="body-text">With all that explanation out of the way, let&#x2019;s see how the applet turned out!</p><p class="body-text">end-text-block</p><br><p class="body-text">begin-text-boxes</p><p class="body-text">a-1 0 \(a\)</p><p class="body-text">b-1 1 \(b\)</p><p class="body-text">resolution-1 500 Resolution</p><p class="body-text">end-text-boxes</p><p class="body-text">begin-text-buttons</p><p class="body-text">generate-1 Generate</p><p class="body-text">end-text-buttons</p><div class="center-content" data-aos="fade-up"><div style="width: 70vmin"><canvas id="output-canvas-1" class="output-canvas"></canvas></div></div><p class="body-text">section</p><p class="body-text">text s A Different Renderer</p><br><p class="body-text">begin-text-block</p><p class="body-text">This is a great start, but we have a lot more to do, and the first and easiest change to make is to modify the renderer. We currently have the line <code>renderer: "cpu"</code> in our options, which means that when we pass Wilson our pixel data, it gets copied into the canvas by JavaScript. A slightly better alternative is to render the canvas with WebGL and pass in the pixel data as a texture. This can marginally increase performance, and on some browers, it also increases the maximum possible canvas size. Hearing the word WebGL might make you a little nervous, and maybe rightfully so, but we don&#x2019;t actually have to interface with it at all right now. Just replacing that line in the options with <code>renderer: "hybrid"</code> is enough to change everything necessary on the backend.</p><p class="body-text">As another improvement, let&#x2019;s add a button to download the current state of the canvas &mdash; we need a better way to get the applet&#x2019;s output than taking a screenshot.</p><p class="body-text">end-text-block</p><pre><code class="language-js" data-aos="fade-up">let options =<p class="body-text">{</p><p class="body-text">&#9;renderer: "hybrid",</p><p class="body-text">&#9;</p><p class="body-text">&#9;canvas_width: 500,</p><p class="body-text">&#9;canvas_height: 500,</p><p class="body-text">&#9;</p><p class="body-text">&#9;world_width: 4,</p><p class="body-text">&#9;world_height: 4,</p><p class="body-text">&#9;world_center_x: 0,</p><p class="body-text">&#9;world_center_y: 0</p><p class="body-text">};</code></pre></p><br><pre><code class="language-js" data-aos="fade-up">let download_button_element = document.querySelector("#download-button");<p class="body-text">download_button_element.addEventListener("click", () =></p><p class="body-text">{</p><p class="body-text">&#9;wilson.download_frame("a-julia-set.png");</p><p class="body-text">});</code></pre></p><br><p class="body-text">begin-text-boxes</p><p class="body-text">a-2 0 \(a\)</p><p class="body-text">b-2 1 \(b\)</p><p class="body-text">resolution-2 500 Resolution</p><p class="body-text">end-text-boxes</p><p class="body-text">begin-text-buttons</p><p class="body-text">generate-2 Generate</p><p class="body-text">end-text-buttons</p><div class="center-content" data-aos="fade-up"><div style="width: 70vmin"><canvas id="output-canvas-2" class="output-canvas"></canvas></div></div><p class="body-text">begin-text-buttons</p><p class="body-text">download-2 Download</p><p class="body-text">end-text-buttons</p><p class="body-text">section</p><p class="body-text">begin-text-block</p><p class="body-text">We&#x2019;re getting somewhere! In the next section, we&#x2019;ll add the first bit of interactivity in the form of a draggable selector for \(c\).</p><p class="body-text">You can view the code for this page <a href="/projects/wilson/guide/1-getting-started/scripts/getting-started.js">here</a>. </p><p class="body-text">end-text-block</p><p class="body-text">nav-buttons</p><p class="body-text">footer</p></section></main><script>"undefined"==typeof Page&&(""!==window.location.search?window.location.replace("/index.html?page="+encodeURIComponent(window.location.pathname)+"&"+window.location.search.slice(1)):window.location.replace("/index.html?page="+encodeURIComponent(window.location.pathname))),Page.settings = {"title": "Part 1: Getting Started","math_page": true,"small_margins_on_ultrawide": true,"parent_list": "/projects/wilson/guide"},Page.load()</script></body></html>