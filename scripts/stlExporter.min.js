import{Vector3}from"./three.min.js";class STLExporter{parse(scene,options={}){const t=void 0!==options.binary&&options.binary,r=[];let n=0;scene.traverse(function(object){if(object.isMesh){var t=object.geometry;if(!0!==t.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");var e=t.index,o=t.getAttribute("position");n+=null!==e?e.count/3:o.count/3,r.push({object3d:object,geometry:t})}});let e,o=80;var i;!0===t?(i=2*n+3*n*4*4+80+4,i=new ArrayBuffer(i),(e=new DataView(i)).setUint32(o,n,!0),o+=4):(e="",e+="solid exported\n");const s=new Vector3,f=new Vector3,l=new Vector3,u=new Vector3,p=new Vector3,x=new Vector3;for(let w=0,V=r.length;w<V;w++){var m=r[w].object3d,y=r[w].geometry,d=y.index,j=y.getAttribute("position");if(null!==d)for(let t=0;t<d.count;t+=3)v(d.getX(t+0),d.getX(t+1),d.getX(t+2),j,m);else for(let e=0;e<j.count;e+=3){const a=e+0,b=e+1,c=e+2;v(a,b,c,j,m)}}return!1===t&&(e+="endsolid exported\n"),e;function v(a,b,c,positionAttribute,object){s.fromBufferAttribute(positionAttribute,a),f.fromBufferAttribute(positionAttribute,b),l.fromBufferAttribute(positionAttribute,c),!0===object.isSkinnedMesh&&(object.boneTransform(a,s),object.boneTransform(b,f),object.boneTransform(c,l)),s.applyMatrix4(object.matrixWorld),f.applyMatrix4(object.matrixWorld),l.applyMatrix4(object.matrixWorld),positionAttribute=s,a=f,b=l,u.subVectors(b,a),p.subVectors(positionAttribute,a),u.cross(p).normalize(),x.copy(u).normalize(),!0===t?(e.setFloat32(o,x.x,!0),o+=4,e.setFloat32(o,x.y,!0),o+=4,e.setFloat32(o,x.z,!0),o+=4):e=e+("\tfacet normal "+x.x+" "+x.y+" "+x.z)+"\n\t\touter loop\n",A(s),A(f),A(l),!0===t?(e.setUint16(o,0,!0),o+=2):e+="\t\tendloop\n\tendfacet\n"}function A(vertex){!0===t?(e.setFloat32(o,vertex.x,!0),o+=4,e.setFloat32(o,vertex.y,!0),o+=4,e.setFloat32(o,vertex.z,!0),o+=4):e+="\t\t\tvertex "+vertex.x+" "+vertex.y+" "+vertex.z+"\n"}}}export{STLExporter};