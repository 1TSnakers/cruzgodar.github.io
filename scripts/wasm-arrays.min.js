"use strict";const ccallArrays=(r,e,a,t,{heapIn:A="HEAPF32",heapOut:s="HEAPF32",returnArraySize:l=1}={})=>{const n={};let u,E;n.HEAP8=Int8Array,n.HEAPU8=Uint8Array,n.HEAP16=Int16Array,n.HEAPU16=Uint16Array,n.HEAP32=Int32Array,n.HEAPU32=Uint32Array,n.HEAPF32=Float32Array,n.HEAPF64=Float64Array,a=a||[];const c="array"==e?"number":e,P=[],h=[],y=[];try{if(t)for(let r=0;r<t.length;r++)if("array"==a[r]||Array.isArray(t[r])){const e=new n[A](t[r]),a=Module._malloc(e.length*e.BYTES_PER_ELEMENT);switch(A){case"HEAP8":case"HEAPU8":Module[A].set(e,a);break;case"HEAP16":case"HEAPU16":Module[A].set(e,a>>1);break;case"HEAP32":case"HEAPU32":case"HEAPF32":Module[A].set(e,a>>2);break;case"HEAPF64":Module[A].set(e,a>>3)}y.push(a),P.push(a),P.push(t[r].length),h.push("number"),h.push("number")}else P.push(t[r]),h.push(null==a[r]?"number":a[r]);u=Module.ccall(r,c,h,P)}catch(r){E=r}finally{for(let r=0;r<y.length;r++)Module._free(y[r])}if(E)throw E;if("array"==e){const r=[];for(let e=0;e<l;e++)r.push(Module[s][u/n[s].BYTES_PER_ELEMENT+e]);return r}return u},cwrapArrays=(r,e,a,{heapIn:t="HEAPF32",heapOut:A="HEAPF32",returnArraySize:s=1}={})=>l=>ccallArrays(r,e,a,l,{heapIn:t,heapOut:A,returnArraySize:s});