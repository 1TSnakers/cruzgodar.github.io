import anime from"../anime.min.js";import{doubleEncodingGlsl,loadGlsl}from"../src/complexGlsl.min.js";import{animate,sleep}from"../src/utils.min.js";import{WilsonCPU,WilsonGPU}from"../wilson.min.js";import{AnimationFrameApplet}from"./animationFrameApplet.min.js";import{getFloatGlsl,getVectorGlsl,tempShader}from"./applet.min.js";class RaymarchApplet extends AnimationFrameApplet{movingSpeed=.1;moveVelocity=[0,0,0];moveFriction=.96;moveStopThreshhold=.01;lastTimestamp=-1;theta=0;phi=0;worldSize=2.5;resolution=500;maxMarches;maxShadowMarches;maxReflectionMarches;clipDistance;imagePlaneCenterPos=[0,0,0];forwardVec=[0,0,0];rightVec=[0,0,0];upVec=[0,0,0];focalLengthFactor;cameraPos;lightPos;lightBrightness;useOppositeLight;oppositeLightBrightness;ambientLight;bloomPower;fogColor;fogScaling;stepFactor;epsilonScaling;minEpsilon;useShadows;useSoftShadows;useReflections;useBloom;useAntialiasing;useFor3DPrinting;uniforms={};lockZ;speedFactor=2;fovFactor=1;lockedOnOrigin;distanceFromOrigin=1;distanceEstimatorGlsl;getColorGlsl;uniformsGlsl;getReflectivityGlsl;getGeodesicGlsl;addGlsl;constructor({canvas,shader,resolution=500,distanceEstimatorGlsl,getColorGlsl,uniformsGlsl="",getReflectivityGlsl="return 0.2;",getGeodesicGlsl=(pos,dir)=>pos+" + t * "+dir,addGlsl="",uniforms={},theta=0,phi=Math.PI/2,stepFactor=.99,epsilonScaling=1.25,minEpsilon=3e-7,maxMarches=128,maxShadowMarches=128,maxReflectionMarches=128,clipDistance=1e3,focalLengthFactor=2.5,cameraPos=[0,0,0],lockedOnOrigin=!0,lockZ,lightPos=[50,70,100],lightBrightness=1,useOppositeLight=!0,oppositeLightBrightness=.5,ambientLight=.25,bloomPower=1,fogColor=[0,0,0],fogScaling=.05,useShadows=!1,useSoftShadows=!0,useReflections=!1,useBloom=!0,useAntialiasing=!1,useFor3DPrinting=!1}){super(canvas),this.resolution=resolution,this.theta=theta,this.phi=phi,this.stepFactor=stepFactor,this.epsilonScaling=epsilonScaling,this.minEpsilon=minEpsilon,this.maxMarches=maxMarches,this.maxShadowMarches=maxShadowMarches,this.maxReflectionMarches=maxReflectionMarches,this.clipDistance=clipDistance,this.focalLengthFactor=focalLengthFactor,this.cameraPos=cameraPos,this.lockedOnOrigin=lockedOnOrigin,this.worldSize=this.lockedOnOrigin?2.5:1.5,this.lockZ=lockZ,this.lightPos=lightPos,this.lightBrightness=lightBrightness,this.useOppositeLight=useOppositeLight,this.oppositeLightBrightness=oppositeLightBrightness,this.ambientLight=ambientLight,this.bloomPower=bloomPower,this.fogColor=fogColor,this.fogScaling=fogScaling,this.useShadows=useShadows,this.useSoftShadows=useSoftShadows,this.useReflections=useReflections,this.useBloom=useBloom,this.useAntialiasing=useAntialiasing,this.useFor3DPrinting=useFor3DPrinting,this.uniformsGlsl=`
			uniform vec2 aspectRatio;
			uniform float resolution;
			uniform vec3 cameraPos;
			uniform vec3 imagePlaneCenterPos;
			uniform vec3 rightVec;
			uniform vec3 upVec;
			uniform float epsilonScaling;
			uniform float minEpsilon;
			uniform vec2 uvCenter;
			uniform float uvScale;
			${uniformsGlsl}
		`,this.uniforms={...this.useFor3DPrinting?{}:{aspectRatio:[1,1],resolution:this.resolution,cameraPos:this.cameraPos,imagePlaneCenterPos:this.imagePlaneCenterPos,rightVec:this.rightVec,upVec:this.upVec,minEpsilon:this.minEpsilon},epsilonScaling:this.epsilonScaling,uvCenter:[0,0],uvScale:1,...uniforms},this.listenForKeysPressed(["w","s","a","d","q","e"," ","shift","z","c"],(key,pressed)=>{if("z"===key){const e=pressed?1:4,i=pressed?4:1;animate(t=>{this.fovFactor=(1-t)*e+t*i,this.setUniforms({epsilonScaling:this.epsilonScaling*((1-t)*e+t*i)}),this.needNewFrame=!0},250,"easeOutCubic")}}),this.distanceFromOrigin=magnitude(this.cameraPos);var t=shader??this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl}),e={shader:tempShader,canvasWidth:this.resolution,worldWidth:this.worldSize,worldHeight:this.worldSize,worldCenterX:this.lockedOnOrigin?this.theta:2*Math.PI-this.theta,worldCenterY:this.lockedOnOrigin?this.phi:Math.PI-this.phi,minWorldY:.001-this.worldSize/2,maxWorldY:Math.PI-.001+this.worldSize/2,onResizeCanvas:this.onResizeCanvas.bind(this),interactionOptions:{useForPanAndZoom:!0,disallowZooming:!0,onPanAndZoom:()=>{this.calculateVectors(),this.needNewFrame=!0},callbacks:{touchstart:this.onTouchStart.bind(this),touchend:this.onTouchEnd.bind(this)}},fullscreenOptions:{onSwitch:this.switchFullscreen.bind(this),beforeSwitch:this.beforeSwitchFullscreen.bind(this),fillScreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}};this.wilson=new WilsonGPU(canvas,e),this.wilson.loadShader({id:"draw",shader:t,uniforms:this.uniforms}),this.useFor3DPrinting&&this.make3DPrintable(),this.needNewFrame=!0,this.resume()}switchFullscreen(){this.resume()}async beforeSwitchFullscreen(){this.pause(),await sleep(33)}async make3DPrintable(){var t=1500;this.setUniforms({uvScale:3,uvCenter:[0,0],epsilonScaling:.0015}),this.wilson.resizeCanvas({width:t}),this.drawFrame(),await sleep(1e3);for(let e=1;e<=t;e++)this.setUniforms({uvCenter:[2*e/t-1,0]}),this.drawFrame(),await sleep(0)}createShader({distanceEstimatorGlsl=this.distanceEstimatorGlsl,getColorGlsl=this.getColorGlsl,getReflectivityGlsl=this.getReflectivityGlsl,getGeodesicGlsl=this.getGeodesicGlsl,addGlsl=this.addGlsl,useForDepthBuffer=!1}){this.distanceEstimatorGlsl=distanceEstimatorGlsl,this.getColorGlsl=getColorGlsl,this.getReflectivityGlsl=getReflectivityGlsl,this.getGeodesicGlsl=getGeodesicGlsl,this.addGlsl=addGlsl;var t=this.useShadows&&this.useSoftShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float softShadowFactor = 1.0;
				float t = 0.0;

				float lastDistanceToScene = 100000.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					// Use Sebastian Aaltonen's improvement to Inigo Quilez's soft shadow algorithm.
					float distanceToScene = distanceEstimator(pos);
					float y = distanceToScene * distanceToScene / (2.0 * lastDistanceToScene);
        			float d = sqrt(distanceToScene * distanceToScene - y * y);

					softShadowFactor = min(
						softShadowFactor,
						d / (max(t - y, 0.0) * 0.025) 
					);

					lastDistanceToScene = distanceToScene;

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (t > clipDistance || length(pos - lightPos) < 0.2)
					{
						return clamp(softShadowFactor, maxShadowAmount, 1.0);
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return clamp(softShadowFactor, maxShadowAmount, 1.0);
			}
		`:this.useShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float t = 0.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (t > clipDistance)
					{
						return 1.0;
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return 1.0;
			}
		`:"",e=this.useReflections?`
			vec3 computeShadingWithoutReflection(
				vec3 pos,
				float epsilon,
				float distanceToScene,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, distanceToScene * 0.5);
				pos += (epsilon - distanceToScene) * surfaceNormal;
				surfaceNormal = getSurfaceNormal(pos, epsilon * 0.5);
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}

			// Unlike in raymarch(), startPos is replacing cameraPos, and rayDirectionVec is precomputed.
			vec3 computeReflection(
				vec3 startPos,
				vec3 rayDirectionVec,
				int startIteration
			) {
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxReflectionMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (distanceToScene < epsilon)
					{
						return computeShadingWithoutReflection(
							pos,
							epsilon,
							distanceToScene,
							iteration + startIteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
		`:"",i=this.useBloom?`
			float computeBloom(vec3 rayDirectionVec)
			{
				return pow(
					(3.0 - distance(
						normalize(rayDirectionVec),
						normalize(lightPos - cameraPos)
					)) / 2.99,
					${getFloatGlsl(20/this.bloomPower)}
				);
			}
		`:"",s=useForDepthBuffer?`
				vec3 computeShading(
					vec3 pos,
					float epsilon,
					float distanceToScene,
					int iteration
				) {
					gl_FragColor = encodeFloat(length(pos - cameraPos));
					return vec3(0.0);
				}
			`:`
				vec3 computeShading(
					vec3 pos,
					float epsilon,
					float distanceToScene,
					int iteration
				) {
					// Using distanceToScene / 2 here means we never step inside the object
					// which helps to prevent banding.
					vec3 surfaceNormal = getSurfaceNormal(pos, distanceToScene * 0.5);
					pos += (epsilon - distanceToScene) * surfaceNormal;
					surfaceNormal = getSurfaceNormal(pos, epsilon * 0.5);
					
					vec3 lightDirection = normalize(lightPos - pos);
					
					float dotProduct = dot(surfaceNormal, lightDirection);
					
					float lightIntensity = max(
						${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
						${getFloatGlsl(this.ambientLight)}
					);



					vec3 color = getColor(pos)
						* lightIntensity
						* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

					

					${this.useShadows?`
						float shadowIntensity = computeShadowIntensity(pos, lightDirection);

						color *= shadowIntensity;
					`:""}

					${this.useReflections?`
						vec3 reflectedDirection = reflect(
							normalize(pos - cameraPos) * ${getFloatGlsl(this.stepFactor)},
							surfaceNormal
						);

						color = mix(
							color,
							computeReflection(pos, reflectedDirection, iteration),
							getReflectivity(pos)
						);
					`:""}
					
					//Apply fog.
					return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
				}
			`,o=useForDepthBuffer?`
					vec3 raymarch(vec3 startPos)
					{
						vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
						
						float t = 0.0;
						
						for (int iteration = 0; iteration < maxMarches; iteration++)
						{
							vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
							
							float distanceToScene = distanceEstimator(pos);

							float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
							
							if (distanceToScene < epsilon)
							{
								return computeShading(
									pos,
									epsilon,
									distanceToScene,
									iteration
								);
							}
							
							else if (t > clipDistance)
							{
								gl_FragColor = encodeFloat(clipDistance);
								return vec3(0.0);
							}
							
							t += distanceToScene;
						}
						
						gl_FragColor = encodeFloat(clipDistance);
						return vec3(0.0);
					}
				`:this.useBloom?`
					vec3 raymarch(vec3 startPos)
					{
						vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
						
						float t = 0.0;
						
						for (int iteration = 0; iteration < maxMarches; iteration++)
						{
							vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
							
							float distanceToScene = distanceEstimator(pos);

							float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
							
							if (distanceToScene < epsilon)
							{
								return computeShading(
									pos,
									epsilon,
									distanceToScene,
									iteration
								);
							}
							
							else if (t > clipDistance)
							{
								return mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec));
							}
							
							t += distanceToScene;
						}
						
						return mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec));
					}
				`:`
				vec3 raymarch(vec3 startPos)
				{
					vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
					
					float t = 0.0;
					
					for (int iteration = 0; iteration < maxMarches; iteration++)
					{
						vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
						
						float distanceToScene = distanceEstimator(pos);

						float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
						
						if (distanceToScene < epsilon)
						{
							return computeShading(
								pos,
								epsilon,
								distanceToScene,
								iteration
							);
						}
						
						else if (t > clipDistance)
						{
							return fogColor;
						}
						
						t += distanceToScene;
					}
					
					return fogColor;
				}
			`,a=useForDepthBuffer?`
					void main(void)
					{
						raymarch(
							imagePlaneCenterPos
								+ rightVec * (uvScale * uv.x + uvCenter.x) * aspectRatio.x
								+ upVec * (uvScale * uv.y + uvCenter.y) * aspectRatio.y
						);
					}
				`:this.useFor3DPrinting?`
					void main(void)
					{
						gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);

						if (distanceEstimator(vec3(uv.x, uv.y, uvCenter.x) * uvScale) < epsilonScaling)
						{
							gl_FragColor = vec4(1.0);
						}
					}
				`:`
				void main(void)
				{
					vec3 finalColor = raymarch(
						imagePlaneCenterPos
							+ rightVec * (uvScale * uv.x + uvCenter.x) * aspectRatio.x
							+ upVec * (uvScale * uv.y + uvCenter.y) * aspectRatio.y
					);

					gl_FragColor = vec4(finalColor.xyz, 1.0);
				}
			`;return`
			precision highp float;
			
			varying vec2 uv;

			${this.uniformsGlsl}
			
			const vec3 lightPos = ${getVectorGlsl(this.lightPos)};
			const float lightBrightness = ${getFloatGlsl(this.lightBrightness)};
			const float bloomPower = ${getFloatGlsl(this.bloomPower)};
			
			const float clipDistance = ${getFloatGlsl(this.clipDistance)};
			const int maxMarches = ${this.maxMarches};
			const int maxShadowMarches = ${this.maxShadowMarches};
			const int maxReflectionMarches = ${this.maxReflectionMarches};
			const vec3 fogColor = ${getVectorGlsl(this.fogColor)};
			const float fogScaling = ${getFloatGlsl(this.fogScaling)};
			const float maxShadowAmount = 0.5;

			${useForDepthBuffer?doubleEncodingGlsl:""}

			${addGlsl}
			
			
			
			float distanceEstimator(vec3 pos)
			{
				${distanceEstimatorGlsl}
			}
			
			vec3 getColor(vec3 pos)
			{
				${getColorGlsl}
			}

			${this.useReflections?`float getReflectivity(vec3 pos)
			{
				${getReflectivityGlsl}
			}`:""}
			
			
			
			vec3 getSurfaceNormal(vec3 pos, float epsilon)
			{
				float xStep1 = distanceEstimator(pos + vec3(epsilon, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, epsilon, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, epsilon));
				
				float xStep2 = distanceEstimator(pos - vec3(epsilon, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, epsilon, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, epsilon));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}

			${i}

			${t}

			${e}
			
			${s}

			${o}
			
			${a}
		`}reloadShader({distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl,useForDepthBuffer}={}){this.wilson.loadShader({id:"draw",shader:this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl,useForDepthBuffer:useForDepthBuffer}),uniforms:this.uniforms,antialiasing:this.useAntialiasing}),this.calculateVectors(),this.needNewFrame=!0}setUniforms(uniforms){this.uniforms={...this.uniforms,...uniforms},this.wilson.setUniforms(uniforms,"draw"),this.needNewFrame=!0}calculateVectors(){this.useFor3DPrinting||(this.forwardVec=[Math.cos(this.theta)*Math.sin(this.phi),Math.sin(this.theta)*Math.sin(this.phi),Math.cos(this.phi)],this.rightVec=normalize([this.forwardVec[1],-this.forwardVec[0],0]),this.upVec=crossProduct(this.rightVec,this.forwardVec),this.lockedOnOrigin&&(this.cameraPos=scaleVector(-this.distanceFromOrigin,this.forwardVec)),this.speedFactor=Math.min(this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),.5)/4,this.forwardVec[0]*=this.speedFactor/1.5,this.forwardVec[1]*=this.speedFactor/1.5,this.forwardVec[2]*=this.speedFactor/1.5,this.rightVec[0]*=this.speedFactor/this.fovFactor,this.rightVec[1]*=this.speedFactor/this.fovFactor,this.upVec[0]*=this.speedFactor/this.fovFactor,this.upVec[1]*=this.speedFactor/this.fovFactor,this.upVec[2]*=this.speedFactor/this.fovFactor,this.imagePlaneCenterPos=[this.cameraPos[0]+this.forwardVec[0]*this.focalLengthFactor,this.cameraPos[1]+this.forwardVec[1]*this.focalLengthFactor,this.cameraPos[2]+this.forwardVec[2]*this.focalLengthFactor],this.setUniforms({cameraPos:this.cameraPos,imagePlaneCenterPos:this.imagePlaneCenterPos,rightVec:this.rightVec,upVec:this.upVec}),this.needNewFrame=!1)}distanceEstimator(){throw new Error("Distance estimator not implemented!")}prepareFrame(timeElapsed){this.touchDelay=Math.max(0,this.touchDelay-timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.theta=this.lockedOnOrigin?this.wilson.worldCenterX:2*Math.PI-this.wilson.worldCenterX,this.phi=this.lockedOnOrigin?this.wilson.worldCenterY:Math.PI-this.wilson.worldCenterY,this.calculateVectors(),this.wilson.drawFrame()}async downloadFrame(filename){this.drawFrame(),this.wilson.downloadFrame(filename,!1)}async makeMosaic({size=16,returnPixels=!1,useForDepthBuffer=!1}){return new Promise(outerResolve=>{this.setUniforms({uvScale:1/size,resolution:this.resolution*size});const i=[];for(let t=0;t<size;t++)i.push((1+2*t)/size-1);const a=[],r=new Array(size);for(let e=0;e<size;e++){a.push([]),r[e]=new Array(size);for(let t=0;t<size;t++)a[e].push(document.createElement("canvas")),a[e][t].width=this.resolution,a[e][t].height=this.resolution}const s=async()=>{if(useForDepthBuffer){var s=new Float32Array(this.resolution*this.resolution*size*size);for(let i=0;i<size;i++)for(let e=0;e<this.resolution;e++)for(let t=0;t<size;t++)s.set(r[t][i].subarray(e*this.resolution,(e+1)*this.resolution),i*this.resolution*this.resolution*size+e*this.resolution*size+t*this.resolution);outerResolve(s)}else{var t=document.createElement("canvas"),i=(t.width=this.resolution*size,t.height=this.resolution*size,t.getContext("2d",{colorSpace:"display-p3"}));for(let e=0;e<size;e++)for(let t=0;t<size;t++)i.drawImage(a[e][t],e*this.resolution,t*this.resolution);returnPixels||(i.translate(0,this.resolution*size),i.scale(1,-1)),i.drawImage(t,0,0);var o=returnPixels?i.getImageData(0,0,this.resolution*size,this.resolution*size).data:void 0;returnPixels||t.toBlob(blob=>{var t=document.createElement("a");t.href=URL.createObjectURL(blob),t.download="mosaic.png",t.click()}),await sleep(100),this.setUniforms({uvScale:1,uvCenter:[0,0],resolution:this.resolution}),this.needNewFrame=!0,outerResolve(o)}};let o=0,n=0;const l=async()=>{var t=a[o][n].getContext("2d",{colorSpace:"display-p3"}),e=(this.setUniforms({uvCenter:[i[o],i[n]]}),this.drawFrame(),useForDepthBuffer&&(r[o][n]=new Float32Array(this.wilson.readPixels().buffer)),new ImageData(new Uint8ClampedArray(this.wilson.readPixels()),this.resolution,this.resolution));t.putImageData(e,0,0),await sleep(500),++n===size&&(n=0,o++),o!==size?requestAnimationFrame(l):s()};requestAnimationFrame(l)})}async downloadBokehFrame(){var t=this.useAntialiasing;this.useAntialiasing=!0,await loadGlsl(),this.reloadShader({useForDepthBuffer:!1});const e=await this.makeMosaic({size:4,returnPixels:!0});this.reloadShader({useForDepthBuffer:!0});var s=await this.makeMosaic({size:4,useForDepthBuffer:!0});const o=4*this.resolution;var a=o/250*1,r=this.createOffscreenCanvas(),n={canvasWidth:o},n=new WilsonCPU(r,n),l=(n.ctx.fillStyle="rgb(0, 0, 0)",n.ctx.fillRect(0,0,o,o),Array.from(s).map((depth,i)=>{return[depth,i%o,o-Math.floor(i/o)-1,e[4*i],e[4*i+1],e[4*i+2]]}).sort((a,b)=>b[0]-a[0])),c=l[l.length-1][0];let h=0;for(let F=0;F<l.length;F++)if(l[F][0]<this.clipDistance){h=F;break}var m=l[h=Math.floor(h+.1*(l.length-h))][0],d=new Array(o*o*4).fill(0);for(const V of l){var u=V[0];if(u!==this.clipDistance){var p,f=V[1],g=V[2],v=Math.min(Math.max((u-c)/(m-c),0),1)*(a-.5)+.5;let e=0;for(let i=Math.floor(-v);i<=Math.ceil(v);i++)for(let t=Math.floor(-v);t<=Math.ceil(v);t++)t*t+i*i<=v*v&&(p=Math.min(v-Math.sqrt(t*t+i*i),1),e+=p);var w,S,P=1/e;for(let s=Math.floor(-v);s<=Math.ceil(v);s++)for(let t=Math.floor(-v);t<=Math.ceil(v);t++)t*t+s*s<=v*v&&(w=g+s,S=f+t,w<0||w>=o||S<0||S>=o||(w=w*o+S,S=P*Math.min(v-Math.sqrt(t*t+s*s),1),d[4*w]+=V[3]*S,d[4*w+1]+=V[4]*S,d[4*w+2]+=V[5]*S))}}var y=new Uint8ClampedArray(d);for(let G=0;G<o*o;G++)y[4*G+3]=255;n.drawFrame(y),n.downloadFrame("bokeh-render.png"),this.useAntialiasing=t,this.reloadShader({useForDepthBuffer:!1}),this.drawFrame(),r.remove()}touchDelay=0;numTouches=0;onTouchStart({event}){this.numTouches<=1&&2===event.touches.length?(this.numTouches=2,this.touchDelay=100):this.numTouches<=2&&3===event.touches.length?this.numTouches=3:this.numTouches=0}onTouchEnd({event}){event.touches.length<2&&(this.numTouches=0)}moveUpdate(timeElapsed){0===this.touchDelay&&(2===this.numTouches?this.moveVelocity[0]=1:3===this.numTouches&&(this.moveVelocity[0]=-1)),this.keysPressed.w||2===this.numTouches?this.moveVelocity[0]=1:!this.keysPressed.s&&3!==this.numTouches||(this.moveVelocity[0]=-1),this.keysPressed.d?this.moveVelocity[1]=1:this.keysPressed.a&&(this.moveVelocity[1]=-1),this.keysPressed[" "]?this.moveVelocity[2]=1:this.keysPressed.shift&&(this.moveVelocity[2]=-1);var t,e,i=(this.keysPressed.c?.05:1)*this.movingSpeed;this.lockedOnOrigin||0===this.moveVelocity[0]&&0===this.moveVelocity[1]&&0===this.moveVelocity[2]||(e=void 0!==this.lockZ?scaleVector(magnitude(this.forwardVec),normalize([this.forwardVec[0],this.forwardVec[1],0])):this.forwardVec,t=void 0!==this.lockZ?scaleVector(magnitude(this.rightVec),normalize([this.rightVec[0],this.rightVec[1],0])):this.rightVec,e=[this.moveVelocity[0]*e[0]+this.moveVelocity[1]*t[0],this.moveVelocity[0]*e[1]+this.moveVelocity[1]*t[1],this.moveVelocity[0]*e[2]+this.moveVelocity[1]*t[2]+this.moveVelocity[2]*this.speedFactor/1.5],this.cameraPos[0]+=i*e[0]*(timeElapsed/6.944),this.cameraPos[1]+=i*e[1]*(timeElapsed/6.944),this.cameraPos[2]=this.lockZ??this.cameraPos[2]+i*e[2]*(timeElapsed/6.944),this.needNewFrame=!0);for(let s=0;s<3;s++)this.moveVelocity[s]*=this.moveFriction**(timeElapsed/6.944),Math.abs(this.moveVelocity[s])<this.moveStopThreshhold&&(this.moveVelocity[s]=0)}onResizeCanvas(){this.useFor3DPrinting||(this.resolution=Math.sqrt(this.wilson.canvasWidth*this.wilson.canvasHeight),this.wilson.resizeWorld({minY:.001-this.wilson.worldHeight/2,maxY:Math.PI-.001+this.wilson.worldHeight/2}),this.setUniforms({aspectRatio:[this.wilson.worldWidth/this.worldSize,this.wilson.worldHeight/this.worldSize],resolution:this.resolution}),this.needNewFrame=!0)}animateUniform({name,value,duration=1e3}){const e=this.uniforms[name];animate(t=>{this.setUniforms({[name]:t*value+(1-t)*e}),this.needNewFrame=!0},duration,"easeInOutQuart")}loopUniform({name,startValue,endValue,duration=2e3}){const t={t:0};return anime({targets:t,t:1,duration:duration,easing:"easeInOutQuad",loop:!0,direction:"alternate",update:()=>{this.setUniforms({[name]:startValue+(endValue-startValue)*t.t}),this.needNewFrame=!0}})}async setLockedOnOrigin(value){if(value&&!this.lockedOnOrigin){var e=magnitude(this.cameraPos);const s=normalize(this.cameraPos);var i=Math.acos(this.cameraPos[2]/e);let t=Math.PI-Math.atan2(this.cameraPos[1],this.cameraPos[0]);t>Math.PI&&(t-=2*Math.PI),t<-Math.PI&&(t+=2*Math.PI);const o={r:e,theta:2*Math.PI-this.theta,phi:Math.PI-this.phi};o.theta>Math.PI&&(o.theta-=2*Math.PI),o.theta<-Math.PI&&(o.theta+=2*Math.PI),await anime({targets:o,theta:t,phi:i,r:this.distanceFromOrigin,duration:500,easing:"easeOutCubic",update:()=>{this.wilson.resizeWorld({centerX:o.theta,centerY:o.phi}),this.cameraPos=scaleVector(o.r,s),this.needNewFrame=!0}}).finished}this.lockedOnOrigin=value,this.worldSize=this.lockedOnOrigin?2.5:1.5,this.wilson.resizeWorld({width:this.worldSize,height:this.worldSize,centerX:this.lockedOnOrigin?this.theta:2*Math.PI-this.theta,centerY:this.lockedOnOrigin?this.phi:Math.PI-this.phi,minY:.001-this.worldSize/2,maxY:Math.PI-.001+this.worldSize/2})}}function magnitude(vec){return Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])}function addVectors(vec1,vec2){return[vec1[0]+vec2[0],vec1[1]+vec2[1],vec1[2]+vec2[2]]}function scaleVector(c,vec){return[c*vec[0],c*vec[1],c*vec[2]]}function dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]}function dotProduct4(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}function crossProduct(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}function matMul(mat1,mat2){return[[mat1[0][0]*mat2[0][0]+mat1[0][1]*mat2[1][0]+mat1[0][2]*mat2[2][0],mat1[0][0]*mat2[0][1]+mat1[0][1]*mat2[1][1]+mat1[0][2]*mat2[2][1],mat1[0][0]*mat2[0][2]+mat1[0][1]*mat2[1][2]+mat1[0][2]*mat2[2][2]],[mat1[1][0]*mat2[0][0]+mat1[1][1]*mat2[1][0]+mat1[1][2]*mat2[2][0],mat1[1][0]*mat2[0][1]+mat1[1][1]*mat2[1][1]+mat1[1][2]*mat2[2][1],mat1[1][0]*mat2[0][2]+mat1[1][1]*mat2[1][2]+mat1[1][2]*mat2[2][2]],[mat1[2][0]*mat2[0][0]+mat1[2][1]*mat2[1][0]+mat1[2][2]*mat2[2][0],mat1[2][0]*mat2[0][1]+mat1[2][1]*mat2[1][1]+mat1[2][2]*mat2[2][1],mat1[2][0]*mat2[0][2]+mat1[2][1]*mat2[1][2]+mat1[2][2]*mat2[2][2]]]}function qmul(x1,y1,z1,w1,x2,y2,z2,w2){return[x1*x2-y1*y2-z1*z1-w1*w2,x1*y2+y1*x2+z1*w2-w1*z2,x1*z2-y1*w2+z1*x2+w1*y2,x1*w2+y1*z2-z1*y2+w1*x2]}function normalize(vec){var t=magnitude(vec);return[vec[0]/t,vec[1]/t,vec[2]/t]}function getRotationMatrix(thetaX,thetaY,thetaZ){var t=Math.cos(thetaX),e=Math.sin(thetaX),i=Math.cos(thetaY),s=Math.sin(thetaY),o=Math.cos(thetaZ),a=Math.sin(thetaZ),e=[[1,0,0],[0,t,-e],[0,e,t]];return matMul(matMul([[o,-a,0],[a,o,0],[0,0,1]],[[i,0,-s],[0,1,0],[s,0,i]]),e)}function mat3TimesVector(mat,vec){return[mat[0][0]*vec[0]+mat[0][1]*vec[1]+mat[0][2]*vec[2],mat[1][0]*vec[0]+mat[1][1]*vec[1]+mat[1][2]*vec[2],mat[2][0]*vec[0]+mat[2][1]*vec[1]+mat[2][2]*vec[2]]}export{RaymarchApplet,magnitude,addVectors,scaleVector,dotProduct,dotProduct4,crossProduct,matMul,qmul,normalize,getRotationMatrix,mat3TimesVector};