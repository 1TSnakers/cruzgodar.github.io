import anime from"../anime.min.js";import{addTemporaryListener}from"../src/main.min.js";import{Wilson}from"../wilson.min.js";import{AnimationFrameApplet}from"./animationFrameApplet.min.js";import{Applet,getFloatGlsl,getVectorGlsl}from"./applet.min.js";const setUniformFunctions={int:"uniform1i",float:"uniform1f",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv"},minEpsilon=3e-7;class RaymarchApplet extends AnimationFrameApplet{movingSpeed=.1;moveVelocity=[0,0,0];moveFriction=.96;moveStopThreshhold=.01;distanceToScene=1;lastTimestamp=-1;theta=0;phi=0;imageSize=400;imageWidth=400;imageHeight=400;maxMarches=256;maxShadowMarches=128;maxReflectionMarches=256;clipDistance=1e3;imagePlaneCenterPos=[];forwardVec=[];rightVec=[];upVec=[];cameraPos=[0,0,0];lightPos=[50,70,100];lightBrightness=1;bloomPower=.11;fogColor=[0,0,0];fogScaling=.05;useShadows=!1;useReflections=!1;useBloom=!0;uniforms={};lockZ;focalLength=2;fovFactor=1;lockedOnOrigin=!1;distanceFromOrigin=1;constructor({canvas,distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl="",uniforms,theta,phi,cameraPos}){super(canvas),this.uniforms=uniforms,this.theta=theta,this.phi=phi,this.cameraPos=cameraPos,this.lockedOnOrigin||this.listenForKeysPressed(["w","s","a","d","q","e"," ","shift","z"],(key,pressed)=>{if("z"===key){const t={t:0},e=this.fovFactor,i=pressed?5:1;anime({targets:t,t:1,duration:250,easing:"easeOutCubic",update:()=>{this.fovFactor=(1-t.t)*e+t.t*i,this.needNewFrame=!0}})}});const t=setInterval(()=>{this?.wilson?.draggables?.container&&(this.listenForNumTouches(),clearInterval(t))},100);var e={renderer:"gpu",shader:this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl}),canvasWidth:this.imageWidth,canvasHeight:this.imageHeight,worldCenterX:-this.theta,worldCenterY:-this.phi,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:this.changeResolution.bind(this),mousedownCallback:this.onGrabCanvas.bind(this),touchstartCallback:this.onGrabCanvas.bind(this),mousedragCallback:this.onDragCanvas.bind(this),touchmoveCallback:this.onDragCanvas.bind(this),mouseupCallback:this.onReleaseCanvas.bind(this),touchendCallback:this.onReleaseCanvas.bind(this)};this.wilson=new Wilson(canvas,e),this.wilson.render.initUniforms(["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","epsilon",...Object.keys(this.uniforms)]),this.calculateVectors(),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,Math.max(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,Math.min(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1i(this.wilson.uniforms.imageSize,this.imageSize),this.wilson.gl.uniform3fv(this.wilson.uniforms.cameraPos,this.cameraPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.imagePlaneCenterPos,this.imagePlaneCenterPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.forwardVec,this.forwardVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.rightVec,this.rightVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.upVec,this.upVec),this.wilson.gl.uniform1f(this.wilson.uniforms.epsilon,1e-4);for(const o in this.uniforms){var i=this.uniforms[o];this.wilson.gl[setUniformFunctions[i[0]]](this.wilson.uniforms[o],i[1])}addTemporaryListener({object:window,event:"resize",callback:()=>this.changeResolution()}),this.resume()}createShader({distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl}){var t=this.useShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				//That factor of .9 is important -- without it, we're always stepping as far as possible, which results in artefacts and weirdness.
				vec3 rayDirectionVec = normalize(lightDirection) * .95;

				float softShadowFactor = 100.0;
				
				float t = 0.01;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = startPos + t * rayDirectionVec;
					
					float distanceToScene = distanceEstimator(pos);

					softShadowFactor = min(softShadowFactor, max(distanceToScene, 0.0) / t * 20.0);

					if (t > clipDistance || length(pos - lightPos) < 0.2)
					{
						return clamp(softShadowFactor, maxShadowAmount, 1.0);
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return clamp(softShadowFactor, maxShadowAmount, 1.0);
			}
		`:"",e=this.useReflections?`
			vec3 computeShadingWithoutReflection(
				vec3 pos,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					lightBrightness * dotProduct,
					.25
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}

			// Unlike in raymarch(), startPos is replacing cameraPos, and rayDirectionVec is precomputed.
			vec3 computeReflection(vec3 startPos, vec3 rayDirectionVec, int startIteration)
			{
				float t = .0001;
				
				for (int iteration = 0; iteration < maxReflectionMarches; iteration++)
				{
					vec3 pos = startPos + t * rayDirectionVec;
					
					float distanceToScene = distanceEstimator(pos);

					if (distanceToScene < epsilon)
					{
						return computeShadingWithoutReflection(
							pos,
							distanceToScene,
							iteration + startIteration
						);
					}
					
					else if (t > clipDistance)
					{
						return fogColor${this.useBloom?" * computeBloom(rayDirectionVec)":""};
					}
					
					t += distanceToScene;
				}
				
				return fogColor${this.useBloom?" * computeBloom(rayDirectionVec)":""};
			}
		`:"",i=this.useBloom?`
			float computeBloom(vec3 rayDirectionVec)
			{
				return max(
					1.0,
					pow(
						1.0 / distance(
							normalize(rayDirectionVec),
							normalize(lightPos - cameraPos)
						),
						bloomPower
					)
				);
			}
		`:"",i=`
			precision highp float;
			
			varying vec2 uv;
			
			uniform float aspectRatioX;
			uniform float aspectRatioY;
			
			uniform vec3 cameraPos;
			uniform vec3 imagePlaneCenterPos;
			uniform vec3 forwardVec;
			uniform vec3 rightVec;
			uniform vec3 upVec;
			uniform float epsilon;
			uniform int imageSize;

			${Object.entries(this.uniforms).map(([key,value])=>`uniform ${value[0]} ${key};`).join("\n")}
			
			const vec3 lightPos = ${getVectorGlsl(this.lightPos)};
			const float lightBrightness = ${getFloatGlsl(this.lightBrightness)};
			const float bloomPower = ${getFloatGlsl(this.bloomPower)};
			
			const float clipDistance = ${getFloatGlsl(this.clipDistance)};
			const int maxMarches = ${this.maxMarches};
			const int maxShadowMarches = ${this.maxShadowMarches};
			const int maxReflectionMarches = ${this.maxReflectionMarches};
			const vec3 fogColor = ${getVectorGlsl(this.fogColor)};
			const float fogScaling = ${getFloatGlsl(this.fogScaling)};

			${addGlsl}
			
			
			
			float distanceEstimator(vec3 pos)
			{
				${distanceEstimatorGlsl}
			}
			
			vec3 getColor(vec3 pos)
			{
				${getColorGlsl}
			}

			${this.useReflections?`float getReflectivity(vec3 pos)
			{
				${getReflectivityGlsl}
			}`:""}
			
			
			
			vec3 getSurfaceNormal(vec3 pos)
			{
				float xStep1 = distanceEstimator(pos + vec3(epsilon, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, epsilon, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, epsilon));
				
				float xStep2 = distanceEstimator(pos - vec3(epsilon, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, epsilon, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, epsilon));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}

			${i}

			${t}

			${e}
			
			vec3 computeShading(
				vec3 pos,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					lightBrightness * dotProduct,
					.25
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}

				${this.useReflections?`
					vec3 reflectedDirection = reflect(normalize(pos - cameraPos) * .95, surfaceNormal);

					color = mix(
						color,
						computeReflection(pos, reflectedDirection, iteration),
						getReflectivity(pos)
					);
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}


			
			vec3 raymarch(vec3 startPos)
			{
				vec3 rayDirectionVec = normalize(startPos - cameraPos) * .95;
				
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxMarches; iteration++)
				{
					vec3 pos = cameraPos + t * rayDirectionVec;
					
					float distanceToScene = distanceEstimator(pos);
					
					if (distanceToScene < epsilon)
					{
						return computeShading(
							pos,
							distanceToScene,
							iteration
						);
					}
					
					else if (t > clipDistance)
					{
						return fogColor${this.useBloom?" * computeBloom(rayDirectionVec)":""};
					}
					
					t += distanceToScene;
				}
				
				return fogColor${this.useBloom?" * computeBloom(rayDirectionVec)":""};
			}
			
			
			
			void main(void)
			{
				vec3 finalColor = raymarch(
					imagePlaneCenterPos + rightVec * uv.x * aspectRatioX + upVec * uv.y / aspectRatioY
				);
				
				gl_FragColor = vec4(finalColor.xyz, 1.0);
			}
		`;return window.DEBUG&&console.log(i),i}calculateVectors(){var t=this.lockedOnOrigin?-this.theta:this.theta,e=this.lockedOnOrigin?Math.PI-this.phi:this.phi;this.forwardVec=[Math.cos(t)*Math.sin(e),Math.sin(t)*Math.sin(e),Math.cos(e)],this.rightVec=RaymarchApplet.normalize([this.forwardVec[1],-this.forwardVec[0],0]),this.upVec=RaymarchApplet.crossProduct(this.rightVec,this.forwardVec),this.lockedOnOrigin&&(this.cameraPos=RaymarchApplet.scaleVector(-this.distanceFromOrigin,this.forwardVec)),this.distanceToScene=this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),this.focalLength=Math.min(this.distanceToScene,.5)/2,this.forwardVec[0]*=this.focalLength/2,this.forwardVec[1]*=this.focalLength/2,this.forwardVec[2]*=this.focalLength/2,this.rightVec[0]*=this.focalLength/(2*this.fovFactor),this.rightVec[1]*=this.focalLength/(2*this.fovFactor),this.upVec[0]*=this.focalLength/(2*this.fovFactor),this.upVec[1]*=this.focalLength/(2*this.fovFactor),this.upVec[2]*=this.focalLength/(2*this.fovFactor),this.imagePlaneCenterPos=[this.cameraPos[0]+this.forwardVec[0],this.cameraPos[1]+this.forwardVec[1],this.cameraPos[2]+this.forwardVec[2]],this.wilson.gl.uniform3fv(this.wilson.uniforms.cameraPos,this.cameraPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.imagePlaneCenterPos,this.imagePlaneCenterPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.forwardVec,this.forwardVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.rightVec,this.rightVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.upVec,this.upVec),this.wilson.gl.uniform1f(this.wilson.uniforms.epsilon,Math.max(2*this.distanceToScene/this.imageSize,minEpsilon))}distanceEstimator(){throw new Error("Distance estimator not implemented!")}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.wilson.worldCenterY=Math.min(Math.max(this.wilson.worldCenterY,.01-Math.PI),-.01),this.theta=-this.wilson.worldCenterX,this.phi=-this.wilson.worldCenterY,this.wilson.render.drawFrame()}moveUpdate(timeElapsed){var t,e;this.keysPressed.w||2===this.numTouches?this.moveVelocity[0]=1:!this.keysPressed.s&&3!==this.numTouches||(this.moveVelocity[0]=-1),this.keysPressed.d?this.moveVelocity[1]=1:this.keysPressed.a&&(this.moveVelocity[1]=-1),this.keysPressed[" "]?this.moveVelocity[2]=1:this.keysPressed.shift&&(this.moveVelocity[2]=-1),this.lockedOnOrigin||0===this.moveVelocity[0]&&0===this.moveVelocity[1]&&0===this.moveVelocity[2]||(e=void 0!==this.lockZ?RaymarchApplet.scaleVector(RaymarchApplet.magnitude(this.forwardVec),RaymarchApplet.normalize([this.forwardVec[0],this.forwardVec[1],0])):this.forwardVec,t=void 0!==this.lockZ?RaymarchApplet.scaleVector(RaymarchApplet.magnitude(this.rightVec),RaymarchApplet.normalize([this.rightVec[0],this.rightVec[1],0])):this.rightVec,e=[this.moveVelocity[0]*e[0]+this.moveVelocity[1]*t[0],this.moveVelocity[0]*e[1]+this.moveVelocity[1]*t[1],this.moveVelocity[0]*e[2]+this.moveVelocity[1]*t[2]+this.moveVelocity[2]*this.focalLength/2],this.cameraPos[0]+=this.movingSpeed*e[0]*(timeElapsed/6.944),this.cameraPos[1]+=this.movingSpeed*e[1]*(timeElapsed/6.944),this.cameraPos[2]=this.lockZ??this.cameraPos[2]+this.movingSpeed*e[2]*(timeElapsed/6.944),this.needNewFrame=!0),this.calculateVectors();for(let i=0;i<3;i++)this.moveVelocity[i]*=this.moveFriction**(timeElapsed/6.944),Math.abs(this.moveVelocity[i])<this.moveStopThreshhold&&(this.moveVelocity[i]=0)}changeResolution(resolution=this.imageSize){this.imageSize=Math.max(50,resolution),this.wilson.fullscreen.currentlyFullscreen?[this.imageWidth,this.imageHeight]=Applet.getEqualPixelFullScreen(this.imageSize):(this.imageWidth=this.imageSize,this.imageHeight=this.imageSize),this.wilson.changeCanvasSize(this.imageWidth,this.imageHeight),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,Math.max(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,Math.min(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1i(this.wilson.uniforms.imageSize,this.imageSize),this.needNewFrame=!0}setUniform(name,value){this.uniforms[name][1]=value,this.wilson.gl[setUniformFunctions[this.uniforms[name][0]]](this.wilson.uniforms[name],value)}static magnitude(vec){return Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])}static addVectors(vec1,vec2){return[vec1[0]+vec2[0],vec1[1]+vec2[1],vec1[2]+vec2[2]]}static scaleVector(c,vec){return[c*vec[0],c*vec[1],c*vec[2]]}static dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]}static dotProduct4(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}static crossProduct(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}static matMul(mat1,mat2){return[[mat1[0][0]*mat2[0][0]+mat1[0][1]*mat2[1][0]+mat1[0][2]*mat2[2][0],mat1[0][0]*mat2[0][1]+mat1[0][1]*mat2[1][1]+mat1[0][2]*mat2[2][1],mat1[0][0]*mat2[0][2]+mat1[0][1]*mat2[1][2]+mat1[0][2]*mat2[2][2]],[mat1[1][0]*mat2[0][0]+mat1[1][1]*mat2[1][0]+mat1[1][2]*mat2[2][0],mat1[1][0]*mat2[0][1]+mat1[1][1]*mat2[1][1]+mat1[1][2]*mat2[2][1],mat1[1][0]*mat2[0][2]+mat1[1][1]*mat2[1][2]+mat1[1][2]*mat2[2][2]],[mat1[2][0]*mat2[0][0]+mat1[2][1]*mat2[1][0]+mat1[2][2]*mat2[2][0],mat1[2][0]*mat2[0][1]+mat1[2][1]*mat2[1][1]+mat1[2][2]*mat2[2][1],mat1[2][0]*mat2[0][2]+mat1[2][1]*mat2[1][2]+mat1[2][2]*mat2[2][2]]]}static qmul(x1,y1,z1,w1,x2,y2,z2,w2){return[x1*x2-y1*y2-z1*z1-w1*w2,x1*y2+y1*x2+z1*w2-w1*z2,x1*z2-y1*w2+z1*x2+w1*y2,x1*w2+y1*z2-z1*y2+w1*x2]}static normalize(vec){var t=RaymarchApplet.magnitude(vec);return[vec[0]/t,vec[1]/t,vec[2]/t]}}export{RaymarchApplet};