import anime from"../anime.min.js";import{addTemporaryListener}from"../src/main.min.js";import{Wilson}from"../wilson.min.js";import{AnimationFrameApplet}from"./animationFrameApplet.min.js";import{Applet,getFloatGlsl,getVectorGlsl}from"./applet.min.js";const setUniformFunctions={int:["uniform1i",[]],float:["uniform1f",[]],vec2:["uniform2fv",[]],vec3:["uniform3fv",[]],vec4:["uniform4fv",[]],mat2:["uniformMatrix2fv",[!1]],mat3:["uniformMatrix3fv",[!1]],mat4:["uniformMatrix4fv",[!1]]};class RaymarchApplet extends AnimationFrameApplet{movingSpeed=.1;moveVelocity=[0,0,0];moveFriction=.96;moveStopThreshhold=.01;lastTimestamp=-1;theta=0;phi=0;imageSize=400;imageWidth=400;imageHeight=400;maxMarches=128;maxShadowMarches=128;maxReflectionMarches=128;clipDistance=1e3;imagePlaneCenterPos=[];forwardVec=[];rightVec=[];upVec=[];cameraPos;lightPos;lightBrightness;useOppositeLight;oppositeLightBrightness;ambientLight;bloomPower;fogColor=[0,0,0];fogScaling=.05;stepFactor;epsilonScaling;minEpsilon;useShadows=!1;useSoftShadows=!0;useReflections=!1;useBloom=!0;uniforms={};lockZ;speedFactor=2;fovFactor=1;lockedOnOrigin=!1;distanceFromOrigin=1;distanceEstimatorGlsl;getColorGlsl;getReflectivityGlsl;getGeodesicGlsl;addGlsl;constructor({canvas,distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl="return 0.2;",getGeodesicGlsl=(pos,dir)=>pos+" + t * "+dir,addGlsl="",uniforms={},theta,phi,stepFactor=.95,epsilonScaling=1.75,minEpsilon=3e-7,cameraPos=[0,0,0],lockedOnOrigin=!1,lightPos=[50,70,100],lightBrightness=1,useOppositeLight=!1,oppositeLightBrightness=.5,ambientLight=.25,useBloom=!0,bloomPower=1,useShadows=!1,useReflections=!1}){super(canvas),this.uniforms=uniforms,this.theta=theta,this.phi=phi,this.stepFactor=stepFactor,this.epsilonScaling=epsilonScaling,this.minEpsilon=minEpsilon,this.cameraPos=cameraPos,this.lockedOnOrigin=lockedOnOrigin,this.lightPos=lightPos,this.lightBrightness=lightBrightness,this.useOppositeLight=useOppositeLight,this.oppositeLightBrightness=oppositeLightBrightness,this.ambientLight=ambientLight,this.useBloom=useBloom,this.bloomPower=bloomPower,this.useShadows=useShadows,this.useReflections=useReflections,this.lockedOnOrigin?this.distanceFromOrigin=RaymarchApplet.magnitude(this.cameraPos):this.listenForKeysPressed(["w","s","a","d","q","e"," ","shift","z"],(key,pressed)=>{if("z"===key){const t={t:0},e=this.fovFactor,i=pressed?5:1;anime({targets:t,t:1,duration:250,easing:"easeOutCubic",update:()=>{this.fovFactor=(1-t.t)*e+t.t*i,this.needNewFrame=!0}})}});const t=setInterval(()=>{this?.wilson?.draggables?.container&&(this.listenForNumTouches(),clearInterval(t))},100);var e={renderer:"gpu",shader:this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl}),canvasWidth:this.imageWidth,canvasHeight:this.imageHeight,worldCenterX:-this.theta,worldCenterY:-this.phi,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:this.changeResolution.bind(this),mousedownCallback:this.onGrabCanvas.bind(this),touchstartCallback:this.onGrabCanvas.bind(this),mousedragCallback:this.onDragCanvas.bind(this),touchmoveCallback:this.onDragCanvas.bind(this),mouseupCallback:this.onReleaseCanvas.bind(this),touchendCallback:this.onReleaseCanvas.bind(this)};this.wilson=new Wilson(canvas,e),this.initUniforms();addTemporaryListener({object:window,event:"resize",callback:()=>this.changeResolution()}),this.resume()}createShader({distanceEstimatorGlsl=this.distanceEstimatorGlsl,getColorGlsl=this.getColorGlsl,getReflectivityGlsl=this.getReflectivityGlsl,getGeodesicGlsl=this.getGeodesicGlsl,addGlsl=this.addGlsl}){this.distanceEstimatorGlsl=distanceEstimatorGlsl,this.getColorGlsl=getColorGlsl,this.getReflectivityGlsl=getReflectivityGlsl,this.getGeodesicGlsl=getGeodesicGlsl,this.addGlsl=addGlsl;var t=this.useShadows&&this.useSoftShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float softShadowFactor = 1.0;
				float t = 0.0;

				float lastDistanceToScene = 100000.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					// Use Sebastian Aaltonen's improvement to Inigo Quilez's soft shadow algorithm.
					float distanceToScene = distanceEstimator(pos);
					float y = distanceToScene * distanceToScene / (2.0 * lastDistanceToScene);
        			float d = sqrt(distanceToScene * distanceToScene - y * y);

					softShadowFactor = min(
						softShadowFactor,
						d / (max(t - y, 0.0) * 0.025) 
					);

					lastDistanceToScene = distanceToScene;

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (t > clipDistance || length(pos - lightPos) < 0.2)
					{
						return clamp(softShadowFactor, maxShadowAmount, 1.0);
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return clamp(softShadowFactor, maxShadowAmount, 1.0);
			}
		`:this.useShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float t = 0.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (t > clipDistance)
					{
						return 1.0;
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return 1.0;
			}
		`:"",e=this.useReflections?`
			vec3 computeShadingWithoutReflection(
				vec3 pos,
				float epsilon,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}

			// Unlike in raymarch(), startPos is replacing cameraPos, and rayDirectionVec is precomputed.
			vec3 computeReflection(vec3 startPos, vec3 rayDirectionVec, int startIteration)
			{
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxReflectionMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};;
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (distanceToScene < epsilon)
					{
						return computeShadingWithoutReflection(
							pos,
							epsilon,
							distanceToScene - 2.0 * epsilon,
							iteration + startIteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
		`:"",i=this.useBloom?`
			float computeBloom(vec3 rayDirectionVec)
			{
				return pow(
					(3.0 - distance(
						normalize(rayDirectionVec),
						normalize(lightPos - cameraPos)
					)) / 2.99,
					${getFloatGlsl(20/this.bloomPower)}
				);
			}
		`:"",i=`
			precision highp float;
			
			varying vec2 uv;
			
			uniform float aspectRatioX;
			uniform float aspectRatioY;
			
			uniform vec3 cameraPos;
			uniform vec3 imagePlaneCenterPos;
			uniform vec3 forwardVec;
			uniform vec3 rightVec;
			uniform vec3 upVec;
			uniform int imageSize;
			uniform float epsilonScaling;
			uniform float minEpsilon;

			${Object.entries(this.uniforms).map(([key,value])=>`uniform ${value[0]} ${key};`).join("\n")}
			
			const vec3 lightPos = ${getVectorGlsl(this.lightPos)};
			const float lightBrightness = ${getFloatGlsl(this.lightBrightness)};
			const float bloomPower = ${getFloatGlsl(this.bloomPower)};
			
			const float clipDistance = ${getFloatGlsl(this.clipDistance)};
			const int maxMarches = ${this.maxMarches};
			const int maxShadowMarches = ${this.maxShadowMarches};
			const int maxReflectionMarches = ${this.maxReflectionMarches};
			const vec3 fogColor = ${getVectorGlsl(this.fogColor)};
			const float fogScaling = ${getFloatGlsl(this.fogScaling)};
			const float maxShadowAmount = 0.5;

			${addGlsl}
			
			
			
			float distanceEstimator(vec3 pos)
			{
				${distanceEstimatorGlsl}
			}
			
			vec3 getColor(vec3 pos)
			{
				${getColorGlsl}
			}

			${this.useReflections?`float getReflectivity(vec3 pos)
			{
				${getReflectivityGlsl}
			}`:""}
			
			
			
			vec3 getSurfaceNormal(vec3 pos, float epsilon)
			{
				float xStep1 = distanceEstimator(pos + vec3(epsilon, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, epsilon, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, epsilon));
				
				float xStep2 = distanceEstimator(pos - vec3(epsilon, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, epsilon, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, epsilon));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}

			${i}

			${t}

			${e}
			
			vec3 computeShading(
				vec3 pos,
				float epsilon,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}

				${this.useReflections?`
					vec3 reflectedDirection = reflect(normalize(pos - cameraPos) * ${getFloatGlsl(this.stepFactor)}, surfaceNormal);

					color = mix(
						color,
						computeReflection(pos, reflectedDirection, iteration),
						getReflectivity(pos)
					);
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}


			
			vec3 raymarch(vec3 startPos)
			{
				vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
				
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};;
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);
					
					if (distanceToScene < epsilon)
					{
						return computeShading(
							pos,
							epsilon,
							distanceToScene - 2.0 * epsilon,
							iteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
			
			
			
			void main(void)
			{
				vec3 finalColor = raymarch(
					imagePlaneCenterPos + rightVec * uv.x * aspectRatioX + upVec * uv.y / aspectRatioY
				);
				
				gl_FragColor = vec4(finalColor.xyz, 1.0);
			}
		`;return window.DEBUG&&console.log(i),i}initUniforms(){this.wilson.render.initUniforms(["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","epsilonScaling","minEpsilon",...Object.keys(this.uniforms)]),this.calculateVectors(),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,Math.max(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,Math.min(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1i(this.wilson.uniforms.imageSize,this.imageSize),this.wilson.gl.uniform3fv(this.wilson.uniforms.cameraPos,this.cameraPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.imagePlaneCenterPos,this.imagePlaneCenterPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.forwardVec,this.forwardVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.rightVec,this.rightVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.upVec,this.upVec),this.wilson.gl.uniform1f(this.wilson.uniforms.epsilonScaling,this.epsilonScaling),this.wilson.gl.uniform1f(this.wilson.uniforms.minEpsilon,this.minEpsilon);for(const i in this.uniforms){var t=this.uniforms[i],e=setUniformFunctions[t[0]];this.wilson.gl[e[0]](this.wilson.uniforms[i],...e[1],t[1])}}reloadShader({distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl}={}){this.wilson.render.shaderPrograms=[],this.wilson.render.loadNewShader(this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl})),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0]),this.initUniforms(),this.needNewFrame=!0}calculateVectors(){var t=this.lockedOnOrigin?-this.theta:this.theta,e=this.lockedOnOrigin?Math.PI-this.phi:this.phi;this.forwardVec=[Math.cos(t)*Math.sin(e),Math.sin(t)*Math.sin(e),Math.cos(e)],this.rightVec=RaymarchApplet.normalize([this.forwardVec[1],-this.forwardVec[0],0]),this.upVec=RaymarchApplet.crossProduct(this.rightVec,this.forwardVec),this.lockedOnOrigin&&(this.cameraPos=RaymarchApplet.scaleVector(-this.distanceFromOrigin,this.forwardVec)),this.speedFactor=Math.min(this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),.5)/4,this.forwardVec[0]*=this.speedFactor/1.5,this.forwardVec[1]*=this.speedFactor/1.5,this.forwardVec[2]*=this.speedFactor/1.5,this.rightVec[0]*=this.speedFactor/this.fovFactor,this.rightVec[1]*=this.speedFactor/this.fovFactor,this.upVec[0]*=this.speedFactor/this.fovFactor,this.upVec[1]*=this.speedFactor/this.fovFactor,this.upVec[2]*=this.speedFactor/this.fovFactor;this.imagePlaneCenterPos=[this.cameraPos[0]+2*this.forwardVec[0],this.cameraPos[1]+2*this.forwardVec[1],this.cameraPos[2]+2*this.forwardVec[2]],this.wilson.gl.uniform3fv(this.wilson.uniforms.cameraPos,this.cameraPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.imagePlaneCenterPos,this.imagePlaneCenterPos),this.wilson.gl.uniform3fv(this.wilson.uniforms.forwardVec,this.forwardVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.rightVec,this.rightVec),this.wilson.gl.uniform3fv(this.wilson.uniforms.upVec,this.upVec)}distanceEstimator(){throw new Error("Distance estimator not implemented!")}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.wilson.worldCenterY=Math.min(Math.max(this.wilson.worldCenterY,.01-Math.PI),-.01),this.theta=-this.wilson.worldCenterX,this.phi=-this.wilson.worldCenterY,this.wilson.render.drawFrame()}moveUpdate(timeElapsed){var t,e;this.keysPressed.w||2===this.numTouches?this.moveVelocity[0]=1:!this.keysPressed.s&&3!==this.numTouches||(this.moveVelocity[0]=-1),this.keysPressed.d?this.moveVelocity[1]=1:this.keysPressed.a&&(this.moveVelocity[1]=-1),this.keysPressed[" "]?this.moveVelocity[2]=1:this.keysPressed.shift&&(this.moveVelocity[2]=-1),this.lockedOnOrigin||0===this.moveVelocity[0]&&0===this.moveVelocity[1]&&0===this.moveVelocity[2]||(e=void 0!==this.lockZ?RaymarchApplet.scaleVector(RaymarchApplet.magnitude(this.forwardVec),RaymarchApplet.normalize([this.forwardVec[0],this.forwardVec[1],0])):this.forwardVec,t=void 0!==this.lockZ?RaymarchApplet.scaleVector(RaymarchApplet.magnitude(this.rightVec),RaymarchApplet.normalize([this.rightVec[0],this.rightVec[1],0])):this.rightVec,e=[this.moveVelocity[0]*e[0]+this.moveVelocity[1]*t[0],this.moveVelocity[0]*e[1]+this.moveVelocity[1]*t[1],this.moveVelocity[0]*e[2]+this.moveVelocity[1]*t[2]+this.moveVelocity[2]*this.speedFactor/1.5],this.cameraPos[0]+=this.movingSpeed*e[0]*(timeElapsed/6.944),this.cameraPos[1]+=this.movingSpeed*e[1]*(timeElapsed/6.944),this.cameraPos[2]=this.lockZ??this.cameraPos[2]+this.movingSpeed*e[2]*(timeElapsed/6.944),this.needNewFrame=!0),this.calculateVectors();for(let i=0;i<3;i++)this.moveVelocity[i]*=this.moveFriction**(timeElapsed/6.944),Math.abs(this.moveVelocity[i])<this.moveStopThreshhold&&(this.moveVelocity[i]=0)}changeResolution(resolution=this.imageSize){this.imageSize=Math.max(50,resolution),this.wilson.fullscreen.currentlyFullscreen?[this.imageWidth,this.imageHeight]=Applet.getEqualPixelFullScreen(this.imageSize):(this.imageWidth=this.imageSize,this.imageHeight=this.imageSize),this.wilson.changeCanvasSize(this.imageWidth,this.imageHeight),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioX,Math.max(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1f(this.wilson.uniforms.aspectRatioY,Math.min(this.imageWidth/this.imageHeight,1)),this.wilson.gl.uniform1i(this.wilson.uniforms.imageSize,this.imageSize),this.needNewFrame=!0}setUniform(name,value){this.uniforms[name][1]=value;var t=setUniformFunctions[this.uniforms[name][0]];this.wilson.gl[t[0]](this.wilson.uniforms[name],...t[1],value)}setEpsilonScaling(value){this.epsilonScaling=value,this.wilson.gl.uniform1f(this.wilson.uniforms.epsilonScaling,this.epsilonScaling)}setMinEpsilon(value){this.minEpsilon=value,this.wilson.gl.uniform1f(this.wilson.uniforms.minEpsilon,this.minEpsilon)}static magnitude(vec){return Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])}static addVectors(vec1,vec2){return[vec1[0]+vec2[0],vec1[1]+vec2[1],vec1[2]+vec2[2]]}static scaleVector(c,vec){return[c*vec[0],c*vec[1],c*vec[2]]}static dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]}static dotProduct4(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}static crossProduct(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}static matMul(mat1,mat2){return[[mat1[0][0]*mat2[0][0]+mat1[0][1]*mat2[1][0]+mat1[0][2]*mat2[2][0],mat1[0][0]*mat2[0][1]+mat1[0][1]*mat2[1][1]+mat1[0][2]*mat2[2][1],mat1[0][0]*mat2[0][2]+mat1[0][1]*mat2[1][2]+mat1[0][2]*mat2[2][2]],[mat1[1][0]*mat2[0][0]+mat1[1][1]*mat2[1][0]+mat1[1][2]*mat2[2][0],mat1[1][0]*mat2[0][1]+mat1[1][1]*mat2[1][1]+mat1[1][2]*mat2[2][1],mat1[1][0]*mat2[0][2]+mat1[1][1]*mat2[1][2]+mat1[1][2]*mat2[2][2]],[mat1[2][0]*mat2[0][0]+mat1[2][1]*mat2[1][0]+mat1[2][2]*mat2[2][0],mat1[2][0]*mat2[0][1]+mat1[2][1]*mat2[1][1]+mat1[2][2]*mat2[2][1],mat1[2][0]*mat2[0][2]+mat1[2][1]*mat2[1][2]+mat1[2][2]*mat2[2][2]]]}static qmul(x1,y1,z1,w1,x2,y2,z2,w2){return[x1*x2-y1*y2-z1*z1-w1*w2,x1*y2+y1*x2+z1*w2-w1*z2,x1*z2-y1*w2+z1*x2+w1*y2,x1*w2+y1*z2-z1*y2+w1*x2]}static normalize(vec){var t=RaymarchApplet.magnitude(vec);return[vec[0]/t,vec[1]/t,vec[2]/t]}}export{RaymarchApplet};