import anime from"../anime.min.js";import{addTemporaryListener}from"../src/main.min.js";import{Wilson}from"../wilson.min.js";import{AnimationFrameApplet}from"./animationFrameApplet.min.js";import{getEqualPixelFullScreen,getFloatGlsl,getVectorGlsl}from"./applet.min.js";const setUniformFunctions={int:(gl,location,value)=>gl.uniform1i(location,value),float:(gl,location,value)=>gl.uniform1f(location,value),vec2:(gl,location,value)=>gl.uniform2fv(location,value),vec3:(gl,location,value)=>gl.uniform3fv(location,value),vec4:(gl,location,value)=>gl.uniform4fv(location,value),mat2:(gl,location,value)=>gl.uniformMatrix2fv(location,!1,[value[0][0],value[1][0],value[0][1],value[1][1]]),mat3:(gl,location,value)=>gl.uniformMatrix3fv(location,!1,[value[0][0],value[1][0],value[2][0],value[0][1],value[1][1],value[2][1],value[0][2],value[1][2],value[2][2]]),mat4:(gl,location,value)=>gl.uniformMatrix4fv(location,!1,[value[0][0],value[1][0],value[2][0],value[3][0],value[0][1],value[1][1],value[2][1],value[3][1],value[0][2],value[1][2],value[2][2],value[3][2],value[0][3],value[1][3],value[2][3],value[3][3]])};class RaymarchApplet extends AnimationFrameApplet{movingSpeed=.1;moveVelocity=[0,0,0];moveFriction=.96;moveStopThreshhold=.01;lastTimestamp=-1;theta=0;phi=0;imageSize=500;imageWidth=500;imageHeight=500;maxMarches;maxShadowMarches;maxReflectionMarches;clipDistance;imagePlaneCenterPos=[];forwardVec=[];rightVec=[];upVec=[];cameraPos;lightPos;lightBrightness;useOppositeLight;oppositeLightBrightness;ambientLight;bloomPower;fogColor;fogScaling;stepFactor;epsilonScaling;minEpsilon;useShadows;useSoftShadows;useReflections;useBloom;useAntialiasing;uniforms={};lockZ;speedFactor=2;fovFactor=1;lockedOnOrigin=!1;distanceFromOrigin=1;distanceEstimatorGlsl;getColorGlsl;getReflectivityGlsl;getGeodesicGlsl;addGlsl;constructor({canvas,shader,resolution=500,distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl="return 0.2;",getGeodesicGlsl=(pos,dir)=>pos+" + t * "+dir,addGlsl="",uniforms={},theta=0,phi=Math.PI/2,stepFactor=.95,epsilonScaling=1.75,minEpsilon=3e-7,maxMarches=128,maxShadowMarches=128,maxReflectionMarches=128,clipDistance=1e3,cameraPos=[0,0,0],lockedOnOrigin=!0,lockZ,lightPos=[50,70,100],lightBrightness=1,useOppositeLight=!1,oppositeLightBrightness=.5,ambientLight=.25,bloomPower=1,fogColor=[0,0,0],fogScaling=.05,useShadows=!1,useSoftShadows=!0,useReflections=!1,useBloom=!0,useAntialiasing=!1}){super(canvas),this.imageSize=resolution,this.imageWidth=resolution,this.imageHeight=resolution,this.theta=theta,this.phi=phi,this.stepFactor=stepFactor,this.epsilonScaling=epsilonScaling,this.minEpsilon=minEpsilon,this.maxMarches=maxMarches,this.maxShadowMarches=maxShadowMarches,this.maxReflectionMarches=maxReflectionMarches,this.clipDistance=clipDistance,this.cameraPos=cameraPos,this.lockedOnOrigin=lockedOnOrigin,this.lockZ=lockZ,this.lightPos=lightPos,this.lightBrightness=lightBrightness,this.useOppositeLight=useOppositeLight,this.oppositeLightBrightness=oppositeLightBrightness,this.ambientLight=ambientLight,this.bloomPower=bloomPower,this.fogColor=fogColor,this.fogScaling=fogScaling,this.useShadows=useShadows,this.useSoftShadows=useSoftShadows,this.useReflections=useReflections,this.useBloom=useBloom,this.useAntialiasing=useAntialiasing,this.uniforms={aspectRatioX:["float",Math.max(this.imageWidth/this.imageHeight,1)],aspectRatioY:["float",Math.min(this.imageWidth/this.imageHeight,1)],imageSize:["int",this.imageSize],cameraPos:["vec3",this.cameraPos],imagePlaneCenterPos:["vec3",this.imagePlaneCenterPos],forwardVec:["vec3",this.forwardVec],rightVec:["vec3",this.rightVec],upVec:["vec3",this.upVec],epsilonScaling:["float",this.epsilonScaling],minEpsilon:["float",this.minEpsilon],uvCenter:["vec2",[0,0]],uvScale:["float",1],...uniforms},this.listenForKeysPressed(["w","s","a","d","q","e"," ","shift","z"],(key,pressed)=>{if("z"===key){const e={t:0},t=this.fovFactor,i=pressed?4:1,s=this.uniforms.epsilonScaling[1],a=pressed?4*this.uniforms.epsilonScaling[1]:this.uniforms.epsilonScaling[1]/4;anime({targets:e,t:1,duration:250,easing:"easeOutCubic",update:()=>{this.fovFactor=(1-e.t)*t+e.t*i,this.setUniform("epsilonScaling",(1-e.t)*s+e.t*a),this.needNewFrame=!0}})}}),this.distanceFromOrigin=magnitude(this.cameraPos);const e=setInterval(()=>{this?.wilson?.draggables?.container&&(this.listenForNumTouches(),clearInterval(e))},100);var t={renderer:"gpu",shader:shader??this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl}),canvasWidth:this.imageWidth,canvasHeight:this.imageHeight,worldCenterX:-this.theta,worldCenterY:-this.phi,useFullscreen:!0,trueFullscreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png",switchFullscreenCallback:this.changeResolution.bind(this),mousedownCallback:this.onGrabCanvas.bind(this),touchstartCallback:this.onGrabCanvas.bind(this),mousedragCallback:this.onDragCanvas.bind(this),touchmoveCallback:this.onDragCanvas.bind(this),mouseupCallback:this.onReleaseCanvas.bind(this),touchendCallback:this.onReleaseCanvas.bind(this)};this.wilson=new Wilson(canvas,t),this.initUniforms(0),this.useAntialiasing&&(this.wilson.render.loadNewShader(this.getEdgeDetectShader()),this.wilson.render.initUniforms(["stepSize"],1),t=shader??this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl,antialiasing:!addGlsl.includes("sampler2D")}),this.wilson.render.loadNewShader(t),this.wilson.render.initUniforms(["stepSize"],2),this.initUniforms(2),this.createTextures());addTemporaryListener({object:window,event:"resize",callback:()=>this.changeResolution()}),this.resume()}onDragCanvas(x,y,xDelta,yDelta){var e=this.lockedOnOrigin?-1:1;this.pan.onDragCanvas(x,y,e*xDelta,e*yDelta)}createShader({distanceEstimatorGlsl=this.distanceEstimatorGlsl,getColorGlsl=this.getColorGlsl,getReflectivityGlsl=this.getReflectivityGlsl,getGeodesicGlsl=this.getGeodesicGlsl,addGlsl=this.addGlsl,antialiasing=!1}){this.distanceEstimatorGlsl=distanceEstimatorGlsl,this.getColorGlsl=getColorGlsl,this.getReflectivityGlsl=getReflectivityGlsl,this.getGeodesicGlsl=getGeodesicGlsl,this.addGlsl=addGlsl;var e=this.useShadows&&this.useSoftShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float softShadowFactor = 1.0;
				float t = 0.0;

				float lastDistanceToScene = 100000.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					// Use Sebastian Aaltonen's improvement to Inigo Quilez's soft shadow algorithm.
					float distanceToScene = distanceEstimator(pos);
					float y = distanceToScene * distanceToScene / (2.0 * lastDistanceToScene);
        			float d = sqrt(distanceToScene * distanceToScene - y * y);

					softShadowFactor = min(
						softShadowFactor,
						d / (max(t - y, 0.0) * 0.025) 
					);

					lastDistanceToScene = distanceToScene;

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (t > clipDistance || length(pos - lightPos) < 0.2)
					{
						return clamp(softShadowFactor, maxShadowAmount, 1.0);
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return clamp(softShadowFactor, maxShadowAmount, 1.0);
			}
		`:this.useShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float t = 0.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (t > clipDistance)
					{
						return 1.0;
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return 1.0;
			}
		`:"",t=this.useReflections?`
			vec3 computeShadingWithoutReflection(
				vec3 pos,
				float epsilon,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}

			// Unlike in raymarch(), startPos is replacing cameraPos, and rayDirectionVec is precomputed.
			vec3 computeReflection(
				vec3 startPos,
				vec3 rayDirectionVec,
				int startIteration
			) {
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxReflectionMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);

					if (distanceToScene < epsilon)
					{
						return computeShadingWithoutReflection(
							pos,
							epsilon,
							distanceToScene - 2.0 * epsilon,
							iteration + startIteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
		`:"",i=this.useBloom?`
			float computeBloom(vec3 rayDirectionVec)
			{
				return pow(
					(3.0 - distance(
						normalize(rayDirectionVec),
						normalize(lightPos - cameraPos)
					)) / 2.99,
					${getFloatGlsl(20/this.bloomPower)}
				);
			}
		`:"",s=antialiasing?`
				vec3 raymarchHelper(vec2 uvAdjust)
				{
					return raymarch(
						imagePlaneCenterPos
							+ rightVec * (uvScale * (uv.x + uvAdjust.x) + uvCenter.x) * aspectRatioX
							+ upVec * (uvScale * (uv.y + uvAdjust.y) + uvCenter.y) / aspectRatioY
					);
				}
				
				void main(void)
				{
					vec2 texCoord = (uv + vec2(1.0)) * 0.5;
					vec4 sample = texture2D(uTexture, texCoord);
					
					if (sample.w > 0.2)
					{
						vec3 aaSample = (
							sample.xyz
							+ raymarchHelper(vec2(stepSize, 0.0))
							+ raymarchHelper(vec2(0.0, stepSize))
							+ raymarchHelper(vec2(-stepSize, 0.0))
							+ raymarchHelper(vec2(0.0, -stepSize))
						) / 5.0;
						
						gl_FragColor = vec4(aaSample, 1.0);
						return;
					}

					gl_FragColor = vec4(sample.xyz, 1.0);
				}
			`:`
				void main(void)
				{
					vec3 finalColor = raymarch(
						imagePlaneCenterPos
							+ rightVec * (uvScale * uv.x + uvCenter.x) * aspectRatioX
							+ upVec * (uvScale * uv.y + uvCenter.y) / aspectRatioY
					);

					gl_FragColor = vec4(finalColor.xyz, 1.0);
				}
			`,i=`
			precision highp float;
			
			varying vec2 uv;

			${Object.entries(this.uniforms).map(([key,value])=>`uniform ${value[0]} ${key};`).join("\n")}

			${antialiasing?`
				uniform sampler2D uTexture;
				uniform float stepSize;
			`:""}
			
			const vec3 lightPos = ${getVectorGlsl(this.lightPos)};
			const float lightBrightness = ${getFloatGlsl(this.lightBrightness)};
			const float bloomPower = ${getFloatGlsl(this.bloomPower)};
			
			const float clipDistance = ${getFloatGlsl(this.clipDistance)};
			const int maxMarches = ${this.maxMarches};
			const int maxShadowMarches = ${this.maxShadowMarches};
			const int maxReflectionMarches = ${this.maxReflectionMarches};
			const vec3 fogColor = ${getVectorGlsl(this.fogColor)};
			const float fogScaling = ${getFloatGlsl(this.fogScaling)};
			const float maxShadowAmount = 0.5;

			${addGlsl}
			
			
			
			float distanceEstimator(vec3 pos)
			{
				${distanceEstimatorGlsl}
			}
			
			vec3 getColor(vec3 pos)
			{
				${getColorGlsl}
			}

			${this.useReflections?`float getReflectivity(vec3 pos)
			{
				${getReflectivityGlsl}
			}`:""}
			
			
			
			vec3 getSurfaceNormal(vec3 pos, float epsilon)
			{
				float xStep1 = distanceEstimator(pos + vec3(epsilon, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, epsilon, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, epsilon));
				
				float xStep2 = distanceEstimator(pos - vec3(epsilon, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, epsilon, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, epsilon));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}

			${i}

			${e}

			${t}
			
			vec3 computeShading(
				vec3 pos,
				float epsilon,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}

				${this.useReflections?`
					vec3 reflectedDirection = reflect(normalize(pos - cameraPos) * ${getFloatGlsl(this.stepFactor)}, surfaceNormal);

					color = mix(
						color,
						computeReflection(pos, reflectedDirection, iteration),
						getReflectivity(pos)
					);
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}


			
			vec3 raymarch(vec3 startPos)
			{
				vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
				
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};;
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (float(imageSize) * epsilonScaling), minEpsilon);
					
					if (distanceToScene < epsilon)
					{
						return computeShading(
							pos,
							epsilon,
							distanceToScene - 2.0 * epsilon,
							iteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
			
			
			
			${s}
		`;return window.DEBUG&&console.log(i),i}getEdgeDetectShader(){return`
			precision highp float;
			
			varying vec2 uv;

			uniform sampler2D uTexture;

			uniform float stepSize;

			float getSampleLuminanceDelta(vec3 color, vec2 texCoord)
			{
				vec3 sample = texture2D(uTexture, texCoord).xyz;
				return 0.299 * abs(sample.x - color.x)
					+ 0.587 * abs(sample.y - color.y)
					+ 0.114 * abs(sample.z - color.z);
			}

			void main(void)
			{
				vec2 texCoord = (uv + vec2(1.0)) * 0.5;
				vec3 sample = texture2D(uTexture, texCoord).xyz;
				float sampleN = getSampleLuminanceDelta(sample, texCoord + vec2(0.0, stepSize));
				float sampleS = getSampleLuminanceDelta(sample, texCoord + vec2(0.0, -stepSize));
				float sampleE = getSampleLuminanceDelta(sample, texCoord + vec2(stepSize, 0.0));
				float sampleW = getSampleLuminanceDelta(sample, texCoord + vec2(-stepSize, 0.0));

				float luminance = max(
					max(sampleN, sampleS),
					max(sampleE, sampleW)
				);
				
				gl_FragColor = vec4(
					texture2D(uTexture, texCoord).xyz,
					luminance
				);
			}
		`}initUniforms(programIndex){var e=["aspectRatioX","aspectRatioY","imageSize","cameraPos","imagePlaneCenterPos","forwardVec","rightVec","upVec","epsilonScaling","minEpsilon","uvCenter","uvScale",...Object.keys(this.uniforms)];this.wilson.render.initUniforms(e,programIndex),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[programIndex]);for(const i in this.uniforms){var t=this.uniforms[i];"vec"===t[0].slice(0,3)&&0===t[1].length||(0,setUniformFunctions[t[0]])(this.wilson.gl,this.wilson.uniforms[i][programIndex],t[1])}}reloadShader({distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl}={}){var e;this.calculateVectors(),this.wilson.render.shaderPrograms=[],this.wilson.render.loadNewShader(this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl})),this.initUniforms(0),this.useAntialiasing&&(this.wilson.render.loadNewShader(this.getEdgeDetectShader()),this.wilson.render.initUniforms(["stepSize"],1),e=this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl,antialiasing:!0}),this.wilson.render.loadNewShader(e),this.initUniforms(2),this.wilson.render.initUniforms(["stepSize"],2),this.createTextures(),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0])),this.needNewFrame=!0}createTextures(){this.wilson.render.framebuffers=[],this.wilson.render.createFramebufferTexturePair(),this.wilson.render.createFramebufferTexturePair(),this.wilson.gl.bindTexture(this.wilson.gl.TEXTURE_2D,this.wilson.render.framebuffers[0].texture),this.wilson.gl.bindFramebuffer(this.wilson.gl.FRAMEBUFFER,null),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[1]),this.wilson.gl.uniform1f(this.wilson.uniforms.stepSize[1],1/this.imageSize),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[2]),this.wilson.gl.uniform1f(this.wilson.uniforms.stepSize[2],2/(3*this.imageSize)),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0])}calculateVectors(){this.forwardVec=[Math.cos(this.theta)*Math.sin(this.phi),Math.sin(this.theta)*Math.sin(this.phi),Math.cos(this.phi)],this.rightVec=normalize([this.forwardVec[1],-this.forwardVec[0],0]),this.upVec=crossProduct(this.rightVec,this.forwardVec),this.lockedOnOrigin&&(this.cameraPos=scaleVector(-this.distanceFromOrigin,this.forwardVec)),this.speedFactor=Math.min(this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),.5)/4,this.forwardVec[0]*=this.speedFactor/1.5,this.forwardVec[1]*=this.speedFactor/1.5,this.forwardVec[2]*=this.speedFactor/1.5,this.rightVec[0]*=this.speedFactor/this.fovFactor,this.rightVec[1]*=this.speedFactor/this.fovFactor,this.upVec[0]*=this.speedFactor/this.fovFactor,this.upVec[1]*=this.speedFactor/this.fovFactor,this.upVec[2]*=this.speedFactor/this.fovFactor;this.imagePlaneCenterPos=[this.cameraPos[0]+2*this.forwardVec[0],this.cameraPos[1]+2*this.forwardVec[1],this.cameraPos[2]+2*this.forwardVec[2]],this.setUniform("cameraPos",this.cameraPos),this.setUniform("imagePlaneCenterPos",this.imagePlaneCenterPos),this.setUniform("forwardVec",this.forwardVec),this.setUniform("rightVec",this.rightVec),this.setUniform("upVec",this.upVec)}distanceEstimator(){throw new Error("Distance estimator not implemented!")}prepareFrame(timeElapsed){this.pan.update(timeElapsed),this.zoom.update(timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.wilson.worldCenterY=Math.min(Math.max(this.wilson.worldCenterY,.01-Math.PI),-.01),this.wilson.worldCenterX<-Math.PI?this.wilson.worldCenterX+=2*Math.PI:this.wilson.worldCenterX>Math.PI&&(this.wilson.worldCenterX-=2*Math.PI),this.theta=-this.wilson.worldCenterX,this.phi=-this.wilson.worldCenterY,this.calculateVectors(),this.useAntialiasing&&this.wilson.gl.bindFramebuffer(this.wilson.gl.FRAMEBUFFER,this.wilson.render.framebuffers[0].framebuffer),this.wilson.render.drawFrame(),this.useAntialiasing&&(this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[1]),this.wilson.gl.bindTexture(this.wilson.gl.TEXTURE_2D,this.wilson.render.framebuffers[0].texture),this.wilson.gl.bindFramebuffer(this.wilson.gl.FRAMEBUFFER,this.wilson.render.framebuffers[1].framebuffer),this.wilson.render.drawFrame(),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[2]),this.wilson.gl.bindTexture(this.wilson.gl.TEXTURE_2D,this.wilson.render.framebuffers[1].texture),this.wilson.gl.bindFramebuffer(this.wilson.gl.FRAMEBUFFER,null),this.wilson.render.drawFrame(),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0]))}downloadFrame(filename){this.downloadMosaic(filename,8)}async downloadMosaic(filename,size){this.setUniform("uvScale",1/size),this.setUniform("imageSize",this.imageSize*size);const i=[];for(let e=0;e<size;e++)i.push((1+2*e)/size-1);const s=[];for(let t=0;t<size;t++){s.push([]);for(let e=0;e<size;e++)s[t].push(document.createElement("canvas")),s[t][e].width=this.imageWidth,s[t][e].height=this.imageHeight}const a=async()=>{var e=document.createElement("canvas"),t=(e.width=this.imageWidth*size,e.height=this.imageHeight*size,e.getContext("2d",{colorSpace:"display-p3"}));for(let i=0;i<size;i++)for(let e=0;e<size;e++)t.drawImage(s[i][e],i*this.imageWidth,e*this.imageHeight);t.translate(0,this.imageSize*size),t.scale(1,-1),t.drawImage(e,0,0),e.toBlob(blob=>{var e=document.createElement("a");e.href=URL.createObjectURL(blob),e.download=filename,e.click()}),await new Promise(resolve=>setTimeout(resolve,100)),this.setUniform("uvScale",1),this.setUniform("uvCenter",[0,0]),this.setUniform("imageSize",this.imageSize),this.needNewFrame=!0};let o=0,r=0;const l=async()=>{var e=s[o][r].getContext("2d",{colorSpace:"display-p3"}),t=(this.setUniform("uvCenter",[i[o],i[r]]),this.drawFrame(),new ImageData(new Uint8ClampedArray(this.wilson.render.getPixelData()),this.imageWidth,this.imageHeight));e.putImageData(t,0,0),await new Promise(resolve=>setTimeout(resolve,500)),++r===size&&(r=0,o++),o!==size?requestAnimationFrame(l):a()};requestAnimationFrame(l)}moveUpdate(timeElapsed){var e,t;this.keysPressed.w||2===this.numTouches?this.moveVelocity[0]=1:!this.keysPressed.s&&3!==this.numTouches||(this.moveVelocity[0]=-1),this.keysPressed.d?this.moveVelocity[1]=1:this.keysPressed.a&&(this.moveVelocity[1]=-1),this.keysPressed[" "]?this.moveVelocity[2]=1:this.keysPressed.shift&&(this.moveVelocity[2]=-1),this.lockedOnOrigin||0===this.moveVelocity[0]&&0===this.moveVelocity[1]&&0===this.moveVelocity[2]||(t=void 0!==this.lockZ?scaleVector(magnitude(this.forwardVec),normalize([this.forwardVec[0],this.forwardVec[1],0])):this.forwardVec,e=void 0!==this.lockZ?scaleVector(magnitude(this.rightVec),normalize([this.rightVec[0],this.rightVec[1],0])):this.rightVec,t=[this.moveVelocity[0]*t[0]+this.moveVelocity[1]*e[0],this.moveVelocity[0]*t[1]+this.moveVelocity[1]*e[1],this.moveVelocity[0]*t[2]+this.moveVelocity[1]*e[2]+this.moveVelocity[2]*this.speedFactor/1.5],this.cameraPos[0]+=this.movingSpeed*t[0]*(timeElapsed/6.944),this.cameraPos[1]+=this.movingSpeed*t[1]*(timeElapsed/6.944),this.cameraPos[2]=this.lockZ??this.cameraPos[2]+this.movingSpeed*t[2]*(timeElapsed/6.944),this.needNewFrame=!0);for(let i=0;i<3;i++)this.moveVelocity[i]*=this.moveFriction**(timeElapsed/6.944),Math.abs(this.moveVelocity[i])<this.moveStopThreshhold&&(this.moveVelocity[i]=0)}changeResolution(resolution=this.imageSize){this.imageSize=Math.max(50,resolution),this.aspectRatio=this.wilson.fullscreen.currentlyFullscreen?window.innerWidth/window.innerHeight:this.nonFullscreenAspectRatio,[this.imageWidth,this.imageHeight]=getEqualPixelFullScreen(this.imageSize,this.aspectRatio),this.wilson.changeCanvasSize(this.imageWidth,this.imageHeight),this.setUniform("aspectRatioX",Math.max(this.aspectRatio,1)),this.setUniform("aspectRatioY",Math.min(this.aspectRatio,1)),this.setUniform("imageSize",this.imageSize),this.useAntialiasing&&this.createTextures(),this.needNewFrame=!0}setUniform(name,value){this.uniforms[name][1]=value;var e=setUniformFunctions[this.uniforms[name][0]];e(this.wilson.gl,this.wilson.uniforms[name][0],value),this.useAntialiasing&&(this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[2]),e(this.wilson.gl,this.wilson.uniforms[name][2],value),this.wilson.gl.useProgram(this.wilson.render.shaderPrograms[0]))}animateUniform({name,value,duration=1e3}){const e={t:this.uniforms[name][1]};return anime({targets:e,t:value,duration:duration,easing:"easeInOutQuart",update:()=>{this.setUniform(name,e.t),this.needNewFrame=!0}}).finished}loopUniform({name,startValue,endValue,duration=2e3}){const e={t:0};return anime({targets:e,t:1,duration:duration,easing:"easeInOutQuad",loop:!0,direction:"alternate",update:()=>{this.setUniform(name,startValue+(endValue-startValue)*e.t),this.needNewFrame=!0}})}async setLockedOnOrigin(value){if(value&&!this.lockedOnOrigin){var t=magnitude(this.cameraPos);const s=normalize(this.cameraPos);var i=Math.PI-Math.acos(this.cameraPos[2]/t);let e=Math.atan2(this.cameraPos[1],this.cameraPos[0])+Math.PI;e>Math.PI&&(e-=2*Math.PI);const a={r:t,theta:this.theta,phi:this.phi};await anime({targets:a,theta:e,phi:i,r:this.distanceFromOrigin,duration:500,easing:"easeOutCubic",update:()=>{this.wilson.worldCenterX=-a.theta,this.wilson.worldCenterY=-a.phi,this.cameraPos=scaleVector(a.r,s),this.needNewFrame=!0}}).finished}this.lockedOnOrigin=value}}function magnitude(vec){return Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])}function addVectors(vec1,vec2){return[vec1[0]+vec2[0],vec1[1]+vec2[1],vec1[2]+vec2[2]]}function scaleVector(c,vec){return[c*vec[0],c*vec[1],c*vec[2]]}function dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]}function dotProduct4(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}function crossProduct(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}function matMul(mat1,mat2){return[[mat1[0][0]*mat2[0][0]+mat1[0][1]*mat2[1][0]+mat1[0][2]*mat2[2][0],mat1[0][0]*mat2[0][1]+mat1[0][1]*mat2[1][1]+mat1[0][2]*mat2[2][1],mat1[0][0]*mat2[0][2]+mat1[0][1]*mat2[1][2]+mat1[0][2]*mat2[2][2]],[mat1[1][0]*mat2[0][0]+mat1[1][1]*mat2[1][0]+mat1[1][2]*mat2[2][0],mat1[1][0]*mat2[0][1]+mat1[1][1]*mat2[1][1]+mat1[1][2]*mat2[2][1],mat1[1][0]*mat2[0][2]+mat1[1][1]*mat2[1][2]+mat1[1][2]*mat2[2][2]],[mat1[2][0]*mat2[0][0]+mat1[2][1]*mat2[1][0]+mat1[2][2]*mat2[2][0],mat1[2][0]*mat2[0][1]+mat1[2][1]*mat2[1][1]+mat1[2][2]*mat2[2][1],mat1[2][0]*mat2[0][2]+mat1[2][1]*mat2[1][2]+mat1[2][2]*mat2[2][2]]]}function qmul(x1,y1,z1,w1,x2,y2,z2,w2){return[x1*x2-y1*y2-z1*z1-w1*w2,x1*y2+y1*x2+z1*w2-w1*z2,x1*z2-y1*w2+z1*x2+w1*y2,x1*w2+y1*z2-z1*y2+w1*x2]}function normalize(vec){var e=magnitude(vec);return[vec[0]/e,vec[1]/e,vec[2]/e]}function getRotationMatrix(thetaX,thetaY,thetaZ){var e=Math.cos(thetaX),t=Math.sin(thetaX),i=Math.cos(thetaY),s=Math.sin(thetaY),a=Math.cos(thetaZ),o=Math.sin(thetaZ),t=[[1,0,0],[0,e,-t],[0,t,e]];return matMul(matMul([[a,-o,0],[o,a,0],[0,0,1]],[[i,0,-s],[0,1,0],[s,0,i]]),t)}function mat3TimesVector(mat,vec){return[mat[0][0]*vec[0]+mat[0][1]*vec[1]+mat[0][2]*vec[2],mat[1][0]*vec[0]+mat[1][1]*vec[1]+mat[1][2]*vec[2],mat[2][0]*vec[0]+mat[2][1]*vec[1]+mat[2][2]*vec[2]]}export{RaymarchApplet,magnitude,addVectors,scaleVector,dotProduct,dotProduct4,crossProduct,matMul,qmul,normalize,getRotationMatrix,mat3TimesVector};