import anime from"../anime.min.js";import{doubleEncodingGlsl}from"../src/complexGlsl.min.js";import{WilsonGPU}from"../wilson.min.js";import{AnimationFrameApplet}from"./animationFrameApplet.min.js";import{getFloatGlsl,getVectorGlsl,tempShader}from"./applet.min.js";const edgeDetectShader=`
	precision highp float;
	
	varying vec2 uv;

	uniform sampler2D uTexture;

	uniform float stepSize;

	float getSampleLuminanceDelta(vec3 color, vec2 texCoord)
	{
		vec3 sample = texture2D(uTexture, texCoord).xyz;
		return 0.299 * abs(sample.x - color.x)
			+ 0.587 * abs(sample.y - color.y)
			+ 0.114 * abs(sample.z - color.z);
	}

	void main(void)
	{
		vec2 texCoord = (uv + vec2(1.0)) * 0.5;
		vec3 sample = texture2D(uTexture, texCoord).xyz;
		float sampleN = getSampleLuminanceDelta(sample, texCoord + vec2(0.0, stepSize));
		float sampleS = getSampleLuminanceDelta(sample, texCoord + vec2(0.0, -stepSize));
		float sampleE = getSampleLuminanceDelta(sample, texCoord + vec2(stepSize, 0.0));
		float sampleW = getSampleLuminanceDelta(sample, texCoord + vec2(-stepSize, 0.0));

		float luminance = max(
			max(sampleN, sampleS),
			max(sampleE, sampleW)
		);
		
		gl_FragColor = vec4(
			texture2D(uTexture, texCoord).xyz,
			luminance
		);
	}
`;class RaymarchApplet extends AnimationFrameApplet{movingSpeed=.1;moveVelocity=[0,0,0];moveFriction=.96;moveStopThreshhold=.01;lastTimestamp=-1;theta=0;phi=0;worldSize=2.5;resolution=500;maxMarches;maxShadowMarches;maxReflectionMarches;clipDistance;imagePlaneCenterPos=[0,0,0];forwardVec=[0,0,0];rightVec=[0,0,0];upVec=[0,0,0];focalLengthFactor;cameraPos;lightPos;lightBrightness;useOppositeLight;oppositeLightBrightness;ambientLight;bloomPower;fogColor;fogScaling;stepFactor;epsilonScaling;minEpsilon;useShadows;useSoftShadows;useReflections;useBloom;useAntialiasing;useFor3DPrinting;uniforms={};lockZ;speedFactor=2;fovFactor=1;lockedOnOrigin;distanceFromOrigin=1;distanceEstimatorGlsl;getColorGlsl;uniformsGlsl;getReflectivityGlsl;getGeodesicGlsl;addGlsl;constructor({canvas,shader,resolution=500,distanceEstimatorGlsl,getColorGlsl,uniformsGlsl="",getReflectivityGlsl="return 0.2;",getGeodesicGlsl=(pos,dir)=>pos+" + t * "+dir,addGlsl="",uniforms={},theta=0,phi=Math.PI/2,stepFactor=.95,epsilonScaling=1.75,minEpsilon=3e-7,maxMarches=128,maxShadowMarches=128,maxReflectionMarches=128,clipDistance=1e3,focalLengthFactor=2.5,cameraPos=[0,0,0],lockedOnOrigin=!0,lockZ,lightPos=[50,70,100],lightBrightness=1,useOppositeLight=!1,oppositeLightBrightness=.5,ambientLight=.25,bloomPower=1,fogColor=[0,0,0],fogScaling=.05,useShadows=!1,useSoftShadows=!0,useReflections=!1,useBloom=!0,useAntialiasing=!1,useFor3DPrinting=!1}){super(canvas),this.resolution=resolution,this.theta=theta,this.phi=phi,this.stepFactor=stepFactor,this.epsilonScaling=epsilonScaling,this.minEpsilon=minEpsilon,this.maxMarches=maxMarches,this.maxShadowMarches=maxShadowMarches,this.maxReflectionMarches=maxReflectionMarches,this.clipDistance=clipDistance,this.focalLengthFactor=focalLengthFactor,this.cameraPos=cameraPos,this.lockedOnOrigin=lockedOnOrigin,this.worldSize=this.lockedOnOrigin?2.5:1.5,this.lockZ=lockZ,this.lightPos=lightPos,this.lightBrightness=lightBrightness,this.useOppositeLight=useOppositeLight,this.oppositeLightBrightness=oppositeLightBrightness,this.ambientLight=ambientLight,this.bloomPower=bloomPower,this.fogColor=fogColor,this.fogScaling=fogScaling,this.useShadows=useShadows,this.useSoftShadows=useSoftShadows,this.useReflections=useReflections,this.useBloom=useBloom,this.useAntialiasing=useAntialiasing,this.useFor3DPrinting=useFor3DPrinting,this.uniformsGlsl=`
			uniform vec2 aspectRatio;
			uniform float resolution;
			uniform vec3 cameraPos;
			uniform vec3 imagePlaneCenterPos;
			uniform vec3 rightVec;
			uniform vec3 upVec;
			uniform float epsilonScaling;
			uniform float minEpsilon;
			uniform vec2 uvCenter;
			uniform float uvScale;
			${uniformsGlsl}
		`,this.uniforms={aspectRatio:[1,1],resolution:this.resolution,cameraPos:this.cameraPos,imagePlaneCenterPos:this.imagePlaneCenterPos,rightVec:this.rightVec,upVec:this.upVec,epsilonScaling:this.epsilonScaling,minEpsilon:this.minEpsilon,uvCenter:[0,0],uvScale:1,...uniforms},this.listenForKeysPressed(["w","s","a","d","q","e"," ","shift","z"],(key,pressed)=>{if("z"===key){const e={t:0},t=pressed?1:4,i=pressed?4:1;anime({targets:e,t:1,duration:250,easing:"easeOutCubic",update:()=>{this.fovFactor=(1-e.t)*t+e.t*i,this.setUniforms({epsilonScaling:this.epsilonScaling*((1-e.t)*t+e.t*i)}),this.needNewFrame=!0}})}}),this.distanceFromOrigin=magnitude(this.cameraPos);var t=shader??this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl}),e={shader:tempShader,canvasWidth:this.resolution,worldWidth:this.worldSize,worldHeight:this.worldSize,worldCenterX:this.theta,worldCenterY:this.phi,minWorldY:.001-this.worldSize/2,maxWorldY:Math.PI-.001+this.worldSize/2,onResizeCanvas:this.onResizeCanvas.bind(this),interactionOptions:{useForPanAndZoom:!0,disallowZooming:!0,onPanAndZoom:()=>{this.calculateVectors(),this.needNewFrame=!0},callbacks:{touchstart:this.onTouchStart.bind(this),touchend:this.onTouchEnd.bind(this)}},fullscreenOptions:{fillScreen:!0,useFullscreenButton:!0,enterFullscreenButtonIconPath:"/graphics/general-icons/enter-fullscreen.png",exitFullscreenButtonIconPath:"/graphics/general-icons/exit-fullscreen.png"}};this.wilson=new WilsonGPU(canvas,e),this.wilson.loadShader({id:"draw",source:t,uniforms:this.uniforms}),this.useAntialiasing&&(this.wilson.loadShader({id:"edgeDetect",source:edgeDetectShader,uniforms:{stepSize:1/this.resolution}}),e=shader??this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,getGeodesicGlsl:getGeodesicGlsl,addGlsl:addGlsl,antialiasing:!addGlsl.includes("sampler2D")}),this.wilson.loadShader({id:"antialias",source:e,uniforms:{...this.uniforms,stepSize:2/(3*this.resolution)}}),this.wilson.useShader("draw"),this.createTextures()),this.useFor3DPrinting&&this.make3DPrintable(),this.needNewFrame=!0,this.resume()}async make3DPrintable(){var e=1500;this.setUniform("uvScale",1.5),this.setUniform("epsilonScaling",.0015),this.changeResolution(e),this.setUniform("uvCenter",[-.5,0]),this.drawFrame(),await new Promise(resolve=>setTimeout(resolve,500));for(let t=1;t<=e;t++)this.setUniform("uvCenter",[t/e-.5,0]),this.drawFrame(),this.wilson.downloadFrame(t.toString().padStart(4,"0"),!1),await new Promise(resolve=>setTimeout(resolve,150))}createShader({distanceEstimatorGlsl=this.distanceEstimatorGlsl,getColorGlsl=this.getColorGlsl,getReflectivityGlsl=this.getReflectivityGlsl,getGeodesicGlsl=this.getGeodesicGlsl,addGlsl=this.addGlsl,antialiasing=!1,useForDepthBuffer=!1}){this.distanceEstimatorGlsl=distanceEstimatorGlsl,this.getColorGlsl=getColorGlsl,this.getReflectivityGlsl=getReflectivityGlsl,this.getGeodesicGlsl=getGeodesicGlsl,this.addGlsl=addGlsl;var e=this.useShadows&&this.useSoftShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float softShadowFactor = 1.0;
				float t = 0.0;

				float lastDistanceToScene = 100000.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					// Use Sebastian Aaltonen's improvement to Inigo Quilez's soft shadow algorithm.
					float distanceToScene = distanceEstimator(pos);
					float y = distanceToScene * distanceToScene / (2.0 * lastDistanceToScene);
        			float d = sqrt(distanceToScene * distanceToScene - y * y);

					softShadowFactor = min(
						softShadowFactor,
						d / (max(t - y, 0.0) * 0.025) 
					);

					lastDistanceToScene = distanceToScene;

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (t > clipDistance || length(pos - lightPos) < 0.2)
					{
						return clamp(softShadowFactor, maxShadowAmount, 1.0);
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return clamp(softShadowFactor, maxShadowAmount, 1.0);
			}
		`:this.useShadows?`
			// Nearly identical to raymarching, but it only marches toward the light.
			float computeShadowIntensity(vec3 startPos, vec3 lightDirection)
			{
				vec3 rayDirectionVec = normalize(lightDirection) * .25;
				float t = 0.0;

				for (int iteration = 0; iteration < maxShadowMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (t > clipDistance)
					{
						return 1.0;
					}

					if (distanceToScene < epsilon)
					{
						return maxShadowAmount;
					}
					
					t += distanceToScene;
				}

				return 1.0;
			}
		`:"",t=this.useReflections?`
			vec3 computeShadingWithoutReflection(
				vec3 pos,
				float epsilon,
				float correctionDistance,
				int iteration
			) {
				vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

				// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
				pos -= surfaceNormal * correctionDistance;
				
				vec3 lightDirection = normalize(lightPos - pos);
				
				float dotProduct = dot(surfaceNormal, lightDirection);
				
				float lightIntensity = max(
					${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
					${getFloatGlsl(this.ambientLight)}
				);

				vec3 color = getColor(pos)
					* lightIntensity
					* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

				${this.useShadows?`
					float shadowIntensity = computeShadowIntensity(pos, lightDirection);

					color *= shadowIntensity;
				`:""}
				
				//Apply fog.
				return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
			}

			// Unlike in raymarch(), startPos is replacing cameraPos, and rayDirectionVec is precomputed.
			vec3 computeReflection(
				vec3 startPos,
				vec3 rayDirectionVec,
				int startIteration
			) {
				float t = 0.0;
				
				for (int iteration = 0; iteration < maxReflectionMarches; iteration++)
				{
					vec3 pos = ${getGeodesicGlsl("startPos","rayDirectionVec")};
					
					float distanceToScene = distanceEstimator(pos);

					float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);

					if (distanceToScene < epsilon)
					{
						return computeShadingWithoutReflection(
							pos,
							epsilon,
							distanceToScene - 2.0 * epsilon,
							iteration + startIteration
						);
					}
					
					else if (t > clipDistance)
					{
						return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
					}
					
					t += distanceToScene;
				}
				
				return ${this.useBloom?"mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec))":"fogColor"};
			}
		`:"",i=this.useBloom?`
			float computeBloom(vec3 rayDirectionVec)
			{
				return pow(
					(3.0 - distance(
						normalize(rayDirectionVec),
						normalize(lightPos - cameraPos)
					)) / 2.99,
					${getFloatGlsl(20/this.bloomPower)}
				);
			}
		`:"",s=useForDepthBuffer?`
				vec3 computeShading(
					vec3 pos,
					float epsilon,
					float correctionDistance,
					int iteration
				) {
					gl_FragColor = encodeFloat(length(pos - cameraPos));
					return vec3(0.0);
				}
			`:`
				vec3 computeShading(
					vec3 pos,
					float epsilon,
					float correctionDistance,
					int iteration
				) {
					vec3 surfaceNormal = getSurfaceNormal(pos, epsilon);

					// This corrects the position so that it's exactly on the surface (we probably marched a little bit inside).
					pos -= surfaceNormal * correctionDistance;
					
					vec3 lightDirection = normalize(lightPos - pos);
					
					float dotProduct = dot(surfaceNormal, lightDirection);
					
					float lightIntensity = max(
						${this.useOppositeLight?`lightBrightness * max(dotProduct, -${getFloatGlsl(this.oppositeLightBrightness)} * dotProduct)`:"lightBrightness * dotProduct"},
						${getFloatGlsl(this.ambientLight)}
					);

					vec3 color = getColor(pos)
						* lightIntensity
						* max((1.0 - float(iteration) / float(maxMarches)), 0.0);

					${this.useShadows?`
						float shadowIntensity = computeShadowIntensity(pos, lightDirection);

						color *= shadowIntensity;
					`:""}

					${this.useReflections?`
						vec3 reflectedDirection = reflect(
							normalize(pos - cameraPos) * ${getFloatGlsl(this.stepFactor)},
							surfaceNormal
						);

						color = mix(
							color,
							computeReflection(pos, reflectedDirection, iteration),
							getReflectivity(pos)
						);
					`:""}
					
					//Apply fog.
					return mix(color, fogColor, 1.0 - exp(-distance(pos, cameraPos) * fogScaling));
				}
			`,o=useForDepthBuffer?`
					vec3 raymarch(vec3 startPos)
					{
						vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
						
						float t = 0.0;
						
						for (int iteration = 0; iteration < maxMarches; iteration++)
						{
							vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
							
							float distanceToScene = distanceEstimator(pos);

							float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
							
							if (distanceToScene < epsilon)
							{
								return computeShading(
									pos,
									epsilon,
									distanceToScene - 2.0 * epsilon,
									iteration
								);
							}
							
							else if (t > clipDistance)
							{
								gl_FragColor = encodeFloat(clipDistance);
								return vec3(0.0);
							}
							
							t += distanceToScene;
						}
						
						gl_FragColor = encodeFloat(clipDistance);
						return vec3(0.0);
					}
				`:this.useBloom?`
					vec3 raymarch(vec3 startPos)
					{
						vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
						
						float t = 0.0;
						
						for (int iteration = 0; iteration < maxMarches; iteration++)
						{
							vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
							
							float distanceToScene = distanceEstimator(pos);

							float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
							
							if (distanceToScene < epsilon)
							{
								return computeShading(
									pos,
									epsilon,
									distanceToScene - 2.0 * epsilon,
									iteration
								);
							}
							
							else if (t > clipDistance)
							{
								return mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec));
							}
							
							t += distanceToScene;
						}
						
						return mix(fogColor, vec3(1.0), computeBloom(rayDirectionVec));
					}
				`:`
				vec3 raymarch(vec3 startPos)
				{
					vec3 rayDirectionVec = normalize(startPos - cameraPos) * ${getFloatGlsl(this.stepFactor)};
					
					float t = 0.0;
					
					for (int iteration = 0; iteration < maxMarches; iteration++)
					{
						vec3 pos = ${getGeodesicGlsl("cameraPos","rayDirectionVec")};
						
						float distanceToScene = distanceEstimator(pos);

						float epsilon = max(t / (resolution * epsilonScaling), minEpsilon);
						
						if (distanceToScene < epsilon)
						{
							return computeShading(
								pos,
								epsilon,
								distanceToScene - 2.0 * epsilon,
								iteration
							);
						}
						
						else if (t > clipDistance)
						{
							return fogColor;
						}
						
						t += distanceToScene;
					}
					
					return fogColor;
				}
			`,a=useForDepthBuffer?`
					void main(void)
					{
						raymarch(
							imagePlaneCenterPos)
								+ rightVec * (uvScale * uv.x + uvCenter.x) * aspectRatio.x
								+ upVec * (uvScale * uv.y + uvCenter.y) * aspectRatio.y
						);
					}
				`:this.useFor3DPrinting?`
					void main(void)
					{
						gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);

						if (distanceEstimator(vec3(uv.x, uv.y, uvCenter.x) * uvScale) < epsilonScaling)
						{
							gl_FragColor = vec4(1.0);
						}
					}
				`:antialiasing?`
					vec3 raymarchHelper(vec2 uvAdjust)
					{
						return raymarch(
							imagePlaneCenterPos
								+ rightVec * (uvScale * (uv.x + uvAdjust.x) + uvCenter.x) * aspectRatio.x
								+ upVec * (uvScale * (uv.y + uvAdjust.y) + uvCenter.y) * aspectRatio.y
						);
					}
					
					void main(void)
					{
						vec2 texCoord = (uv + vec2(1.0)) * 0.5;
						vec4 sample = texture2D(uTexture, texCoord);
						
						if (sample.w > 0.15)
						{
							vec3 aaSample = (
								sample.xyz
								+ raymarchHelper(vec2(stepSize, 0.0))
								+ raymarchHelper(vec2(0.0, stepSize))
								+ raymarchHelper(vec2(-stepSize, 0.0))
								+ raymarchHelper(vec2(0.0, -stepSize))
							) / 5.0;
							
							gl_FragColor = vec4(aaSample, 1.0);
							return;
						}

						gl_FragColor = vec4(sample.xyz, 1.0);
					}
				`:`
				void main(void)
				{
					vec3 finalColor = raymarch(
						imagePlaneCenterPos
							+ rightVec * (uvScale * uv.x + uvCenter.x) * aspectRatio.x
							+ upVec * (uvScale * uv.y + uvCenter.y) * aspectRatio.y
					);

					gl_FragColor = vec4(finalColor.xyz, 1.0);
				}
			`,i=`
			precision highp float;
			
			varying vec2 uv;

			${this.uniformsGlsl}

			${antialiasing?`
				uniform sampler2D uTexture;
				uniform float stepSize;
			`:""}
			
			const vec3 lightPos = ${getVectorGlsl(this.lightPos)};
			const float lightBrightness = ${getFloatGlsl(this.lightBrightness)};
			const float bloomPower = ${getFloatGlsl(this.bloomPower)};
			
			const float clipDistance = ${getFloatGlsl(this.clipDistance)};
			const int maxMarches = ${this.maxMarches};
			const int maxShadowMarches = ${this.maxShadowMarches};
			const int maxReflectionMarches = ${this.maxReflectionMarches};
			const vec3 fogColor = ${getVectorGlsl(this.fogColor)};
			const float fogScaling = ${getFloatGlsl(this.fogScaling)};
			const float maxShadowAmount = 0.5;

			${useForDepthBuffer?doubleEncodingGlsl:""}

			${addGlsl}
			
			
			
			float distanceEstimator(vec3 pos)
			{
				${distanceEstimatorGlsl}
			}
			
			vec3 getColor(vec3 pos)
			{
				${getColorGlsl}
			}

			${this.useReflections?`float getReflectivity(vec3 pos)
			{
				${getReflectivityGlsl}
			}`:""}
			
			
			
			vec3 getSurfaceNormal(vec3 pos, float epsilon)
			{
				float xStep1 = distanceEstimator(pos + vec3(epsilon, 0.0, 0.0));
				float yStep1 = distanceEstimator(pos + vec3(0.0, epsilon, 0.0));
				float zStep1 = distanceEstimator(pos + vec3(0.0, 0.0, epsilon));
				
				float xStep2 = distanceEstimator(pos - vec3(epsilon, 0.0, 0.0));
				float yStep2 = distanceEstimator(pos - vec3(0.0, epsilon, 0.0));
				float zStep2 = distanceEstimator(pos - vec3(0.0, 0.0, epsilon));
				
				return normalize(vec3(xStep1 - xStep2, yStep1 - yStep2, zStep1 - zStep2));
			}

			${i}

			${e}

			${t}
			
			${s}

			${o}
			
			${a}
		`;return window.DEBUG&&console.log(i),i}reloadShader({distanceEstimatorGlsl,getColorGlsl,getReflectivityGlsl,addGlsl,useAntialiasing=this.useAntialiasing,useForDepthBuffer}={}){var e;this.useAntialiasing=useAntialiasing,this.wilson.loadShader({id:"draw",source:this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl,useForDepthBuffer:useForDepthBuffer}),uniforms:this.uniforms}),this.useAntialiasing&&(this.wilson.loadShader({id:"edgeDetect",source:edgeDetectShader,uniforms:{stepSize:1/this.resolution}}),e=this.createShader({distanceEstimatorGlsl:distanceEstimatorGlsl,getColorGlsl:getColorGlsl,getReflectivityGlsl:getReflectivityGlsl,addGlsl:addGlsl,useForDepthBuffer:useForDepthBuffer,antialiasing:!0}),this.wilson.loadShader({id:"antialias",source:e,uniforms:{...this.uniforms,stepSize:2/(3*this.resolution)}}),this.createTextures()),this.calculateVectors(),this.needNewFrame=!0}createTextures(){this.wilson.createFramebufferTexturePair({id:"0",textureType:"float"}),this.wilson.createFramebufferTexturePair({id:"1",textureType:"float"}),this.wilson.useFramebuffer(null),this.wilson.useTexture("0"),this.wilson.setUniforms({stepSize:1/this.resolution},"edgeDetect"),this.wilson.setUniforms({stepSize:2/(3*this.resolution)},"antialias"),this.wilson.useShader("draw")}setUniforms(uniforms){this.uniforms={...this.uniforms,...uniforms},this.wilson.setUniforms(uniforms,"draw"),this.useAntialiasing&&this.wilson.setUniforms(uniforms,"antialias"),this.needNewFrame=!0}calculateVectors(){this.forwardVec=[Math.cos(this.theta)*Math.sin(this.phi),Math.sin(this.theta)*Math.sin(this.phi),Math.cos(this.phi)],this.rightVec=normalize([this.forwardVec[1],-this.forwardVec[0],0]),this.upVec=crossProduct(this.rightVec,this.forwardVec),this.lockedOnOrigin&&(this.cameraPos=scaleVector(-this.distanceFromOrigin,this.forwardVec)),this.speedFactor=Math.min(this.distanceEstimator(this.cameraPos[0],this.cameraPos[1],this.cameraPos[2]),.5)/4,this.forwardVec[0]*=this.speedFactor/1.5,this.forwardVec[1]*=this.speedFactor/1.5,this.forwardVec[2]*=this.speedFactor/1.5,this.rightVec[0]*=this.speedFactor/this.fovFactor,this.rightVec[1]*=this.speedFactor/this.fovFactor,this.upVec[0]*=this.speedFactor/this.fovFactor,this.upVec[1]*=this.speedFactor/this.fovFactor,this.upVec[2]*=this.speedFactor/this.fovFactor,this.imagePlaneCenterPos=[this.cameraPos[0]+this.forwardVec[0]*this.focalLengthFactor,this.cameraPos[1]+this.forwardVec[1]*this.focalLengthFactor,this.cameraPos[2]+this.forwardVec[2]*this.focalLengthFactor],this.setUniforms({cameraPos:this.cameraPos,imagePlaneCenterPos:this.imagePlaneCenterPos,rightVec:this.rightVec,upVec:this.upVec}),this.needNewFrame=!1}distanceEstimator(){throw new Error("Distance estimator not implemented!")}prepareFrame(timeElapsed){this.touchDelay=Math.max(0,this.touchDelay-timeElapsed),this.moveUpdate(timeElapsed)}drawFrame(){this.theta=this.lockedOnOrigin?this.wilson.worldCenterX:2*Math.PI-this.wilson.worldCenterX,this.phi=this.lockedOnOrigin?this.wilson.worldCenterY:Math.PI-this.wilson.worldCenterY,this.calculateVectors(),this.useAntialiasing&&this.wilson.useFramebuffer("0"),this.wilson.drawFrame(),this.useAntialiasing&&(this.wilson.useShader("edgeDetect"),this.wilson.useTexture("0"),this.wilson.useFramebuffer("1"),this.wilson.drawFrame(),this.wilson.useShader("antialias"),this.wilson.useTexture("1"),this.wilson.useFramebuffer(null),this.wilson.drawFrame(),this.wilson.useShader("draw"))}downloadFrame(filename){this.drawFrame(),this.wilson.downloadFrame(filename,!1)}async downloadMosaic(filename,size){this.setUniforms({uvScale:1/size,resolution:this.resolution*size});const i=[];for(let e=0;e<size;e++)i.push((1+2*e)/size-1);const s=[];for(let t=0;t<size;t++){s.push([]);for(let e=0;e<size;e++)s[t].push(document.createElement("canvas")),s[t][e].width=this.resolution,s[t][e].height=this.resolution}const o=async()=>{var e=document.createElement("canvas"),t=(e.width=this.resolution*size,e.height=this.resolution*size,e.getContext("2d",{colorSpace:"display-p3"}));for(let i=0;i<size;i++)for(let e=0;e<size;e++)t.drawImage(s[i][e],i*this.resolution,e*this.resolution);t.translate(0,this.resolution*size),t.scale(1,-1),t.drawImage(e,0,0),e.toBlob(blob=>{var e=document.createElement("a");e.href=URL.createObjectURL(blob),e.download=filename,e.click()}),await new Promise(resolve=>setTimeout(resolve,100)),this.setUniforms({uvScale:1,uvCenter:[0,0],resolution:this.resolution}),this.needNewFrame=!0};let a=0,r=0;const l=async()=>{var e=s[a][r].getContext("2d",{colorSpace:"display-p3"}),t=(this.setUniforms({uvCenter:[i[a],i[r]]}),this.drawFrame(),new ImageData(new Uint8ClampedArray(this.wilson.readPixels()),this.resolution,this.resolution));e.putImageData(t,0,0),await new Promise(resolve=>setTimeout(resolve,500)),++r===size&&(r=0,a++),a!==size?requestAnimationFrame(l):o()};requestAnimationFrame(l)}touchDelay=0;numTouches=0;onTouchStart({event}){this.numTouches<=1&&2===event.touches.length?(this.numTouches=2,this.touchDelay=100):this.numTouches<=2&&3===event.touches.length?this.numTouches=3:this.numTouches=0}onTouchEnd({event}){event.touches.length<2&&(this.numTouches=0)}moveUpdate(timeElapsed){var e,t;0===this.touchDelay&&(2===this.numTouches?this.moveVelocity[0]=1:3===this.numTouches&&(this.moveVelocity[0]=-1)),this.keysPressed.w||2===this.numTouches?this.moveVelocity[0]=1:!this.keysPressed.s&&3!==this.numTouches||(this.moveVelocity[0]=-1),this.keysPressed.d?this.moveVelocity[1]=1:this.keysPressed.a&&(this.moveVelocity[1]=-1),this.keysPressed[" "]?this.moveVelocity[2]=1:this.keysPressed.shift&&(this.moveVelocity[2]=-1),this.lockedOnOrigin||0===this.moveVelocity[0]&&0===this.moveVelocity[1]&&0===this.moveVelocity[2]||(t=void 0!==this.lockZ?scaleVector(magnitude(this.forwardVec),normalize([this.forwardVec[0],this.forwardVec[1],0])):this.forwardVec,e=void 0!==this.lockZ?scaleVector(magnitude(this.rightVec),normalize([this.rightVec[0],this.rightVec[1],0])):this.rightVec,t=[this.moveVelocity[0]*t[0]+this.moveVelocity[1]*e[0],this.moveVelocity[0]*t[1]+this.moveVelocity[1]*e[1],this.moveVelocity[0]*t[2]+this.moveVelocity[1]*e[2]+this.moveVelocity[2]*this.speedFactor/1.5],this.cameraPos[0]+=this.movingSpeed*t[0]*(timeElapsed/6.944),this.cameraPos[1]+=this.movingSpeed*t[1]*(timeElapsed/6.944),this.cameraPos[2]=this.lockZ??this.cameraPos[2]+this.movingSpeed*t[2]*(timeElapsed/6.944),this.needNewFrame=!0);for(let i=0;i<3;i++)this.moveVelocity[i]*=this.moveFriction**(timeElapsed/6.944),Math.abs(this.moveVelocity[i])<this.moveStopThreshhold&&(this.moveVelocity[i]=0)}onResizeCanvas(){this.resolution=Math.sqrt(this.wilson.canvasWidth*this.wilson.canvasHeight),this.wilson.resizeWorld({minY:.001-this.wilson.worldHeight/2,maxY:Math.PI-.001+this.wilson.worldHeight/2}),this.setUniforms({aspectRatio:[this.wilson.worldWidth/this.worldSize,this.wilson.worldHeight/this.worldSize],resolution:this.resolution}),this.useAntialiasing&&this.createTextures(),this.needNewFrame=!0}animateUniform({name,value,duration=1e3}){const e={t:this.uniforms[name][1]};return anime({targets:e,t:value,duration:duration,easing:"easeInOutQuart",update:()=>{this.setUniform(name,e.t),this.needNewFrame=!0}}).finished}loopUniform({name,startValue,endValue,duration=2e3}){const e={t:0};return anime({targets:e,t:1,duration:duration,easing:"easeInOutQuad",loop:!0,direction:"alternate",update:()=>{this.setUniform(name,startValue+(endValue-startValue)*e.t),this.needNewFrame=!0}})}async setLockedOnOrigin(value){if(value&&!this.lockedOnOrigin){var t=magnitude(this.cameraPos);const s=normalize(this.cameraPos);var i=Math.acos(this.cameraPos[2]/t);let e=Math.PI-Math.atan2(this.cameraPos[1],this.cameraPos[0]);e>Math.PI&&(e-=2*Math.PI),e<-Math.PI&&(e+=2*Math.PI);const o={r:t,theta:2*Math.PI-this.theta,phi:Math.PI-this.phi};o.theta>Math.PI&&(o.theta-=2*Math.PI),o.theta<-Math.PI&&(o.theta+=2*Math.PI),await anime({targets:o,theta:e,phi:i,r:this.distanceFromOrigin,duration:500,easing:"easeOutCubic",update:()=>{this.wilson.resizeWorld({centerX:o.theta,centerY:o.phi}),this.cameraPos=scaleVector(o.r,s),this.needNewFrame=!0}}).finished}this.lockedOnOrigin=value,this.worldSize=this.lockedOnOrigin?2.5:1.5,this.wilson.resizeWorld({width:this.worldSize,height:this.worldSize,centerX:this.lockedOnOrigin?this.theta:2*Math.PI-this.theta,centerY:this.lockedOnOrigin?this.phi:Math.PI-this.phi,minY:.001-this.worldSize/2,maxY:Math.PI-.001+this.worldSize/2})}}function magnitude(vec){return Math.sqrt(vec[0]*vec[0]+vec[1]*vec[1]+vec[2]*vec[2])}function addVectors(vec1,vec2){return[vec1[0]+vec2[0],vec1[1]+vec2[1],vec1[2]+vec2[2]]}function scaleVector(c,vec){return[c*vec[0],c*vec[1],c*vec[2]]}function dotProduct(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]}function dotProduct4(vec1,vec2){return vec1[0]*vec2[0]+vec1[1]*vec2[1]+vec1[2]*vec2[2]+vec1[3]*vec2[3]}function crossProduct(vec1,vec2){return[vec1[1]*vec2[2]-vec1[2]*vec2[1],vec1[2]*vec2[0]-vec1[0]*vec2[2],vec1[0]*vec2[1]-vec1[1]*vec2[0]]}function matMul(mat1,mat2){return[[mat1[0][0]*mat2[0][0]+mat1[0][1]*mat2[1][0]+mat1[0][2]*mat2[2][0],mat1[0][0]*mat2[0][1]+mat1[0][1]*mat2[1][1]+mat1[0][2]*mat2[2][1],mat1[0][0]*mat2[0][2]+mat1[0][1]*mat2[1][2]+mat1[0][2]*mat2[2][2]],[mat1[1][0]*mat2[0][0]+mat1[1][1]*mat2[1][0]+mat1[1][2]*mat2[2][0],mat1[1][0]*mat2[0][1]+mat1[1][1]*mat2[1][1]+mat1[1][2]*mat2[2][1],mat1[1][0]*mat2[0][2]+mat1[1][1]*mat2[1][2]+mat1[1][2]*mat2[2][2]],[mat1[2][0]*mat2[0][0]+mat1[2][1]*mat2[1][0]+mat1[2][2]*mat2[2][0],mat1[2][0]*mat2[0][1]+mat1[2][1]*mat2[1][1]+mat1[2][2]*mat2[2][1],mat1[2][0]*mat2[0][2]+mat1[2][1]*mat2[1][2]+mat1[2][2]*mat2[2][2]]]}function qmul(x1,y1,z1,w1,x2,y2,z2,w2){return[x1*x2-y1*y2-z1*z1-w1*w2,x1*y2+y1*x2+z1*w2-w1*z2,x1*z2-y1*w2+z1*x2+w1*y2,x1*w2+y1*z2-z1*y2+w1*x2]}function normalize(vec){var e=magnitude(vec);return[vec[0]/e,vec[1]/e,vec[2]/e]}function getRotationMatrix(thetaX,thetaY,thetaZ){var e=Math.cos(thetaX),t=Math.sin(thetaX),i=Math.cos(thetaY),s=Math.sin(thetaY),o=Math.cos(thetaZ),a=Math.sin(thetaZ),t=[[1,0,0],[0,e,-t],[0,t,e]];return matMul(matMul([[o,-a,0],[a,o,0],[0,0,1]],[[i,0,-s],[0,1,0],[s,0,i]]),t)}function mat3TimesVector(mat,vec){return[mat[0][0]*vec[0]+mat[0][1]*vec[1]+mat[0][2]*vec[2],mat[1][0]*vec[0]+mat[1][1]*vec[1]+mat[1][2]*vec[2],mat[2][0]*vec[0]+mat[2][1]*vec[1]+mat[2][2]*vec[2]]}export{edgeDetectShader,RaymarchApplet,magnitude,addVectors,scaleVector,dotProduct,dotProduct4,crossProduct,matMul,qmul,normalize,getRotationMatrix,mat3TimesVector};