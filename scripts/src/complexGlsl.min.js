const glslFilenames=["equality","powers","trig","combinatorics","number-theory","gamma","hypergeometric","su3_character","lambert_w","hurwitz_zeta","zeta"],glslFiles={main:{dependencies:[],keywords:[]},constants:{dependencies:[],keywords:[]}};let doubleEmulationGlsl,doubleEncodingGlsl;function splitGlslFile(filename,text){text=text.replaceAll("\r","");let l=0;for(;;){var i=text.indexOf("#function",l);if(-1===i)break;var s=text.indexOf("\n",i+10);if(-1===s)return void console.error("[GLSL bundling] Invalid function name in file "+filename);let n=text.slice(i+10,s).split(" ");n=n.map(keyword=>keyword.replaceAll(" ",""));for(let e=0;e<n.length;e++)""===n[e]&&(n.splice(e,1),e--);var t=text.indexOf("#endfunction",s+1);if(-1===t)return void console.error("[GLSL bundling] Missing #endfunction in file "+filename);glslFiles[n[0]]={keywords:n};i=text.indexOf("#requires",i);if(-1!==i&&i<t){var a=text.indexOf("\n",i+10);let e=text.slice(i+10,a).split(" ");e=e.map(dependency=>dependency.replaceAll(" ",""));for(let l=0;l<e.length;l++)""===e[l]&&(e.splice(l,1),l--);glslFiles[n[0]].dependencies=e,glslFiles[n[0]].content=text.slice(a+1,t)}else glslFiles[n[0]].dependencies=[],glslFiles[n[0]].content=text.slice(s+1,t);l=t+13}}const glslFilesByDepth=[];let loadedGlsl=!1,loadGlslPromise;async function loadGlsl(){if(!loadedGlsl)return loadGlslPromise=!loadedGlsl&&loadGlslPromise?loadGlslPromise:loadGlslLogic()}async function loadGlslLogic(){var e=await(await fetch("/scripts/glsl/constants")).text();glslFiles.constants.content=e;e=await(await fetch("/scripts/glsl/main")).text();glslFiles.main.content=e;e=await(await fetch("/scripts/glsl/double_emulation")).text();doubleEmulationGlsl=e;e=await(await fetch("/scripts/glsl/double_encoding")).text();doubleEncodingGlsl=e;const l={};await Promise.all(glslFilenames.map(filename=>new Promise(resolve=>{fetch("/scripts/glsl/"+filename).then(response=>response.text()).then(text=>{l[filename]=text,resolve()})}))),glslFilenames.forEach(filename=>splitGlslFile(filename,l[filename]));e=Object.keys(glslFiles);e.forEach(filename=>glslFiles[filename].parents=[]),e.forEach(filename=>{var e=glslFiles[filename].dependencies;e.forEach(dependency=>glslFiles[dependency].parents.push(filename)),0===e.length&&"main"!==filename&&glslFiles.main.parents.push(filename)});let n=["main"],i=0;for(;0!==n.length;){const s=[];glslFilesByDepth.push([]),n.forEach(filename=>{void 0===glslFiles[filename].depth?glslFiles[filename].depth=i:glslFiles[filename].depth=Math.max(glslFiles[filename].depth,i),glslFiles[filename].parents.forEach(parent=>{s.includes(parent)||s.push(parent)})}),i++,n=s}e.forEach(filename=>glslFilesByDepth[glslFiles[filename].depth].push(filename)),loadedGlsl=!0}function getGlslBundle(codeString){const e=codeString.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);let l="";var n=Object.keys(glslFiles);const i={};n.forEach(filename=>i[filename]=!1),i.main=!0;let s="";n.forEach(filename=>{i[filename]||e.forEach(keyword=>{-1!==glslFiles[filename].keywords.indexOf(keyword)&&(s="[GLSL bundling] Adding "+filename,function e(filename,depth){i[filename]||(i[filename]=!0,0!==depth&&(s+="\n                     "+"   ".repeat(depth)+"â†³ "+filename),glslFiles[filename].dependencies.forEach(dependency=>e(dependency,depth+1)))}(filename,0),console.log(s))})}),l=glslFiles.constants.content+glslFiles.main.content;for(let t=1;t<glslFilesByDepth.length;t++)glslFilesByDepth[t].forEach(filename=>{i[filename]&&(l+=glslFiles[filename].content)});return l}export{doubleEmulationGlsl,doubleEncodingGlsl,loadGlsl,getGlslBundle};