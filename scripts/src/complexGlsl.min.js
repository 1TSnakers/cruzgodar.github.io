import{asyncFetch}from"./utils.min.js";const glslFilenames=["equality","powers","trig","combinatorics","number-theory","gamma","hypergeometric","su3_character","lambert_w","hurwitz_zeta","zeta"],glslFiles={main:{dependencies:[],keywords:[]},constants:{dependencies:[],keywords:[]}};let doubleEmulationGlsl,doubleEncodingGlsl;function splitGlslFile(filename,text){text=text.replaceAll("\r","");let e=0;for(;;){var n=text.indexOf("#function",e);if(-1===n)break;var t=text.indexOf("\n",n+10);if(-1===t)return void console.error("[GLSL bundling] Invalid function name in file "+filename);let s=text.slice(n+10,t).split(" ");s=s.map(keyword=>keyword.replaceAll(" ",""));for(let l=0;l<s.length;l++)""===s[l]&&(s.splice(l,1),l--);var i=text.indexOf("#endfunction",t+1);if(-1===i)return void console.error("[GLSL bundling] Missing #endfunction in file "+filename);glslFiles[s[0]]={keywords:s};n=text.indexOf("#requires",n);if(-1!==n&&n<i){var o=text.indexOf("\n",n+10);let l=text.slice(n+10,o).split(" ");l=l.map(dependency=>dependency.replaceAll(" ",""));for(let e=0;e<l.length;e++)""===l[e]&&(l.splice(e,1),e--);glslFiles[s[0]].dependencies=l,glslFiles[s[0]].content=text.slice(o+1,i)}else glslFiles[s[0]].dependencies=[],glslFiles[s[0]].content=text.slice(t+1,i);e=i+13}}const glslFilesByDepth=[];let loadedGlsl=!1,loadGlslPromise;async function loadGlsl(){if(!loadedGlsl)return loadGlslPromise=!loadedGlsl&&loadGlslPromise?loadGlslPromise:loadGlslLogic()}async function loadGlslLogic(){[glslFiles.constants.content,glslFiles.main.content,doubleEmulationGlsl,doubleEncodingGlsl]=await Promise.all([asyncFetch("/scripts/glsl/constants"),asyncFetch("/scripts/glsl/main"),asyncFetch("/scripts/glsl/double_emulation"),asyncFetch("/scripts/glsl/double_encoding")]);const l={};await Promise.all(glslFilenames.map(filename=>new Promise(resolve=>{asyncFetch("/scripts/glsl/"+filename).then(text=>{l[filename]=text,resolve()})})));for(const filename of glslFilenames)splitGlslFile(filename,l[filename]);var e=Object.keys(glslFiles);for(const filename of e)glslFiles[filename].parents=[];for(const filename of e){var s=glslFiles[filename].dependencies;for(const o of s)glslFiles[o].parents.push(filename);0===s.length&&"main"!==filename&&glslFiles.main.parents.push(filename)}let n=["main"],t=0;for(;0!==n.length;){var i=[];glslFilesByDepth.push([]);for(const filename of n){void 0===glslFiles[filename].depth?glslFiles[filename].depth=t:glslFiles[filename].depth=Math.max(glslFiles[filename].depth,t);for(const a of glslFiles[filename].parents)i.includes(a)||i.push(a)}t++,n=i}for(const filename of e)glslFilesByDepth[glslFiles[filename].depth].push(filename);loadedGlsl=!0}function getGlslBundle(codeString){var l=codeString.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);if(!l)return"";let e="";var s=Object.keys(glslFiles);const n={};for(const filename of s)n[filename]=!1;n.main=!0;let t="";for(const filename of s)if(!n[filename])for(const i of l)-1!==glslFiles[filename].keywords.indexOf(i)&&(t="[GLSL bundling] Adding "+filename,function l(filename,depth){if(!n[filename]){n[filename]=!0,0!==depth&&(t+="\n                     "+"   ".repeat(depth)+"â†³ "+filename);for(const e of glslFiles[filename].dependencies)l(e,depth+1)}}(filename,0),console.log(t));e=glslFiles.constants.content+glslFiles.main.content;for(let o=1;o<glslFilesByDepth.length;o++)for(const filename of glslFilesByDepth[o])n[filename]&&(e+=glslFiles[filename].content);return e}export{doubleEmulationGlsl,doubleEncodingGlsl,loadGlsl,getGlslBundle};