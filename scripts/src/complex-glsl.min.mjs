const glslFilenames=["equality","powers","trig","combinatorics","number-theory","gamma","hypergeometric","su3_character","lambert_w","hurwitz_zeta","zeta"],glslFiles={main:{dependencies:[],keywords:[]},constants:{dependencies:[],keywords:[]}};let doubleEmulationGlsl=null,doubleEncodingGlsl=null;function splitGlslFile(l,n){n=n.replaceAll("\r","");let e=0;for(;;){var t=n.indexOf("#function",e);if(-1===t)break;var i=n.indexOf("\n",t+10);if(-1===i)return void console.error("[GLSL bundling] Invalid function name in file "+l);let s=n.slice(t+10,i).split(" ");s=s.map(l=>l.replaceAll(" ",""));for(let l=0;l<s.length;l++)""===s[l]&&(s.splice(l,1),l--);var a=n.indexOf("#endfunction",i+1);if(-1===a)return void console.error("[GLSL bundling] Missing #endfunction in file "+l);glslFiles[s[0]]={keywords:s};t=n.indexOf("#requires",t);if(-1!==t&&t<a){var o=n.indexOf("\n",t+10);let e=n.slice(t+10,o).split(" ");e=e.map(l=>l.replaceAll(" ",""));for(let l=0;l<e.length;l++)""===e[l]&&(e.splice(l,1),l--);glslFiles[s[0]].dependencies=e,glslFiles[s[0]].content=n.slice(o+1,a)}else glslFiles[s[0]].dependencies=[],glslFiles[s[0]].content=n.slice(i+1,a);e=a+13}}const glslFilesByDepth=[];let loadedGlsl=!1;async function loadGlsl(){if(!loadedGlsl){var s=await(await fetch("/scripts/glsl/constants")).text();glslFiles.constants.content=s;s=await(await fetch("/scripts/glsl/main")).text();glslFiles.main.content=s;s=await(await fetch("/scripts/glsl/double_emulation")).text();doubleEmulationGlsl=s;s=await(await fetch("/scripts/glsl/double_encoding")).text();doubleEncodingGlsl=s;const n={};await Promise.all(glslFilenames.map(s=>new Promise(e=>{fetch("/scripts/glsl/"+s).then(l=>l.text()).then(l=>{n[s]=l,e()})}))),glslFilenames.forEach(l=>splitGlslFile(l,n[l]));s=Object.keys(glslFiles);s.forEach(l=>glslFiles[l].parents=[]),s.forEach(e=>{var l=glslFiles[e].dependencies;l.forEach(l=>glslFiles[l].parents.push(e)),0===l.length&&"main"!==e&&glslFiles.main.parents.push(e)});let l=["main"],e=0;for(;0!==l.length;){const t=[];glslFilesByDepth.push([]),l.forEach(l=>{void 0===glslFiles[l].depth?glslFiles[l].depth=e:glslFiles[l].depth=Math.max(glslFiles[l].depth,e),glslFiles[l].parents.forEach(l=>{t.includes(l)||t.push(l)})}),e++,l=t}s.forEach(l=>glslFilesByDepth[glslFiles[l].depth].push(l)),loadedGlsl=!0}}function getGlslBundle(l){const s=l.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);let e="";l=Object.keys(glslFiles);const n={};l.forEach(l=>n[l]=!1),n.main=!0;let t="";l.forEach(e=>{n[e]||s.forEach(l=>{-1!==glslFiles[e].keywords.indexOf(l)&&(t="[GLSL bundling] Adding "+e,function e(l,s){n[l]||(n[l]=!0,0!==s&&(t+="\n                     "+"   ".repeat(s)+"â†³ "+l),glslFiles[l].dependencies.forEach(l=>e(l,s+1)))}(e,0),console.log(t))})}),e=glslFiles.constants.content+glslFiles.main.content;for(let l=1;l<glslFilesByDepth.length;l++)glslFilesByDepth[l].forEach(l=>{n[l]&&(e+=glslFiles[l].content)});return e}export{doubleEmulationGlsl,doubleEncodingGlsl,loadGlsl,getGlslBundle};