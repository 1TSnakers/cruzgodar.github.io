const glslFilenames=["equality","powers","trig","combinatorics","number-theory","gamma","hypergeometric","su3_character","lambert_w","hurwitz_zeta","zeta"],glslFiles={main:{dependencies:[],keywords:[]},constants:{dependencies:[],keywords:[]}};let doubleEmulationGlsl=null,doubleEncodingGlsl=null;function splitGlslFile(filename,text){text=text.replaceAll("\r","");let l=0;for(;;){var i=text.indexOf("#function",l);if(-1===i)break;var t=text.indexOf("\n",i+10);if(-1===t)return void console.error("[GLSL bundling] Invalid function name in file "+filename);let n=text.slice(i+10,t).split(" ");n=n.map(keyword=>keyword.replaceAll(" ",""));for(let e=0;e<n.length;e++)""===n[e]&&(n.splice(e,1),e--);var s=text.indexOf("#endfunction",t+1);if(-1===s)return void console.error("[GLSL bundling] Missing #endfunction in file "+filename);glslFiles[n[0]]={keywords:n};i=text.indexOf("#requires",i);if(-1!==i&&i<s){var a=text.indexOf("\n",i+10);let e=text.slice(i+10,a).split(" ");e=e.map(dependency=>dependency.replaceAll(" ",""));for(let l=0;l<e.length;l++)""===e[l]&&(e.splice(l,1),l--);glslFiles[n[0]].dependencies=e,glslFiles[n[0]].content=text.slice(a+1,s)}else glslFiles[n[0]].dependencies=[],glslFiles[n[0]].content=text.slice(t+1,s);l=s+13}}const glslFilesByDepth=[];let loadedGlsl=!1;async function loadGlsl(){if(!loadedGlsl){var n=await(await fetch("/scripts/glsl/constants")).text();glslFiles.constants.content=n;n=await(await fetch("/scripts/glsl/main")).text();glslFiles.main.content=n;n=await(await fetch("/scripts/glsl/double_emulation")).text();doubleEmulationGlsl=n;n=await(await fetch("/scripts/glsl/double_encoding")).text();doubleEncodingGlsl=n;const i={};await Promise.all(glslFilenames.map(filename=>new Promise(resolve=>{fetch("/scripts/glsl/"+filename).then(response=>response.text()).then(text=>{i[filename]=text,resolve()})}))),glslFilenames.forEach(filename=>splitGlslFile(filename,i[filename]));n=Object.keys(glslFiles);n.forEach(filename=>glslFiles[filename].parents=[]),n.forEach(filename=>{var e=glslFiles[filename].dependencies;e.forEach(dependency=>glslFiles[dependency].parents.push(filename)),0===e.length&&"main"!==filename&&glslFiles.main.parents.push(filename)});let e=["main"],l=0;for(;0!==e.length;){const t=[];glslFilesByDepth.push([]),e.forEach(filename=>{void 0===glslFiles[filename].depth?glslFiles[filename].depth=l:glslFiles[filename].depth=Math.max(glslFiles[filename].depth,l),glslFiles[filename].parents.forEach(parent=>{t.includes(parent)||t.push(parent)})}),l++,e=t}n.forEach(filename=>glslFilesByDepth[glslFiles[filename].depth].push(filename)),loadedGlsl=!0}}function getGlslBundle(codeString){const e=codeString.match(/[a-zA-Z_][a-zA-Z0-9_]*/g);let l="";var n=Object.keys(glslFiles);const i={};n.forEach(filename=>i[filename]=!1),i.main=!0;let t="";n.forEach(filename=>{i[filename]||e.forEach(keyword=>{-1!==glslFiles[filename].keywords.indexOf(keyword)&&(t="[GLSL bundling] Adding "+filename,function e(filename,depth){i[filename]||(i[filename]=!0,0!==depth&&(t+="\n                     "+"   ".repeat(depth)+"â†³ "+filename),glslFiles[filename].dependencies.forEach(dependency=>e(dependency,depth+1)))}(filename,0),console.log(t))})}),l=glslFiles.constants.content+glslFiles.main.content;for(let s=1;s<glslFilesByDepth.length;s++)glslFilesByDepth[s].forEach(filename=>{i[filename]&&(l+=glslFiles[filename].content)});return l}export{doubleEmulationGlsl,doubleEncodingGlsl,loadGlsl,getGlslBundle};